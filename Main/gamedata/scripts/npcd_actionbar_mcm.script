local npcdu = npcd_utils
local NPCD = npcd
local FEAT_MODE = NPCD.FEAT_MODE
local FEAT_SETTING = NPCD.FEAT_SETTING
local KEYBIND = NPCD.KEYBIND

function on_mcm_load()
	op = { id = "actionbar", text = "ui_mcm_menu_npcd_actionbar", gr = get_actionbar_menu(),
    }
	return op, "npcd"
end

local function start_ui(self)
    self:On_Cancel()
    start()
end

local function level_present()
    return level.present()
end

function get_actionbar_menu()
	-- printf("/[NPCD][Main] get_actionbar_menu")
	local actionbar_menu = {}

	-- build actionbar main menu
    local main_options = {
        { id = "title", type = "slide", link = "ui_options_slider_player", text = "ui_mcm_npcd_actionbar_main_title", size = {512,50}, spacing = 20 },
        { id = "desc", type = "desc", clr = {200, 200, 255, 200}, text = "ui_mcm_npcd_actionbar_main_desc" },
		{ id = "max_slots", type = "input", val = 2, def = 8, min = 1, max = npcd_actionbar.MAX_SLOTS},
		{ id = "show_empty", type = "check", val = 1, def = true },
        { id = "show_always", type = "check", val = 1, def = false },
		{ id = "divider", type = "line" },
		{ id = "offset_x", type = "input", val = 2, def = 180, max = 1024, min = 0 },
		{ id = "offset_y", type = "input", val = 2, def = 720, max = 768, min = 0 },
		{ id = "divider", type = "line" },
		{ id = "adjust_position", type = "button", functor_ui = {start_ui}, precondition = {level_present}},
    }

	-- add main menu to actionbar menu
	local main_menu = { id="main", text="ui_mcm_menu_npcd_actionbar_main", sh=true, gr=main_options}
	table.insert(actionbar_menu, main_menu)

	-- add slots menu to actionbar menu
	local slots_options = {
        { id = "title", type = "slide", link = "ui_options_slider_player", text = "ui_mcm_npcd_actionbar_slots_title", size = {512,50}, spacing = 20 },
        { id = "desc", type = "desc", clr = {200, 200, 255, 200}, text = "ui_mcm_npcd_actionbar_slots_desc" },
    }
	table.insert(slots_options, { id = "divider", type = "line" })

	local actionbar = npcd_actionbar.get_actionbar()
	-- npcdu.printlog_table("on_mcm_load actionbar.by_key", actionbar.by_key)
	for key, action_slot in pairs(actionbar.by_key) do
		-- npcdu.printlog_table("on_mcm_load action_slot", action_slot)
		local npc = npcdu.get_npc_obj(action_slot.npc_id)
    	local feat = npcd.get_npc_feat_data(action_slot.npc_id, action_slot.feat_id)
        if feat then
            table.insert(slots_options, { id = action_slot.key .. "_feat", type = "slide", link = "ui_options_slider_night", size = {512,50}, ui_hook_functor= {npcd_mcm.do_ui_feat_header}, icon = feat.icon, name = feat.name, spacing = 20, borderless=true, })
            table.insert(slots_options, { id = action_slot.key .. "_npc", type = "desc", clr = {200, 180, 4, 219}, text = npc and npc:character_name() or npc_id })
            table.insert(slots_options, {id = action_slot.key .. "_" .. FEAT_SETTING.INDEX, type = "input", hint = "st_npcd_action_slot_index", val = 2, def = action_slot.index, min = 1, max = npcd_actionbar.settings.max_slots or npcd_actionbar.MAX_SLOTS})
            -- keybind
            local keybind_grp = {
                key_bind = {
                    id = action_slot.key .. "_" .. FEAT_SETTING.KEYBIND.KEY,
                    hint = "st_npcd_feat_keybind",
                    default = feat.activation_key.keybind or DIK_keys.DIK_H,
                },
                mode = {
                    id = action_slot.key .. "_" .. FEAT_SETTING.KEYBIND.MODIFIER,
                    default = feat.activation_key.modifier or KEYBIND.MODIFIER.PRESS,
                },
                modifier = {
                    id = action_slot.key .. "_" .. FEAT_SETTING.KEYBIND.SECOND_KEY,
                    default = feat.activation_key.second_key or KEYBIND.SECOND_KEY.NONE,
                }
            }
            npcd_mcm.add_keybind(slots_options, keybind_grp)
        end
	end

	-- build slots menu
    local slots_menu = { id="slots", text="ui_mcm_menu_npcd_actionbar_slots", sh=true, gr=slots_options}

	table.insert(actionbar_menu, slots_menu)
	-- npcdu.printlog_table("on_mcm_load actionbar_menu", actionbar_menu)
	return actionbar_menu
end

function get_feat_activation_input(npc_id, feat)
    local activation_key = {
        keybind = npcd_mcm.get_setting("actionbar", "slots/" .. npc_id .. "_" .. feat.id .. "_" .. FEAT_SETTING.KEYBIND.KEY),
        modifier = npcd_mcm.get_setting("actionbar", "slots/" .. npc_id .. "_" .. feat.id .. "_" .. FEAT_SETTING.KEYBIND.MODIFIER),
        second_key = npcd_mcm.get_setting("actionbar", "slots/" .. npc_id .. "_" .. feat.id .. "_" .. FEAT_SETTING.KEYBIND.SECOND_KEY)

    }
    local feat_activation_input = {
        activation_key = activation_key,
        activation_functor = feat.activation_functor
    }
	-- npcdu.printlog_table("get_feat_activation_input", feat_activation_input)
    return feat_activation_input
end

function get_feat_index_slot(npc_id, feat_id)
	return npcd_mcm.get_setting("actionbar", "slots/" .. npc_id .. "_" .. feat_id .. "_" .. FEAT_SETTING.INDEX)
end

function update_mcm_menu()
	local op, module = on_mcm_load()

	-- npcdu.printlog_table("update_mcm_menu npcd op", op)
	for i=1, #ui_mcm.options do
		if ui_mcm.options[i].id == module then
			-- printf("> menu %s ID %s", i, ui_mcm.options[i].id)
			for j=1, #ui_mcm.options[i].gr do
				if ui_mcm.options[i].gr[j].id == "actionbar" then
					-- printf("> submenu %s ID %s", j, ui_mcm.options[i].gr[j].id)
					ui_mcm.options[i].gr[j] = op
				end
			end
		end
	end
	ui_mcm.init_opt_coder()
	-- npcdu.printlog_table("update_mcm_menu", ui_mcm.options)
end

local commands = {
    -- { 
    --     name = "ui_mcm_ui_popup_messages_apm_main_scaling",
    --     get = function() return npcd_mcm.get_setting("actionbar", "main/scaling") end,
    --     set = function(val) npcd_mcm.set_setting("actionbar", "main/scaling", val); update_option("scaling", val) end,
    --     def = 1,
    --     min = 1,
    --     max = 4,
    --     step = 1
    -- },
    {
        name = "ui_mcm_npcd_actionbar_main_offset_x",
        get = function() return npcd_mcm.get_setting("actionbar", "main/offset_x") end,
        set = function(val) npcd_mcm.set_setting("actionbar", "main/offset_x", val); npcd_actionbar.settings.offset_x = val end,
        def = 180,
        min = 0,
        max = 1024,
        step = 1
    },
    { 
        name = "ui_mcm_npcd_actionbar_main_offset_y",
        get = function() return npcd_mcm.get_setting("actionbar", "main/offset_y") end,
        set = function(val) npcd_mcm.set_setting("actionbar", "main/offset_y", val); npcd_actionbar.settings.offset_y = val end,
        def = 720,
        min = 0,
        max = 768,
        step = 1
    },
}

-------------------------------------------------------------------
GUI = nil -- instance, don't touch
function start()
    exec_console_cmd("main_menu off")

    if (not GUI) then
        GUI = UIActionbarControl()
    end

    if (GUI) and (not GUI:IsShown()) then
        GUI:ShowDialog(true)
        Register_UI("UIActionbarControl","npcd_actionbar_mcm")
        npcd_actionbar_hud.activate_hud()
		npcd_actionbar_hud.HUD:SetTestMode(true)
        RemoveDelayDisableControlMode()
    end
end

function DelayDisableControlMode()
    CreateTimeEvent("npcd_actionbar_mcm", "DelayDisableControlMode", 2, function()
        if npcd_actionbar_hud.HUD then
            npcd_actionbar_hud.deactivate_hud()
            npcd_actionbar_hud.activate_hud()
        end
        return true
    end) 
end

function RemoveDelayDisableControlMode()
    RemoveTimeEvent("npcd_actionbar_mcm", "DelayDisableControlMode")
end

-------------------------------------------------------------------
class "UIActionbarControl" (CUIScriptWnd)

function UIActionbarControl:__init() super()
    self:InitControls()
    RegisterScriptCallback("actor_on_net_destroy", self)
end

function UIActionbarControl:__finalize()
    DelayDisableControlMode()
end

function UIActionbarControl:actor_on_net_destroy()
    self:Close()
    DelayDisableControlMode()
    GUI = nil
end

function UIActionbarControl:InitControls()
    self:SetWndRect         (Frect():set(0,0,1024,768))
    self:SetAutoDelete(true)
    
    self.xml = CScriptXmlInit()
    
    local xml = self.xml
    xml:ParseFile           ("ui_options.xml")
    
    self.dialog = xml:InitStatic("ctrl_lighting", self)
    
    xml:InitFrame("ctrl_lighting:frame", self.dialog)
    local cap = xml:InitStatic("ctrl_lighting:cap_main",self.dialog)
    cap:TextControl():SetText("Offsets")
    self.scroll = xml:InitScrollView("ctrl_lighting:scroll", self.dialog)
    self.scroll:Clear()
    
    self.Track = {}
    self.Value = {}
    self.Num = {}
    for i=1,#commands do
        local _st = xml:InitStatic("ctrl_lighting:st", nil)
        
        local tbl = commands[i]
        local name = tbl.name
        local val = tbl.get()
        local cap = xml:InitStatic("ctrl_lighting:cap", _st)
        cap:TextControl():SetText( game.translate_string(name) )
        
        self.Track[i] = xml:InitTrackBar("ctrl_lighting:track", _st)
        self.Track[i]:SetStep(tbl.step)
        self.Track[i]:SetOptFBounds(tbl.min, tbl.max)
        self.Track[i]:SetFValue(val)
        self.Value[i] = val
        self.Num[i] = xml:InitTextWnd("ctrl_lighting:num", _st)
        self.Num[i]:SetText(val)
        
        self.scroll:AddWindow(_st, true)
        _st:SetAutoDelete(true)
    end
    if #commands > 0 then
        local footer = xml:InitStatic("ctrl_lighting:cap_main",self.dialog)
        footer:SetWndPos( vector2():set( footer:GetWndPos().x, 30 + (#commands + 1) * 30 ) )
        footer:TextControl():SetText(game.translate_string("ui_mcm_npcd_actionbar_adjust_position_preview"))
    end
end

function UIActionbarControl:Callback_Track(i, val)
    local cmd = commands[i].set
    if cmd and val then
        cmd(val)
        self.Num[i]:SetText(val)
    end
end

function UIActionbarControl:Update()
    CUIScriptWnd.Update(self)
    
    -- Hack to simulate tracing method for TrackBar value changes. TODO: add callback support for CUITrackBar in engine, this is just silly
    for i,ctrl in pairs(self.Track) do
        if ctrl:IsCursorOverWindow() then
            local val = round_idp(ctrl:GetFValue(), precision)
            if (val ~= self.Value[i]) then
                self.Value[i] = val
                self:Callback_Track(i, val)
                return
            end
        end
    end
end

function UIActionbarControl:OnKeyboard(dik, keyboard_action)
    local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
    if (res == false) then
        local bind = dik_to_bind(dik)
        if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
        
            if dik == DIK_keys.DIK_ESCAPE then
                self:Close()
            end
            if dik == DIK_keys.DIK_SPACE then
                self:PreviewHud()
            end
        end
    end

    return res
end

function UIActionbarControl:Close()
    self:HideDialog()
    self:Show(false)

    Unregister_UI("UIActionbarControl")
    DelayDisableControlMode()
    GUI = nil
	-- ui_mcm.open_to("npcd/actionbar/main")
end

function UIActionbarControl:PreviewHud()
    self:HideDialog()
    self:Show(false)

    Unregister_UI("UIActionbarControl")
    DelayDisableControlMode()
    GUI = nil
	CreateTimeEvent("npcd_actionbar_mcm", "ReopenControlMode", 2, function()
        start()
        return true
    end)
end