function on_mcm_load()
    op = { id= "spotter", sh=true ,gr =
			{
				{ id = "title"						, type = "slide"    , link = "ui_options_slider_gameplay_diff", text = "ui_mcm_spotter_title", size = {512,50}, spacing = 20 },
				{id = "spotter_help1", type = "desc", clr = {200, 200, 255, 200}, text="ui_mcm_spotter_general_help1"},
				{id = "spotter_help2", type = "desc", clr = {200, 200, 255, 200}, text="ui_mcm_spotter_general_help2"},
				{id = "spotter_help3", type = "desc", clr = {200, 200, 255, 200}, text="ui_mcm_spotter_general_help3"},
				{id = "spotter_help4", type = "desc", clr = {200, 200, 255, 200}, text="ui_mcm_spotter_general_help4"},	
				{ id = "hotkey", type = "key_bind", val = 2, def = DIK_keys.DIK_C },
				{ id = "divider", type = "line" },
				{ id = "perk_chance"  	, type = "track"    , val = 2, min = 1, max = 100, step = 1, def = 10},
                { id = "marker_life"  	, type = "track"    , val = 2, min = 1, max = 60, step = 1, def = 15},
				{ id = "keep_spotting"  	, type ="check", val=1,def=false},
				{ id = "bark"  	, type ="check", val=1,def=true},
			}
		 }
    return op
end

local defaults = {
	["perk_chance"]     = 10,
	["marker_life"]     = 15,
	["keep_spotting"]     = false,
	["bark"]     = true,
	["hotkey"]     = DIK_keys.DIK_C
}

function get_config(key)
    local opt = ui_mcm and ui_mcm.get("spotter/"..key) 
    if opt ~= nil then return opt else return defaults[key] end
 end

local marker_life = defaults["marker_life"]
local keep_spotting = defaults["keep_spotting"]
local play_bark = defaults["bark"]
local hotkey_dik = defaults["hotkey"]
local perk_chance = defaults["perk_chance"]
function on_option_change()
	play_bark = get_config('bark')
    hotkey_dik = get_config('hotkey')
    marker_life = get_config('marker_life')
	perk_chance = get_config('perk_chance')
end

-- notifications

print_tip = function(text,delay, ...)

    -- local enabled = dynavision_mcm.get_config('configuration/notifications/enable')
	local enabled = true
    if enabled then
		local text = tostring(text)
		printf(text, ...)
		if not db.actor then
			return
		end
		
		local ico = "ui_inGame2_Dengi_otdani"
		local text_color = utils_xml.get_color("pda_white")
		local arg_color = utils_xml.get_color("d_green")
		local function colorize(s)
			return arg_color .. s .. text_color
		end
		local i = 0
		local t = {...}
		if #t > 0 then
			local function sr(a)
				i = i + 1
				if (type(t[i]) == 'userdata') then
					if (t[i].x and t[i].y) then
						return colorize(vec_to_str(t[i]))
					end
					return colorize('userdata')
				end
				return colorize(tostring(t[i]))
			end
			text = string.gsub(game.translate_string(text), "%%s", sr)
		else
			text = game.translate_string(text)
		end
		text = text_color .. text
		if delay == nil then
			delay = 6000
		end
		news_manager.send_tip(db.actor, text, nil, ico, delay)
	end
end


-- PERKS

local stalkers = {}
local PERKS = "perks"
local PERK_SPOTTER = "npc_perk_spotter"

function is_archetype_perk(npc, perk)
	local archetype = false
	if perk == PERK_SPOTTER then
		if npc:section() == "devushka" or npc:section() == "esc_2_12_stalker_fanat" then
			-- printf("/ npc %s archetype perk", npc:section())
			archetype = true
		end
	end	

	return archetype
end

function roll_perks(perk)
	local roll = false
	if perk == PERK_SPOTTER then
		roll = (math.random(100) <= perk_chance)
	end
	return roll
end

function check_npc_perk(npc, perk)
	if not npc then return end 
	local id = npc:id()
	if not stalkers[id] then
			-- save this NPC
		stalkers[id] = {}
		stalkers[id]["id"] = id
		stalkers[id][PERKS] = {}
		stalkers[id][PERKS][perk] = {}
		stalkers[id][PERKS][perk]["acquired"] = is_archetype_perk(npc, perk) or roll_perks(perk)
		if stalkers[id][PERKS][perk]["acquired"] then
			stalkers[id][PERKS][perk]["id"] = perk
			stalkers[id][PERKS][perk]["rank"] = 1
			print_tip("ui_mcm_spotter_has_perk", 15000, npc:character_name())
		end
	end
	return stalkers[id][PERKS][perk]["acquired"]
end

----
local function npc_joins_actor_squad(npc)
	if (npc and npc:alive()) then
		check_npc_perk(npc, PERK_SPOTTER)
	end
end

axrc_OG_add_to_actor_squad = axr_companions.add_to_actor_squad
function axr_companions.add_to_actor_squad(npc)
	axrc_OG_add_to_actor_squad(npc)
	SendScriptCallback("npc_joins_actor_squad", npc)
end

local function squad_on_npc_death(squad,se_npc)
	local npc = db.storage[se_npc.id] and db.storage[se_npc.id].object
	if not npc then return end
	-- printf("squad_on_npc_death name %s", npc and npc:name())
	local id = npc:id() or 0
	stalkers[id] = nil
end

function is_companions_squad_in_danger()
	--printf("============================================================================================")
	local squad_is_peaceful = true
	for id,squad in pairs(axr_companions.companion_squads) do 
		if (squad and squad.commander_id) then
			local i = 0
			for k in squad:squad_members() do
				local npc = db.storage[k.id] and db.storage[k.id].object
				i = i+1
				-- printf("companion[%s]", i)
				if npc then
					local is_peaceful = false
					-- check if is in fight
					if (npc and npc:alive()) then
						is_peaceful = (not npc:best_enemy()) and npc:dont_has_info("npcx_beh_ignore_combat") and true or false
					end
					-- printf("companion[%s] is_peaceful %s - dist: %s",k.id, is_peaceful, distance_between(db.actor,npc))
					-- check if is too far away
					squad_is_peaceful = squad_is_peaceful and is_peaceful
					-- printf("current calculation for squad is_peaceful %s", squad_is_peaceful)					
				end
				-- printf("--")
			end
		end
	end
	if not squad_is_peaceful then
		-- printf("squad is under attack or attacking")
	end
	--printf("squad is resolved peaceful %s", squad_is_peaceful)
	--printf("============================================================================================")
	return not squad_is_peaceful
end



local squad_is_peaceful
function actor_on_first_update()
    squad_is_peaceful = is_companions_squad_in_danger()
end


local tg_update = 0
local tg_update_step = 1000 --[ms]
function actor_on_update()

		local tg = time_global()
		if tg < tg_update then
			return
		end
		tg_update = tg + tg_update_step


		if keep_spotting then
			do_combat_on()
		end

        local in_danger_state = is_companions_squad_in_danger()
		-- printf("squad_is_peaceful %s, in_danger_state %s", squad_is_peaceful, in_danger_state)
        if squad_is_peaceful and in_danger_state then
			-- printf("spotter_combat_started")
            squad_is_peaceful = false
            SendScriptCallback("spotter_combat_started")
            return
        end

        if not squad_is_peaceful and not in_danger_state then
			-- printf("spotter_combat_ended")
            squad_is_peaceful = true
            SendScriptCallback("spotter_combat_ended")
            return
        end

		-- printf("spotter_combat_unknown")
end

local f = getFS()

function build_npc_barks_lib(npc)
	local npc_id = npc:id()
	stalkers[npc_id]["bark"] = {}
	local num = 1
	while f:exist("$game_sounds$",npc:sound_prefix().."fight\\enemy\\enemy_"..num..".ogg") do
		-- printf("adding sound ["..npc:sound_prefix().."fight\\enemy\\enemy_"..num.."] to table id = "..num)
		stalkers[npc_id]["bark"][num] = npc:sound_prefix().."fight\\enemy\\enemy_"..num
		num = num + 1
	end
end

function bark(npc)
	if not npc then return end
	local female_visual = npc:get_visual_name():find("fstalker")
	local female_voice = npc:sound_prefix():find("woman")
	-- printf("-- NPC id %s, name %s, section %s, sound_prefix %s, female_voice %s, female_visual %s", npc:id(), npc:name(), npc:section(), npc:sound_prefix(), female_voice, female_visual)
	local npc_id = npc:id()
	if female_visual or female_voice then
		file_to_say = xr_sound.get_safe_sound_object( "spotters\\command_fireatwill_" .. math.random(3))
	else
		if not stalkers[npc_id]["bark"] then
			build_npc_barks_lib(npc)
		end
		file_to_say = xr_sound.get_safe_sound_object(stalkers[npc_id]["bark"][math.random(#stalkers[npc_id]["bark"])]) --sets the file to play			
	end
	file_to_say:play(db.actor,0,sound_object.s2d) --plays it
	file_to_say.volume = 1.0 --sets how loud the sound should be

end

local hmm = utils_spotter_hudmarks.get_hud_mark_manager()

local function getArgs()

	local args = {

		texture         = "ui_icons_spotter_pin_cursor_chevron_e",
		-- a texture for the icon is required
		width           = 24,
		height          = 24,
		-- the size of the texture	
		xmlfile         = "ui_hud_marker.xml",
		-- The marker XML structure
		bone            = "bip01_head",
		near_end_dist   = 2,
		-- marker is automatically destroyed if actor gets this close
		far_end_dist     = 100,
		-- marker is automatically destroyed if actor gets this far away
		show_dist         = true,
		-- show distance indicator by the marker
		func_on_update = (
			function(mark, args)
				-- printf("func_on_update")
				local init_time = mark and mark.init_time or 0
				if time_global() - init_time > marker_life*1000 then mark:Destroy() end
			end
			)
	}

	return args
end

local marked_enemy
local marker
-- local marks = {}
function mark_enemy(enemy, npc)
    enemy = enemy or level.get_target_obj()
    -- printf("- Mark enemy %s by npc %s", enemy and enemy:id(), npc and npc:name())
    if (enemy and enemy:alive()) then
		marked_enemy = enemy
		local args = getArgs()
        args.id = enemy:id()
        marker = hmm:AddMarker(args)
		-- marks[enemy:id()] = marker
		if play_bark then
			bark(npc)
		end
    end
end

function find_enemy()
	printf("- Find enemy")
	local be_list = {}
	for id,squad in pairs(axr_companions.companion_squads) do 
		if (squad and squad.commander_id) then
			local i = 0
			for k in squad:squad_members() do
				local npc = db.storage[k.id] and db.storage[k.id].object
				i = i+1
				-- printf("companion[%s]", i)
				if npc then
					local be = npc:best_enemy()
					if (be and be:alive()) then
						-- local distance = be:position():distance_to_sqr(npc:position())
						-- printf("! FOUND ENEMY: %s %s distance %s", be:id(), be:name(), distance)
						if check_npc_perk(npc, PERK_SPOTTER) then
							-- printf("% NPC %s has spotter perk", npc:character_name())
							mark_enemy(be, npc)
							return
						end
						-- -- Add a new element
						-- table.insert(be_list, {be, distance})
					end
				end
			end
		end
	end

	-- local min_be = nil
	-- local min_distance = math.huge  -- Start with a very large number

	-- for _, pair in ipairs(be_list) do
	-- 	local be = pair[1]
	-- 	local distance = pair[2]

	-- 	if distance < min_distance then
	-- 		min_distance = distance
	-- 		min_be = be
	-- 	end
	-- end

	-- printf("-- ENEMY %s with smallest distance %s:", min_be and min_be:id(), min_distance)
	-- return min_be
end


function combat_started()
    -- printf("- TAKE POINT COMBAT [START]")
	
	-- do the first spotting
	local enemy = find_enemy()
	-- printf("-- marker added %s", marker)
end

function do_combat_on()
	if squad_is_peaceful then return end

	if marked_enemy then
		if not marked_enemy:alive() then
			marked_enemy = nil
		end
	else
		-- printf("- TAKE POINT COMBAT [TAG]")
		local enemy = find_enemy()
	end
end

function combat_ended()
    -- printf("! TAKE POINT COMBAT [END]")
end

local spotter_mark_issued
function on_key_press(dik)
	
	-- printf("-- bind %s == hotkey %s", dik, hotkey_dik)
	if (dik == hotkey_dik) then
		-- printf("- create spotter_mark_keyhold")
		CreateTimeEvent("spotter_mark_keypress", "spotter_mark_keypress_long", 0.5, function()
			printf("- execute spotter_mark_keyhold")
			local enemy = find_enemy()
			spotter_mark_issued = true
			return true
		end)		

	end
end

function on_key_release(dik)

	-- printf("-- bind %s == hotkey %s", dik, hotkey_dik)
	if dik == hotkey_dik then
		RemoveTimeEvent("spotter_mark_keypress", "spotter_mark_keypress_long")
		if spotter_mark_issued then
			-- printf("- consume spotter_mark_keyhold")
			spotter_mark_issued = false
		else
			if not zzzz_dynahud then
				axr_companions.on_key_release(dik)
			end
		end
	end

end

-- female_npc = {}
-- RegisterScriptCallback("on_specific_character_init", function(character_id, data)
-- 	printf("%% character_id %s", character_id)
-- 	if data.snd_config:find("(woman|female)") then
-- 		printf("% %s is a woman", character_id)
-- 		female_npc[character_id] = true
-- 	end
-- end)
local string_format = string.format
function printlog_table(text, node, ...)
    
    text = string_format(text, ...)
    printf("Spotter: | %s | \n" .. utils_data.print_table(node, text, true), time_global(), ...)
end

function save_state(m_data)
	printf("$ Spotter Save State")
    if not m_data.spotter then
        m_data.spotter = {}
    end 
    -- save the state
    m_data.spotter.stalkers = stalkers
	printlog_table("Stalkers", m_data.spotter.stalkers)
end

function load_state(m_data)
	printf("$ Spotter Load State")
	if m_data.spotter and m_data.spotter.stalkers then
        -- cache the state
		stalkers = m_data.spotter.stalkers
		printlog_table("Stalkers", stalkers)
	end
end

function on_game_start()
	RegisterScriptCallback("actor_on_first_update",actor_on_first_update)
	RegisterScriptCallback("actor_on_update",actor_on_update)
	RegisterScriptCallback('on_option_change', on_option_change)

    if AddScriptCallback then
        AddScriptCallback("spotter_combat_started")
        AddScriptCallback("spotter_combat_ended")
		AddScriptCallback("npc_joins_actor_squad")
    end

	if not zzzz_dynahud then
		UnregisterScriptCallback("on_key_release",axr_companions.on_key_release)
	end	
	RegisterScriptCallback("on_key_release", on_key_release)
	RegisterScriptCallback("on_key_press", on_key_press)

    RegisterScriptCallback("spotter_combat_started",combat_started)
    RegisterScriptCallback("spotter_combat_ended",combat_ended)

	on_option_change()
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("squad_on_npc_death",squad_on_npc_death)
	RegisterScriptCallback("npc_joins_actor_squad",npc_joins_actor_squad)
end