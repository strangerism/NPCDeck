local SM = z_stalkermon

function on_mcm_load()
    op = { id= "spotter", sh=true ,gr =
			{
				{ id = "title"						, type = "slide"    , link = "ui_options_slider_gameplay_diff", text = "ui_mcm_spotter_title", size = {512,50}, spacing = 20 },
				{id = "spotter_help1", type = "desc", clr = {200, 200, 255, 200}, text="ui_mcm_spotter_general_help1"},
				{id = "spotter_help2", type = "desc", clr = {200, 200, 255, 200}, text="ui_mcm_spotter_general_help2"},
				{id = "spotter_help3", type = "desc", clr = {200, 200, 255, 200}, text="ui_mcm_spotter_general_help3"},
				{id = "spotter_help4", type = "desc", clr = {200, 200, 255, 200}, text="ui_mcm_spotter_general_help4"},	
				{ id = "hotkey", type = "key_bind", val = 2, def = DIK_keys.DIK_C },
				{ id = "divider", type = "line" },
				{ id = "perk_chance"  	, type = "track"    , val = 2, min = 1, max = 100, step = 1, def = 10},
                { id = "marker_life"  	, type = "track"    , val = 2, min = 1, max = 60, step = 1, def = 15},
				{ id = "keep_spotting"  	, type ="check", val=1,def=false},
				{ id = "max_marks"  	, type = "track"    , val = 2, min = 1, max = 5, step = 1, def = 1},
				{ id = "bark"  	, type ="check", val=1,def=true},
			}
		 }
    return op
end

local defaults = {
	["perk_chance"]     = 10,
	["marker_life"]     = 15,
	["keep_spotting"]     = false,
	["max_marks"]     = 1,
	["bark"]     = true,
	["hotkey"]     = DIK_keys.DIK_C
}

function get_config(key)
    local opt = ui_mcm and ui_mcm.get("spotter/"..key) 
    if opt ~= nil then return opt else return defaults[key] end
 end

local marker_life = defaults["marker_life"]
local keep_spotting = defaults["keep_spotting"]
local play_bark = defaults["bark"]
local hotkey_dik = defaults["hotkey"]
local perk_chance = defaults["perk_chance"]
local max_marks = defaults["max_marks"]
function on_option_change()
	marker_life = get_config('marker_life')
	keep_spotting = get_config('keep_spotting')
	play_bark = get_config('bark')
    hotkey_dik = get_config('hotkey')
    perk_chance = get_config('perk_chance')
	max_marks = get_config('max_marks')
end

-- PERKS

local PERK_SPOTTER = {
	id = "npc_perk_spotter",
	abilities = {
		PERK_SPOTTER_ABILITY_CALLMARK = {
			id = "npc_perk_spotter_callmark",
			icon = "ui_icons_spotter_pin_redskull",
			cooldown = 180
		},
		PERK_SPOTTER_ABILITY_SPOT = {
			id = "npc_perk_spotter_spot",
			icon = "ui_icons_spotter_crosshair_gradient",
			cooldown = 30
		}
	},
	functor = nil,
}

local PERK_SPOTTER_ABILITY_CALLMARK = {
	id = "npc_perk_spotter_callmark",
	icon = "ui_icons_spotter_pin_redskull",
	cooldown = 180
}
local PERK_SPOTTER_ABILITY_SPOT = {
	id = "npc_perk_spotter_spot",
	icon = "ui_icons_spotter_crosshair_gradient",
	cooldown = 30
}

local function is_archetype_perk(npc_id)
	local archetype = false

	local npc = db.storage[npc_id] and db.storage[npc_id].object
	if npc and npc:section() == "devushka" or npc:section() == "esc_2_12_stalker_fanat" then
		printf("/ npc %s archetype perk", npc:section())
		archetype = true
	end

	return archetype
end

function roll_perk(npc_id)
	printf("! npc %s roll_perk perk", npc_id)
	return is_archetype_perk(npc_id) or (math.random(100) <= perk_chance)
end

local function is_spotter(npc)
	local npc_id = npc:id()
	printf("! npc %s is_spotter", npc_id)
	if SM.Add_npc(npc_id) then
		-- It's a new NPC lets roll the perk
		PERK_SPOTTER.functor = {"spotter_mcm","roll_perk", npc_id}
		if SM.Roll_perk(npc_id, PERK_SPOTTER) then
			SM.print_tip("ui_mcm_spotter_has_perk", 10000, npc:character_name())
		end
	end
	return SM.Has_perk(npc_id, PERK_SPOTTER.id)
end

local master_spotter_id = nil
function find_master_spotter()
	-- printf("--find_master_spotter")
	local master_npc = nil
	local clist = axr_companions.list_actor_squad_by_id()
	for i=1, #clist do
		local npc = db.storage[clist[i]] and db.storage[clist[i]].object
		if npc and npc:alive() and is_spotter(npc) then
			if master_npc == nil then
				master_npc = npc
			elseif master_npc:rank() < npc:rank() then
				master_npc = npc
			end
		end		
	end
	if master_npc then
		printf("// found master spotter %s with rank %s", master_npc:character_name(), ranks.get_se_obj_rank_name(master_npc))
		if master_npc:id() ~= master_spotter_id then
			local clist = axr_companions.list_actor_squad_by_id()
			for i=1, #clist do
				z_stalkermon.unregister_ability(clist[i], PERK_SPOTTER_ABILITY_CALLMARK)
				z_stalkermon.unregister_ability(clist[i], PERK_SPOTTER_ABILITY_SPOT)
			end			
			SM.print_tip("ui_mcm_spotter_master", 15000, master_npc:character_name())
			z_stalkermon.register_ability(master_npc:id(), PERK_SPOTTER_ABILITY_CALLMARK)
			z_stalkermon.register_ability(master_npc:id(), PERK_SPOTTER_ABILITY_SPOT)
		end
	else
		printf("// No spotters in squad")
	end
	
	return master_npc and master_npc:id() or nil
end

---- SQUAD UPDATES

update_master_spotter_requested = false
local function schedule_update_master_spotter()
	printf("-- schedule_update_master_spotter")
	if not update_master_spotter_requested then
		printf("// update_master_spotter_requested")
		update_master_spotter_requested = true
		CreateTimeEvent("spotter", "schedule_update_master_spotter", 1, function()
			-- printf("- execute spotter_mark_keyhold")
			master_spotter_id = find_master_spotter()
			update_master_spotter_requested = false
			return true
		end)		
	end
end
-----


function is_companions_squad_in_danger()
	--printf("============================================================================================")
	local squad_is_peaceful = true
	local clist = axr_companions.list_actor_squad_by_id()
	for i=1, #clist do
		local npc = db.storage[clist[i]] and db.storage[clist[i]].object
		if npc then
			local is_peaceful = false
			-- check if is in fight
			if npc:alive() then
				is_peaceful = (not npc:best_enemy()) and npc:dont_has_info("npcx_beh_ignore_combat") and true or false
			end
			-- printf("companion[%s] is_peaceful %s - dist: %s",k.id, is_peaceful, distance_between(db.actor,npc))
			-- check if is too far away
			squad_is_peaceful = squad_is_peaceful and is_peaceful
			-- printf("current calculation for squad is_peaceful %s", squad_is_peaceful)					
		end	
	end	
	if not squad_is_peaceful then
		-- printf("squad is under attack or attacking")
	end
	-- printf("-- squad is resolved peaceful %s", squad_is_peaceful)
	--printf("============================================================================================")
	return not squad_is_peaceful
end



local squad_is_peaceful = true
function actor_on_first_update()
    squad_is_peaceful = is_companions_squad_in_danger()
end


local tg_update = 0
local tg_update_step = 1000 --[ms]
function actor_on_update()

		local tg = time_global()
		if tg < tg_update then
			return
		end
		tg_update = tg + tg_update_step


		if not squad_is_peaceful and keep_spotting then
			-- printf("keep_spotting")
			do_keep_spotting()
		end

		if not squad_is_peaceful then
			update_marks()
		end

        local in_danger_state = is_companions_squad_in_danger()
		-- printf("squad_is_peaceful %s, in_danger_state %s", squad_is_peaceful, in_danger_state)
        if squad_is_peaceful and in_danger_state then
			-- printf("spotter_combat_started")
            squad_is_peaceful = false
            SendScriptCallback("spotter_combat_started")
            return
        end

        if not squad_is_peaceful and not in_danger_state then
			-- printf("spotter_combat_ended")
            squad_is_peaceful = true
            SendScriptCallback("spotter_combat_ended")
            return
        end

		-- printf("spotter_combat_unknown")
end

local f = getFS()

function build_npc_barks_lib(npc)
	local npc_id = npc:id()
	SM.stalkers[npc_id]["bark"] = {}
	local num = 1
	while f:exist("$game_sounds$",npc:sound_prefix().."fight\\enemy\\enemy_"..num..".ogg") do
		-- printf("adding sound ["..npc:sound_prefix().."fight\\enemy\\enemy_"..num.."] to table id = "..num)
		SM.stalkers[npc_id]["bark"][num] = npc:sound_prefix().."fight\\enemy\\enemy_"..num
		num = num + 1
	end
end

function bark(npc)
	if not npc then return end
	local female_visual = npc:get_visual_name():find("fstalker")
	local female_voice = npc:sound_prefix():find("woman")
	-- printf("-- NPC id %s, name %s, section %s, sound_prefix %s, female_voice %s, female_visual %s", npc:id(), npc:name(), npc:section(), npc:sound_prefix(), female_voice, female_visual)
	local npc_id = npc:id()
	if female_visual or female_voice then
		file_to_say = xr_sound.get_safe_sound_object( "spotters\\command_fireatwill_" .. math.random(3))
	else
		if not SM.stalkers[npc_id]["bark"] then
			build_npc_barks_lib(npc)
		end
		file_to_say = xr_sound.get_safe_sound_object(SM.stalkers[npc_id]["bark"][math.random(#SM.stalkers[npc_id]["bark"])]) --sets the file to play			
	end
	file_to_say:play(db.actor,0,sound_object.s2d) --plays it
	file_to_say.volume = 1.0 --sets how loud the sound should be

end

local hmm = utils_spotter_hudmarks.get_hud_mark_manager()

local function getArgs(id)

	local args = {
		npc_perk_spotter_callmark = {

			texture         = "ui_icons_spotter_pin_redskull",
			-- a texture for the icon is required
			width           = 24,
			height          = 24,
			-- the size of the texture	
			xmlfile         = "ui_hud_marker.xml",
			-- The marker XML structure
			bone            = "bip01_head",
			near_end_dist   = 2,
			-- marker is automatically destroyed if actor gets this close
			far_end_dist     = 300,
			-- marker is automatically destroyed if actor gets this far away
			show_dist         = true,
			-- show distance indicator by the marker
			-- func_on_update = (
			-- 	function(mark, args)
			-- 		-- printf("func_on_update")
			-- 		local init_time = mark and mark.init_time or 0
			-- 		if time_global() - init_time > marker_life*1000 then mark:Destroy() end
			-- 	end
			-- 	)
		},
		npc_perk_spotter_spot = {

			texture         = "ui_icons_spotter_pin_cursor_chevron_e",
			-- a texture for the icon is required
			width           = 24,
			height          = 24,
			-- the size of the texture	
			xmlfile         = "ui_hud_marker.xml",
			-- The marker XML structure
			bone            = "bip01_head",
			near_end_dist   = 2,
			-- marker is automatically destroyed if actor gets this close
			far_end_dist     = 100,
			-- marker is automatically destroyed if actor gets this far away
			show_dist         = true,
			-- show distance indicator by the marker
			func_on_update = (
				function(mark, args)
					-- printf("func_on_update")
					local init_time = mark and mark.init_time or 0
					if time_global() - init_time > marker_life*1000 then mark:Destroy() end
				end
				)
		}	
	}
	return args[id]
end


function tableSize(t)
    local count = 0
    for _ in pairs(t) do
        count = count + 1
    end
    return count
end


local callmark
local marks = {}
function mark_enemy(enemy, npc)
    enemy = enemy or level.get_target_obj()
    -- printf("- Mark enemy %s by npc %s", enemy and enemy:id(), npc and npc:name())
    if enemy and enemy:alive() and not marks[enemy:id()] then
		z_stalkermon.activate_ability(master_spotter_id, PERK_SPOTTER_ABILITY_SPOT)
		local args = getArgs(PERK_SPOTTER_ABILITY_SPOT.id)
        args.id = enemy:id()
        marker, mark_id = hmm:AddMarker(args)
		marks[enemy:id()] = mark_id
		printf("-- added marker %s for new enemy %s", mark_id, enemy:id())
		printf("// active marks increased to %s", tableSize(marks))
		if play_bark then
			bark(npc)
		end
    end
end

function update_marks()
	for id, marker in pairs(marks) do
		local se_obj = id and alife_object(id)
		if se_obj and (not se_obj:alive()) then
			printf("!! removing marker %s for dead enemy %s", marker, se_obj.id)
			hmm:DelMarker(marker)
			marks[id] = nil
		end
	end
end

function spot_enemy(npc, be_list)
	-- printf("% NPC %s uses spotter perk", npc:character_name())
	local be = npc:best_enemy()
	if (be and be:alive()) then
		local distance = be:position():distance_to_sqr(npc:position())
		-- printf("* FOUND ENEMY: %s %s distance %s", be:id(), be:name(), distance)
		mark_enemy(be, npc)
		-- -- Add a new element
		-- table.insert(be_list, {be, distance})
	end
end

function find_enemy(spotter_id)
	-- printf("- Find enemy")
	local be_list = {}
	if spotter_id then
		local npc = db.storage[spotter_id] and db.storage[spotter_id].object
		if npc and npc:alive() then
			spot_enemy(npc, be_list)
		end
	else
		local clist = axr_companions.list_actor_squad_by_id()
		for i=1, #clist do
			local npc = db.storage[clist[i]] and db.storage[clist[i]].object
			if npc and npc:alive() and is_spotter(npc) then
				spot_enemy(npc, be_list)
				return
			end
		end

		-- local min_be = nil
		-- local min_distance = math.huge  -- Start with a very large number

		-- for _, pair in ipairs(be_list) do
		-- 	local be = pair[1]
		-- 	local distance = pair[2]

		-- 	if distance < min_distance then
		-- 		min_distance = distance
		-- 		min_be = be
		-- 	end
		-- end

		-- printf("-- ENEMY %s with smallest distance %s:", min_be and min_be:id(), min_distance)
		-- return min_be		
	end
end


function combat_started()
    -- printf("- TAKE POINT COMBAT [START]")
	if not master_spotter_id then
		master_spotter_id = find_master_spotter()
	end
	-- do the first spotting
	local enemy = find_enemy(master_spotter_id)
	-- printf("-- marker added %s", marker)
end

function do_keep_spotting()
	-- printf("do_keep_spotting - active marks %s/%s", tableSize(marks), max_marks)
	if tableSize(marks) < max_marks then
		-- printf("- TAKE POINT COMBAT [TAG]")
		local enemy = find_enemy(master_spotter_id)
	end
end

function combat_ended()
    -- printf("! TAKE POINT COMBAT [END]")
	marks = {}
end

local spotter_mark_issued
function on_key_press(dik)
	
	-- printf("-- bind %s == hotkey %s", dik, hotkey_dik)
	if (dik == hotkey_dik) then
		-- printf("- create spotter_mark_keyhold")
		if true then -- not squad_is_peaceful then
			CreateTimeEvent("spotter_mark_keypress", "spotter_mark_keypress_long", 0.5, function()
				-- printf("- execute spotter_mark_keyhold")
				local enemy = find_enemy(master_spotter_id)
				z_stalkermon.activate_ability(master_spotter_id, PERK_SPOTTER_ABILITY_CALLMARK)
				z_stalkermon.activate_ability(master_spotter_id, PERK_SPOTTER_ABILITY_SPOT)
				spotter_mark_issued = true
				return true
			end)
		end
	end
end

function on_key_release(dik)

	-- printf("-- bind %s == hotkey %s", dik, hotkey_dik)
	if dik == hotkey_dik then
		RemoveTimeEvent("spotter_mark_keypress", "spotter_mark_keypress_long")
		if spotter_mark_issued then
			-- printf("- consume spotter_mark_keyhold")
			spotter_mark_issued = false
		else
			if not zzzz_dynahud then
				axr_companions.on_key_release(dik)
			end
		end
	end

end

-- female_npc = {}
-- RegisterScriptCallback("on_specific_character_init", function(character_id, data)
-- 	printf("%% character_id %s", character_id)
-- 	if data.snd_config:find("(woman|female)") then
-- 		printf("% %s is a woman", character_id)
-- 		female_npc[character_id] = true
-- 	end
-- end)

if AddScriptCallback then
	AddScriptCallback("spotter_combat_started")
	AddScriptCallback("spotter_combat_ended")
	AddScriptCallback("schedule_update_master_spotter")
end

function on_game_start()
	RegisterScriptCallback("actor_on_first_update",actor_on_first_update)
	RegisterScriptCallback("actor_on_update",actor_on_update)
	RegisterScriptCallback('on_option_change', on_option_change)

	if not zzzz_dynahud then
		UnregisterScriptCallback("on_key_release",axr_companions.on_key_release)
	end	
	RegisterScriptCallback("on_key_release", on_key_release)
	RegisterScriptCallback("on_key_press", on_key_press)

    RegisterScriptCallback("spotter_combat_started",combat_started)
    RegisterScriptCallback("spotter_combat_ended",combat_ended)

	on_option_change()
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("save_state", save_state)

	RegisterScriptCallback("stalkermon_squad_update",schedule_update_master_spotter)
end