local npcdu = npcd_utils

function get_printer()
	if not Printer then
		Printer = npcd_logging.get_printer("npcd")
	end 
	LOG = Printer:GetLogTypes()
	CAT = Printer:GetLogCategories()
end
if AddScriptCallback then
	RegisterScriptCallback("npcd_on_log_update", get_printer)
end

-- PERKS DECK 

local perks = {}
local categories = {}
local feats_index = {}


MAX_SECONDARY_PERKS = 2
MAX_MAIN_PERKS = 2

PERK_TYPE = {
	ARCHETYPE = "st_npcd_perk_type_archetype",
	MAIN = "st_npcd_perk_type_main",
	SECONDARY = "st_npcd_perk_type_secondary"
}

FEAT_TYPE = {
	ACTIVE = "st_npcd_feat_type_active",
	PASSIVE = "st_npcd_feat_type_passive",
	BOON = "st_npcd_feat_type_boon",
	TRAIT = "st_npcd_feat_type_trait",
	MUTATION = "st_npcd_feat_type_mutation",
}

FEAT_MODE = {
	AUTO = "st_npcd_feat_mode_auto",
	MANUAL = "st_npcd_feat_mode_manual",
	MODAL = "st_npcd_feat_mode_modal",
	STANCE = "st_npcd_feat_mode_stance",
	CUSTOM = "st_npcd_feat_mode_custom"
}

KEYBIND = {
	MODIFIER = {
		PRESS = 0,
		DOUBLE_TAP = 1,
		HOLD = 2,
	},
	SECOND_KEY = {
		NONE = 0,
		SHIFT = 1,
		CTRL = 2,
		ALT = 3,
	}
}

SECOND_KEY_DESC = {}
-- SECOND_KEY_DESC[1] = "ui_mcm_lst_npcd_kb_mod_none"
SECOND_KEY_DESC[1] = "ui_mcm_lst_npcd_kb_mod_shift"
SECOND_KEY_DESC[2] = "ui_mcm_lst_npcd_kb_mod_ctrl"
SECOND_KEY_DESC[3] = "ui_mcm_lst_npcd_kb_mod_alt"


FEAT_SETTING = {
	TYPE = {
			ACTIVATION_KEY = "activation_key",
			STATS = "stats",
			GENERAL = "general"
	},
	KEYBIND = {
		KEY = "keybind",
		MODIFIER = "modifier",
		SECOND_KEY = "second_key"
	},
	INDEX = "index",
	STAT = {
		COOLDOWN = "cooldown",
		DURATION = "duration",
	},
}

INPUT_MANAGER = {
	NPCD = "npcd",
	CUSTOM = "custom"
}

-- Perks API

function get_perk(perk_id)
	if not perk_id then return end -- cannot continue
	return perks[perk_id]
end

function get_perk_feats(perk_id)
	if not perk_id then return end -- cannot continue
	return perks[perk_id].feats
end

function get_perk_feat(perk_id, feat_id)
	if not perk_id or not perks[perk_id].feats then return end -- cannot continue
	return perks[perk_id].feats[feat_id]
end

function get_module_perks(module)
	local module_perks = {}
	for _, perk in pairs(perks) do
		if perks[perk.id]["module"] == module then
			table.insert(module_perks, perk)
		end
	end
	return module_perks
end

function add_category(perk_category, desc)
	if not perk_category then return end
	if not categories[perk_category] then
		categories[perk_category] = desc
		Printer:Log(LOG.ADD, CAT.CONF,"category %s added", perk_category)
	else
		Printer:Log(LOG.WARN, CAT.CONF,"category %s already exists", perk_category)
	end
end

-- NPCD Modules API

local function apply_module_perks_settings(module, module_perks)
	for _, perk in pairs(module_perks) do
		if perk.feats then
			for _, feat in pairs(perk.feats) do
				if feat.stats then
					-- updating feat stats from mcm settings
					for i = 1, #feat.stats do
						for key, _ in pairs(feat.stats[i]) do
							local value = npcd_mcm.get_module_perk_feat_setting(module, perk.id, feat.id, FEAT_SETTING.TYPE.STATS, key, i)
							feat.stats[i][key] = value
							-- Printer:Log(LOG.INFO, CAT.CONF, "updated perk %s feat %s stat %s[%s] to %s", perk.id, feat.id, key, i, value)
						end
					end
				end
				if feat.activation_key then
					-- updating feat activation input from mcm settings
					feat.activation_key = {
						keybind = npcd_mcm.get_module_perk_feat_setting(module, perk.id, feat.id, FEAT_SETTING.TYPE.ACTIVATION_KEY, FEAT_SETTING.KEYBIND.KEY) or feat.activation_key.keybind,
						modifier = npcd_mcm.get_module_perk_feat_setting(module, perk.id, feat.id, FEAT_SETTING.TYPE.ACTIVATION_KEY, FEAT_SETTING.KEYBIND.MODIFIER) or feat.activation_key.modifier,
						second_key = npcd_mcm.get_module_perk_feat_setting(module, perk.id, feat.id, FEAT_SETTING.TYPE.ACTIVATION_KEY, FEAT_SETTING.KEYBIND.SECOND_KEY) or feat.activation_key.second_key,
					}
				end
			end
		end
	end
end

function add_module_perks(module, module_perks)
	if not Printer then
		get_printer()
	end
	Printer:Log(LOG.RUN, CAT.CONF, "add module %s perks", module)
	for _, perk in pairs(module_perks) do
		if not perks[perk.id] then
			perks[perk.id] = npcdu.copy(perk)
			perks[perk.id]["module"] = module
			perks[perk.id]["uid"] = module .. "_" .. perk.id
			for _, feat in pairs(perks[perk.id].feats) do
				feat["perk_id"] = perk.id
				feat["uid"] = module .. "_" .. perk.id .. "_" .. feat.id
			end
		else
			Printer:Log(LOG.ERROR, CAT.CONF, "cannot add module %s perk %s, it already exists from other module %s", module, perk.id, perks[perk.id]["module"])
		end
	end
	-- Printer:LogTable("Added Deck Perks", module_perks)
	update_module_perks(module)
end

function update_module_perks(module)
	Printer:Log(LOG.RUN, CAT.CONF, "update module %s perks", module)
	local module_perks = get_module_perks(module)
	apply_module_perks_settings(module, module_perks)
	-- Printer:LogTable("Updated Deck Perks", module_perks)
end

function build_perk_index()
	for _, perk in pairs(perks) do
		if perk.feats then
			for _, feat in pairs(perk.feats) do
				feats_index[feat.uid] = {
					module = perk.module,
					perk_id = perk.id,
					feat_id = feat.id
				}
			end
		end
	end
end

function get_feat_index(feat_uid)
	return feats_index[feat_uid]
end

-- NPCs DECK

local npcs = {}

ABILITY_STATE = {
	READY = "READY",
	COOLDOWN = "COOLDOWN",
	DISABLED = "DISABLED",
	ENABLED = "ENABLED"
}

-- returns true of a new npc is added
function add_npc(npc_id)
	if npcs[npc_id] then return false end
	Printer:Log(LOG.ADD, CAT.CONF,"npc %s added", npc_id)
	npcs[npc_id] = {}
	npcs[npc_id]["id"] = npc_id
	npcs[npc_id]["recruited"] = false
	npcs[npc_id]["has_profile"] = false
	npcs[npc_id]["alive"] = true
	npcs[npc_id]["show_profile"] = false
	npcs[npc_id]["Perk"] = {}
	npcs[npc_id]["Ability"] = {}
	npcs[npc_id]["Info"] = {}
	npcs[npc_id]["Info"]["can_recruit"] = nil
	npcs[npc_id]["Info"]["last_joined"] = nil
	npcs[npc_id]["Info"]["last_time_seen"] = nil
	npcs[npc_id]["Info"]["last_place_seen"] = nil
	npcs[npc_id]["Info"]["last_place_tracked"] = nil
	npcs[npc_id]["Info"]["codec_frequency"] = nil
	return true
end

function remap_npc(npc_id, new_id)
	if not npc_id or not npcs[npc_id] then return false end
	Printer:Log(LOG.ADD, CAT.CONF,"npc %s remapped to %s", npc_id, new_id)
	npcs[new_id] = npcs[npc_id]
	npcs[new_id].id = new_id
	-- delete old npcs
	npcs[npc_id] = nil
	return true
end

function set_show_profile(npc_id, show)
	if not npcs[npc_id] then return end
	npcs[npc_id].show_profile = show
end

function set_recruited(npc_id, enlist)
	if not npcs[npc_id] then return end
	npcs[npc_id].recruited = enlist
	if enlist then
		npcs[npc_id].Info.last_joined = game.get_game_time()
	end
end

function is_recruited(npc_id)
	if not npcs[npc_id] then return false end
	return npcs[npc_id].recruited
end

function set_deck(deck)
    npcs = deck
end

function get_deck()
    return npcs
end

function get_npcs_id_list()
	local npcs_list = {}
	for id, _ in pairs(npcs) do
		table.insert(npcs_list, id)
	end
	return npcs_list
end

function remove_npc(npc_id)
	if not npc_id then return end
	npcs[npc_id]["alive"] = false
end

function purge_npc(npc_id)
	if not npc_id then return end
	-- clear npc data
	clear_npc_data(npc_id)
	-- clear npc stats
	clear_npc_stats(npc_id)
	npcs[npc_id] = nil
end

function get_npc(npc_id)
    if not npc_id then return end
    return npcs[npc_id]
end

function get_npc_info(npc_id)
    if not npc_id then return end
    return npcs[npc_id].Info
end

function set_npc_info(npc_id, info)
    if not npc_id or not info then return end
    npcs[npc_id].Info = info
end

function set_last_joined(npc_id, time)
	if not npcs[npc_id] then return end
	npcs[npc_id].Info.last_joined = time
end

function set_last_place_seen(npc_id, place)
	if not npcs[npc_id] then return end
	npcs[npc_id].Info.last_place_seen = place
end

function  set_last_place_tracked(npc_id, place)
	if not npcs[npc_id] then return end
	npcs[npc_id].Info.last_place_tracked = place
end

function get_npc_perk(npc_id, perk_id)
	if not npc_id or not npcs[npc_id] or not perk_id then return end
	return npcs[npc_id].Perk[perk_id]
end

function get_npc_perks(npc_id)
	if not npc_id or not npcs[npc_id] then return end
	return npcs[npc_id].Perk
end

function get_perk_rank(npc_id, perk_id)
	if not npc_id or not perk_id then return end
	if not npcs[npc_id] or not npcs[npc_id].Perk[perk_id] then return end
	local rank = npcdu.get_perk_rank(npc_id)
	return rank
end

function get_squad_npc_with_perk(perk_id)
	if not perk_id then return end -- cannot continue
	local clist = npcd_squad.squad_get_clist()
	if not clist or not (npcdu.tablelength(clist) > 0) then return end
	local npc_id = nil
	for _, id in pairs(clist) do
		-- return the npc_id that has the highest perk rank using perk_id
		
		if npcs[id] and npcs[id].Perk[perk_id] then
			if not npc_id then
				npc_id = id
			else
				-- compare ranks
				local rank1 = npcdu.get_perk_rank(npc_id)
				local rank2 = npcdu.get_perk_rank(id)
				if rank2 > rank1 then
					npc_id = id
				end
			end
		end
	end
	return npc_id
end

function get_archetype_perk(npc_id)
	if not npc_id or not npcs[npc_id] then return end
	for i = 1, #npcs[npc_id].Perk, 1 do
		if npcs[npc_id].Perk[i].type == PERK_TYPE.ARCHETYPE then
			local perk_id = npcs[npc_id].Perk[i].id
			return perks[perk_id]
		end
	end
end

function has_perks(npc_id)
	if not npc_id or not npcs[npc_id] then return end
	return npcdu.tablelength(npcs[npc_id].Perk) > 0
end

function has_perk(npc_id, perk_id)
	if not perk_id or not npc_id or not npcs[npc_id] then return end
	local perk = npcs[npc_id].Perk[perk_id]
	return perk and true or false
end


local function roll_perk(npc_id, functor)
	Printer:Log(LOG.RUN, CAT.CONF,"executing npc %s roll", npc_id)
	if not functor then return false end
	local ex_functor = npcdu.copy(functor)
	table.insert(ex_functor, npc_id)
	Printer:TraceTable("execute_roll_perk", ex_functor)
	local result = execute_func(unpack(ex_functor))
	Printer:Trace(LOG.INFO, CAT.EXEC,"with result: %s", result)
	return result
end

-- returns true of the perk is rolled
function roll_npc_perk(npc_id, perk_id)
	Printer:Log(LOG.RUN, CAT.CONF,"rolling npc %s perk", npc_id)
	if not npc_id or not perk_id or not perks[perk_id] then return end
	Printer:Log(LOG.INFO, CAT.CONF,"perk %s is available", perk_id)
	local perk = perks[perk_id]
	if npcs[npc_id].Perk[perk.id] then return end -- already has this perk
	if roll_perk(npc_id, perk.roll_functor) then
		npcs[npc_id].Perk[perk.id] = {}
		npcs[npc_id].Perk[perk.id]["id"]  = perk.id
		return true
	end
	return false
end

function get_perks_id_list()
	local plist = {}
	for id, perk in pairs(perks) do
		table.insert(plist, perk.id)
	end
	return plist
end

local function get_randomized_perk_list(perk_type, perk_archetype)
	local list = {}
	for _, perk in pairs(perks) do
		if perk.type == perk_type then
			if perk_archetype then
				--- not implemented
				if perk.archetype == perk_archetype then
					table.insert(list, perk)
				end
			else
				table.insert(list, perk)
			end
		end
	end
	npcdu.shuffle(list)
	return list
end

local function add_archetype_perk(npc_id)
	-- atm only one archetype can be added
	local archetype_perk_list = get_randomized_perk_list(PERK_TYPE.ARCHETYPE)
	local i = 1
	local attempts = 0
	local max_attempts = 10
	-- loop until succesfully rolls the archetype
	while not roll_npc_perk(npc_id, archetype_perk_list[i].id) and attempts < max_attempts do
		i = i + 1
		attempts = attempts + 1
		if i > #archetype_perk_list then
			-- return
			i = 1 
			npcdu.shuffle(archetype_perk_list)
		end
	end
end

local function add_random_perk(npc_id, perk_type, amount)
	-- atm only one archetype can be added
	local perk_list = get_randomized_perk_list(perk_type)
	local i = 1
	local attempts = 0
	local max_attempts = 10
	local perk_count = 0
	-- loop until succesfully rolls the amount of perks
	while perk_count < amount and attempts < max_attempts do
		if roll_npc_perk(npc_id, perk_list[i].id) then
			-- remove perk from list to avoid duplicates
			table.remove(perk_list, i)
			perk_count = perk_count + 1
			attempts = 0
		end
		i = i + 1
		attempts = attempts + 1
		if i > #perk_list then 
			npcdu.shuffle(perk_list)
			i = 1
		end
	end
end

function create_profile(npc_id)
	Printer:Log(LOG.RUN, CAT.CONF,"npc %s create profile", npc_id)
	-- ARCHETYPE

	add_archetype_perk(npc_id)
	
	add_random_perk(npc_id, PERK_TYPE.MAIN, 1)

	-- -- atm only one perk can be added, of type archetype
	-- local archetype_perk_list = get_randomized_perk_list(PERK_TYPE.ARCHETYPE)
	-- local i = 1
	-- -- loop until succesfully rolls the archetype
	-- while not roll_npc_perk(npc_id, archetype_perk_list[i].id) do
	-- 	i = i + 1
	-- 	if i > #archetype_perk_list then
	-- 		break
	-- 		-- i = 1 
	-- 		-- shuffle(archetype_perk_list)	
	-- 	end
	-- end

	-- -- MAIN PERKS ??

	-- local main_perk_list = get_randomized_perk_list(PERK_TYPE.MAIN)
	-- local i = 1
	-- local perk_count = 0
	-- -- loop until max perks count have been succesfully rolled
	-- while perk_count < MAX_MAIN_PERKS do
	-- 	if roll_npc_perk(npc_id, main_perk_list[i].id) then
	-- 		perk_count = perk_count + 1
	-- 	end
	-- 	i = i + 1
	-- 	if i > #main_perk_list then 
	-- 		shuffle(main_perk_list)
	-- 		i = 1
	-- 	end
	-- end	

	-- -- SECONDARY PERKS
	-- -- no perks available atm
	-- local secondary_perk_list = get_randomized_perk_list(PERK_TYPE.SECONDARY)
	-- local i = 1
	-- local perk_count = 0
	-- -- loop until max perks count have been succesfully rolled
	-- while perk_count < MAX_SECONDARY_PERKS do
	-- 	if roll_npc_perk(npc_id, secondary_perk_list[i].id) then
	-- 		perk_count = perk_count + 1
	-- 	end
	-- 	i = i + 1
	-- 	if i > #secondary_perk_list then 
	-- 		shuffle(secondary_perk_list)
	-- 		i = 1
	-- 	end
	-- end

	npcs[npc_id].has_profile = true
	Printer:LogTable(string.format("Create Profile NPC %s", npc_id), npcs[npc_id])
end

-- called on perks registration
-- essentially a spot to setup the npc profile's state
function setup_profile(npc_id)
	if not npcs[npc_id] and not npcs[npc_id].has_profile then return end
	for _, npc_perk in pairs(npcs[npc_id].Perk) do
		local perk = get_perk(npc_perk.id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				if feat.type == FEAT_TYPE.ACTIVE then
					-- we want to add feat abilities for when they are registered
					-- they also linger for a moment, to hold the state, for when they are are unregistered
					if not add_ability(npc_id, feat) then
						update_ability(npc_id, feat)
					end
				end
				if feat.type == FEAT_TYPE.PASSIVE then
					-- there not seems to be a reason to instantiate abilities for passive feats
				end
			end
		end
	end
end

function get_npc_feat_stats(npc_id, perk_id, feat_id)
	if not npc_id or not npcs[npc_id] or not perk_id or not feat_id then return end
	if not npcs[npc_id].Perk[perk_id] then return end -- npc does not have this perk
	local perk = get_perk(perk_id)
	if not perk or not perk.feats or not perk.feats[feat_id] then return end
	local rank = npcdu.get_perk_rank(npc_id)
	local stats = npcdu.copy(perk.feats[feat_id].stats[rank])
	stats["rank"] = rank
	return stats
end

function get_npc_feats(npc_id, feat_id)
	-- feat_id is optional, if provided returns only that feat
	local npc_feats_list = {}
	for _, npc_perk in pairs(npcs[npc_id].Perk) do
		for _, perk in pairs(perks) do
			if perk.id == npc_perk.id then
				for _, feat in pairs(perk.feats) do
					local npc_feat = npcdu.copy(feat)
					npc_feat["npc_id"] = npc_id
					npc_feat["perk_module"] = perk.module
					npc_feat["perk_id"] = perk.id
					npc_feat["perk_name"] = perk.name
					local rank = npcdu.get_perk_rank(npc_id)
					npc_feat["stats"] = feat.stats[rank]
					-- npc_feat["Ability"] = npcdu.copy(npcs[npc_id].Ability[feat.id])
					if feat_id and feat.id == feat_id then
						return npc_feat
					else
						table.insert(npc_feats_list, npc_feat)
					end
				end
			end
		end
	end
	return npc_feats_list
end

function get_npc_feat_data(npc_id, feat_id)
	if not npc_id or not npcs[npc_id] or not feat_id then return end
	for _, npc_perk in pairs(npcs[npc_id].Perk) do
		local perk = get_perk(npc_perk.id)
		if perk and perk.feats and perk.feats[feat_id] then
			local feat_data = {}
			feat_data["id"] = feat_id
			feat_data["npc_id"] = npc_id
			feat_data["name"] = perk.feats[feat_id].name
			feat_data["icon"] = perk.feats[feat_id].icon
			feat_data["perk_module"] = perk.module
			feat_data["perk_id"] = perk.id
			feat_data["perk_name"] = perk.name
			local rank = npcdu.get_perk_rank(npc_id)
			feat_data["stats"] = perk.feats[feat_id].stats[rank]
			feat_data["activation_functor"] = perk.feats[feat_id].activation_functor
			feat_data["activation_key"] = perk.feats[feat_id].activation_key
			feat_data["Ability"] = npcdu.copy(npcs[npc_id].Ability[feat_id])
			return feat_data
		end
	end
end

function add_ability(npc_id, feat)
	local a_id = feat.id
	if not npcs[npc_id] then return false end
	if npcs[npc_id].Ability[a_id] then return false end -- already has this ability
	Printer:Log(LOG.ADD, CAT.CONF,"npc %s adds ability %s", npc_id, a_id)
    npcs[npc_id].Ability[a_id] = {}
	npcs[npc_id].Ability[a_id]["id"] = a_id
	npcs[npc_id].Ability[a_id]["mode"] = feat.mode
	npcs[npc_id].Ability[a_id]["icon"] = feat.icon_hud or "ui_npcd_hud_default_icon"
	npcs[npc_id].Ability[a_id]["icon_slot"] = feat.icon_slot or "ui_npcd_hud_default_icon"
	npcs[npc_id].Ability[a_id]["state"] = ABILITY_STATE.READY
	npcs[npc_id].Ability[a_id]["registered"] = false
	-- TODO ability should be rank independent 
	local rank = npcdu.get_perk_rank(npc_id, feat.id) -- TODO EXP framework can give this otherwise
	npcs[npc_id].Ability[a_id]["cooldown"] = feat.stats[rank].cooldown or 1 -- TODO move this out from ability
	npcs[npc_id].Ability[a_id]["timer"] = -9999

	return true
end

function update_ability(npc_id, feat)
	local a_id = feat.id
	if not npcs[npc_id] then return false end
	if not npcs[npc_id].Ability[a_id] then return false end -- does not have
	Printer:Log(LOG.ADD, CAT.CONF,"npc %s updates ability %s", npc_id, a_id)
	local rank = npcdu.get_perk_rank(npc_id, feat.id) -- EXP framework can give this otherwise
	npcs[npc_id].Ability[a_id]["cooldown"] = feat.stats[rank].cooldown or 1
	return true
end

function find_npcs_with_ability(feat_id)
	local npcs_with_ability = {}
	for npc_id, npc in pairs(npcs) do
		for _, ability in pairs(npc.Ability) do
			if ability.id == feat_id then
				table.insert(npcs_with_ability, npc_id)
			end
		end
	end
	return npcs_with_ability
end

function remove_ability(npc_id, feat_id)
	if not npcs[npc_id] then return false end
	if not npcs[npc_id].Ability[feat_id] then return false end
	Printer:Log(LOG.REMOVE, CAT.CONF,"npc %s removes ability %s", npc_id, feat_id)
	npcs[npc_id].Ability[feat_id] = nil
	return true
end

function has_abilities(npc_id)
	if not npcs[npc_id] then return false end

	return npcdu.tablelength(npcs[npc_id].Ability) > 0
end

function get_abilities(npc_id)
	if not npcs[npc_id] then return end
	
	return npcs[npc_id].Ability
end

function clear_abilities(npc_id)
	npcs[npc_id].Ability = {}
end

function get_ability(npc_id, feat_id)
	if not npcs[npc_id] then return end
	
	return npcs[npc_id].Ability[feat_id]
end

function ability_registered(npc_id, feat_id)
	if not npcs[npc_id] or not npcs[npc_id].Ability[feat_id] then return end
	
	return npcs[npc_id].Ability[feat_id].registered
end

function set_ability(npc_id, ability)
    npcs[npc_id].Ability[ability.id] = ability
end

function set_ability_settings(npc_id, feat_id, settings)
	if not npcs[npc_id] then return false end
	if not npcs[npc_id].Ability[feat_id] then return false end -- does not have
	for key, value in pairs(settings) do
		npcs[npc_id].Ability[feat_id][key] = value
	end
	return true
end

function reset_ability(npc_id, feat_id)
	if not npcs[npc_id] then return false end
	if not npcs[npc_id].Ability[feat_id] then return false end -- does not have
	npcs[npc_id].Ability[feat_id].state = ABILITY_STATE.READY
	npcs[npc_id].Ability[feat_id].timer = -9999
	return true
end

function start_ability_cooldown(npc_id, feat_id)
	if not npcs[npc_id] then return false end
	if not npcs[npc_id].Ability[feat_id] then return false end -- does not have
	npcs[npc_id].Ability[feat_id].state = ABILITY_STATE.COOLDOWN
	npcs[npc_id].Ability[feat_id].timer = npcs[npc_id].Ability[feat_id].cooldown
	return true
end

function update_ability_cooldown(npc_id, feat_id, delta_time)
	if not npcs[npc_id] or not npcs[npc_id].Ability[feat_id] then return false end -- does not have
	local state = npcs[npc_id].Ability[feat_id].state
	if state ~= ABILITY_STATE.COOLDOWN then return false end -- not in cooldown
	if npcs[npc_id].Ability[feat_id].timer <= 0 then
		npcs[npc_id].Ability[feat_id].state = ABILITY_STATE.READY
		npcs[npc_id].Ability[feat_id].timer = -9999
	end	
	npcs[npc_id].Ability[feat_id].timer = npcs[npc_id].Ability[feat_id].timer - (delta_time or 1)
end

function is_ability_on_cooldown(npc_id, feat_id)
	if not npcs[npc_id] or not npcs[npc_id].Ability[feat_id] then return false end -- does not have
	local state = npcs[npc_id].Ability[feat_id].state
	return state == ABILITY_STATE.COOLDOWN
end

function is_ability_enabled(npc_id, feat_id)
	if not npcs[npc_id] or not npcs[npc_id].Ability[feat_id] then return false end -- does not have
	local state = npcs[npc_id].Ability[feat_id].state
	return state == ABILITY_STATE.ENABLED
end

function disable_ability(npc_id, feat_id)
	if not npcs[npc_id] or not npcs[npc_id].Ability[feat_id] then return false end -- does not have
	local state = npcs[npc_id].Ability[feat_id].state
	if state ~= ABILITY_STATE.ENABLED then return false end -- not enabled
	reset_ability(npc_id, feat_id)
	return true
end

function enable_ability(npc_id, feat_id)
	if not npcs[npc_id] or not npcs[npc_id].Ability[feat_id] then return false end -- does not have
	local state = npcs[npc_id].Ability[feat_id].state
	if state ~= ABILITY_STATE.READY then return false end -- not ready
	npcs[npc_id].Ability[feat_id].state = ABILITY_STATE.ENABLED
	return true
end

-- NPCS STATS

NPCD_STATS = {
	PERK = "Perk",
	NPCS = "Npcs",
	ACTOR = "Actor"
}

local stats = {}
stats["Perk"] = {}
stats["Npcs"] = {}
stats["Actor"] = {}

function get_stats()
	return stats
end

function set_stats(s)
	stats = s
end

function set_stat(stat_type, key, stat)
	stats[stat_type][key] = stat
end

function get_stat(stat_type, key)
	return stats[stat_type][key]
end

function clear_npc_stats(npc_id)
	if npc_id and stats.Npcs[npc_id] then
		stats.Npcs[npc_id] = nil
	end
end

function set_discovered(perk_id)
	if stats.Perk[perk_id] and stats.Perk[perk_id].discovered then return false end
	if not stats.Perk[perk_id] then
		stats.Perk[perk_id] = {}
	end
	stats.Perk[perk_id]["discovered"] = true
	return true
end

function set_favorite(npc_id, favorite)
	if not npcs[npc_id] then return end
	if not stats.Npcs[npc_id] then
		stats.Npcs[npc_id] = {}
	end

	stats.Npcs[npc_id]["favorite"] = favorite
end

function get_favorite(npc_id)
	return stats.Npcs[npc_id] and stats.Npcs[npc_id]["favorite"] or false
end

-- NPCS DATA for MCM

local data = {}
function get_npc_data(id)
	-- Printer:Log(LOG.RUN, CAT.CONF,"getting npc %s data", id)
	if not id then return nil end
    local npc = npcdu.get_npc_obj(id) -- or alife_object(id)
    if npc and IsStalker(npc) then
        local npc_data = {}
        npc_data.id = npc:id()
        npc_data.name = npc:character_name()
        npc_data.community = character_community(npc)
        npc_data.rank_name = ranks.get_obj_rank_name(npc)
        npc_data.rank = npcdu.get_npc_rank(npc)
        npc_data.reputation = npcdu.get_npc_reputation(npc)
        local squad = get_object_squad(npc)
        npc_data.squad_id = squad and squad.id or nil
        npc_data.squad_commander = squad and squad:commander_id() == npc:id() or false
        npc_data.standings = {
            attitude = npc:general_goodwill(db.actor),
            relation = npc:relation(db.actor),
            goodwill_personal = npc:goodwill(db.actor),
            goodwill_actor_faction = relation_registry.community_goodwill(character_community(npc), db.actor:id()),
            goodwill_rank = game_relations.get_rank_relation(npc, db.actor),
            goodwill_reputation = game_relations.get_reputation_relation(npc, db.actor),
            goodwill_communities = relation_registry.community_relation(character_community(npc), character_community(db.actor)),
            sympathy = npc:sympathy(),
        }
		-- Printer:DebugTable("NPCS Data cache update", npc_data)
        data[id] = npc_data
        return data[id]
    elseif data[id] then
		-- Printer:DebugTable("NPCS Data cache returns", data[id])
        return data[id]
    end
    return nil
end

function get_data()
    return data
end

function set_data(new_data)
    data = new_data
end

function clear_npc_data(id)
	if id and data[id] then
		data[id] = nil
	end
end

function actor_on_first_update()
    printf("$[NPCD][Main] npcd actor_on_first_update")
end

function on_game_start()
    printf("$[NPCD][Main] npcd on_game_start")
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	get_printer()
end