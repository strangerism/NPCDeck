local npcdu = npcd_utils

function get_printer()
	if not Printer then
		Printer = npcd_logging.get_printer("npcd")
	end 
	LOG = Printer:GetLogTypes()
	CAT = Printer:GetLogCategories()
end
if AddScriptCallback then
	RegisterScriptCallback("npcd_on_log_update", get_printer)
end

-- PERKS DECK 

local perks = {}

MAX_SECONDARY_PERKS = 3
MAX_MAIN_PERKS = 1

PERK_TYPE = {
	ARCHETYPE = "st_npcd_perk_type_archetype",
	MAIN = "st_npcd_perk_type_main",
	SECONDARY = "st_npcd_perk_type_secondary"
}

FEAT_TYPE = {
	ACTIVE = "st_npcd_feat_type_active",
	PASSIVE = "st_npcd_feat_type_passive"
}

FEAT_MODE = {
	AUTO = "st_npcd_feat_mode_auto",
	MANUAL = "st_npcd_feat_mode_manual",
	MODAL = "st_npcd_feat_mode_modal"
}

KEYBIND = {
	MODIFIER = {
		PRESS = 0,
		DOUBLE_TAP = 1,
		HOLD = 2,
	},
	SECOND_KEY = {
		NONE = 0,
		SHIFT = 1,
		CTRL = 2,
		ALT = 3,
	}
}

SECOND_KEY_DESC = {}
-- SECOND_KEY_DESC[1] = "ui_mcm_lst_npcd_kb_mod_none"
SECOND_KEY_DESC[1] = "ui_mcm_lst_npcd_kb_mod_shift"
SECOND_KEY_DESC[2] = "ui_mcm_lst_npcd_kb_mod_ctrl"
SECOND_KEY_DESC[3] = "ui_mcm_lst_npcd_kb_mod_alt"


FEAT_SETTING = {
	ACTIVATION_KEY = "activation_key",
	KEYBIND = {
		KEY = "keybind",
		MODIFIER = "modifier",
		SECOND_KEY = "second_key"
	},
	INDEX = "index",
	STATS = "stats",
	STAT = {
		COOLDOWN = "cooldown",
		LIFE = "life",
	}
}

INPUT_MANAGER = {
	NPCD = "npcd",
	CUSTOM = "custom"
}

function add_module_perks(module, module_perks)
	for _, perk in pairs(module_perks) do
		if not perks[perk.id] then
			perks[perk.id] = perk
			perks[perk.id]["module"] = module
		end
	end 
	Printer:LogTable("Deck Perks", perks)
end

-- NPCs DECK

local npcs = {}

ABILITY_STATE = {
	READY = "READY",
	COOLDOWN = "COOLDOWN",
	READING = "READING",
	DISABLED = "DISABLED",
}

-- returns true of a new npc is added
function add_npc(npc_id)
	if npcs[npc_id] then return false end
	Printer:Log(LOG.ADD, CAT.CONF,"npc %s added", npc_id)
	npcs[npc_id] = {}
	npcs[npc_id]["id"] = npc_id
	npcs[npc_id]["Perk"] = {}
	npcs[npc_id]["Ability"] = {}
	return true
end

function set_deck(deck)
    npcs = deck
end

function get_deck()
    return npcs
end

function remove_npc(npc_id)
	if not npc_id then return end
	npcs[npc_id] = nil
end

function get_npc(npc_id)
    if not npc_id then return end
    return npcs[npc_id]
end

function get_perk(perk_id, npc_id)
	if not perk_id then return end -- cannot continue
	if npc_id and (not npcs[npc_id] or not npcs[npc_id].Perk[perk_id]) then return end -- npc perk query but npc does not have this perk

	return perks[perk_id]
end

function get_perk_feats(perk_id)
	if not perk_id then return end -- cannot continue
	return perks[perk_id].feats
end

function get_perk_feat(perk_id, feat_id)
	if not perk_id or not perks[perk_id].feats then return end -- cannot continue
	return perks[perk_id].feats[feat_id]
end

function get_perk_feat_stat(perk_id, feat_id, stat_name, rank)
	if not rank or not stat_name then return end
	local feat = get_perk_feat(perk_id, feat_id)
	if not feat or not feat.stats and not feat.stats[rank]  then return end
	return feat.stats[rank][stat_name]
end

-- function get_perks_activations_inputs()
-- 	local activations_inputs = {}
-- 	for _, perk in pairs(perks) do
-- 		if perk and not perk.disabled and perk.feats then
-- 			for key, feat in pairs(perk.feats) do
-- 				if feat.type == FEAT_TYPE.ACTIVE and feat.mode == FEAT_MODE.MANUAL then
-- 					local feat_activation_input = {
-- 						activation_key = feat.activation_key,
-- 						activation_functor = feat.activation_functor
-- 					}
-- 					local id = npcd_mcm.get_module_perk_feat_setting_id(perk.module, perk.id, feat.id, FEAT_SETTING.ACTIVATION_KEY, FEAT_SETTING.KEYBIND.KEY)
-- 					activations_inputs[id] = feat_activation_input
-- 				end
-- 			end
-- 		end
-- 	end
-- 	return activations_inputs
-- end

function get_npc_perks(npc_id)
	if not npc_id or not npcs[npc_id] then return end
	return npcs[npc_id].Perk
end

function get_archetype_perk(npc_id)
	if not npc_id or not npcs[npc_id] then return end
	for i = 1, #npcs[npc_id].Perk, 1 do
		if npcs[npc_id].Perk[i].type == PERK_TYPE.ARCHETYPE then
			local perk_id = npcs[npc_id].Perk[i].id
			return perks[perk_id]
		end
	end
end

function has_perk(npc_id, perk_id)
	if not perk_id or not npc_id or not npcs[npc_id] then return end
	local perk = npcs[npc_id].Perk[perk_id]
	return (perk and (perk.rank >= 0)) or false
end


local function roll_perk(npc_id, functor)
	Printer:Log(LOG.INFO, CAT.CONF,"executing npc %s roll", npc_id)
	if not functor then return false end
	table.insert(functor, npc_id)
	return execute_func(unpack(functor))
end

-- returns true of the perk is rolled
function roll_npc_perk(npc_id, perk_id)
	Printer:Log(LOG.INFO, CAT.CONF,"npc %s Roll_perk", npc_id)
	if not npc_id or not perk_id or not perks[perk_id] then return end
	Printer:Log(LOG.INFO, CAT.CONF,"perk %s is available", perk_id)
	local perk = perks[perk_id]
	if npcs[npc_id].Perk[perk.id] then return end
	Printer:Log(LOG.INFO, CAT.CONF,"npc %s never rolled this perk", npc_id)
	if roll_perk(npc_id, perk.roll_functor) then
		npcs[npc_id].Perk[perk.id] = {}
		npcs[npc_id].Perk[perk.id]["id"]  = perk.id
		npcs[npc_id].Perk[perk.id].rank  = 0  -- 0 stands for acquired TODO revise this
		local npc = npcdu.get_npc_obj(npc_id)
		npcdu.print_tip(perk.roll_success_desc, 10000, npc:character_name(), npcdu.get_feat_rank_desc(npc_id, perk_id))
		Printer:LogTable(string.format("Roll_perk NPC %s", npc_id), npcs[npc_id])
		return true
	end
end

function add_perks(npc_id, some_perks)
end

function set_perks(npc_id, new_perks)
end

local function get_randomized_perk_list(perk_type, perk_archetype)
	local list = {}
	for _, perk in pairs(perks) do
		if perk.type == perk_type then
			if perk_archetype then
				--- not implemented
				if perk.archetype == perk_archetype then
					table.insert(list, perk)	
				end
			else
				table.insert(list, perk)
			end
		end
	end
	npcdu.shuffle(list)
	return list
end

function create_profile(npc_id)

	-- ARCHETYPE
	-- atm only one perk can be added, of type archetype
	local archetype_perk_list = get_randomized_perk_list(PERK_TYPE.ARCHETYPE)
	local i = 1
	-- loop until succesfully rolls the archetype
	while not roll_npc_perk(npc_id, archetype_perk_list[i].id) do
		i = i + 1
		if i > #archetype_perk_list then
			return
			-- i = 1 
			-- shuffle(archetype_perk_list)	
		end
	end
	
	-- -- MAIN PERKS ??
	-- -- no perks available atm
	-- local main_perk_list = get_randomized_perk_list(PERK_TYPE.MAIN, Get_archetype_perk(npc_id))
	-- local i = 1
	-- local perk_count = 0
	-- -- loop until max perks count have been succesfully rolled
	-- while perk_count < MAX_MAIN_PERKS do
	-- 	if roll_npc_perk(npc_id, main_perk_list[i].id) then
	-- 		perk_count = perk_count + 1
	-- 	end
	-- 	i = i + 1
	-- 	if i > #main_perk_list then 
	-- 		shuffle(main_perk_list)
	-- 		i = 1
	-- 	end
	-- end	

	-- -- SECONDARY PERKS
	-- -- no perks available atm
	-- local secondary_perk_list = get_randomized_perk_list(PERK_TYPE.SECONDARY)
	-- local i = 1
	-- local perk_count = 0
	-- -- loop until max perks count have been succesfully rolled
	-- while perk_count < MAX_SECONDARY_PERKS do
	-- 	if roll_npc_perk(npc_id, secondary_perk_list[i].id) then
	-- 		perk_count = perk_count + 1
	-- 	end
	-- 	i = i + 1
	-- 	if i > #secondary_perk_list then 
	-- 		shuffle(secondary_perk_list)
	-- 		i = 1
	-- 	end
	-- end	
end

function get_npc_feat(npc_id, feat_id)
	for _, npc_perk in pairs(npcs[npc_id].Perk) do
		for _, perk in pairs(perks) do
			if perk.id == npc_perk.id then
				for _, feat in pairs(perk.feats) do
					if feat.id == feat_id then
						feat["perk_module"] = perk.module
						feat["perk_id"] = perk.id
						feat["perk_name"] = perk.name
						return feat
					end
				end
			end
		end
	end
end

function add_ability(npc_id, feat)
	local a_id = feat.id
	Printer:Log(LOG.ADD, CAT.CONF,"npc %s add_ability %s", npc_id, a_id)
    npcs[npc_id].Ability[a_id] = {}
	npcs[npc_id].Ability[a_id]["id"] = a_id
	npcs[npc_id].Ability[a_id]["mode"] = feat.mode
	npcs[npc_id].Ability[a_id]["icon"] = feat.icon_hud
	npcs[npc_id].Ability[a_id]["icon_slot"] = feat.icon_slot
	npcs[npc_id].Ability[a_id]["state"] = ABILITY_STATE.READY
	local rank = npcdu.get_feat_rank(npc_id, feat.id) -- EXP framework should give this
	npcs[npc_id].Ability[a_id]["cooldown"] = feat.cooldown or feat.stats[rank].cooldown or 360
	npcs[npc_id].Ability[a_id]["timer"] = -1
end

function remove_ability(npc_id, feat_id)
    local a_id = feat_id
	npcs[npc_id].Ability[a_id] = nil
end

function has_abilities(npc_id)
	if not npcs[npc_id] then return false end

	return npcdu.tablelength(npcs[npc_id].Ability) > 0
end

function get_abilities(npc_id)
	if not npcs[npc_id] then return end
	
	return npcs[npc_id].Ability
end

function get_ability(npc_id, feat_id)
	if not npcs[npc_id] then return end
	
	return npcs[npc_id].Ability[feat_id]
end

function set_ability(npc_id, ability)
    npcs[npc_id].Ability[ability.id] = ability
end

function actor_on_first_update()
	Printer:Log(LOG.RUN, CAT.CONF,"NPCS actor_on_first_update")
end
function on_game_start()
	-- Printer:Log(LOG.START, CAT.CONF,"NPCS on_game_start")
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
end