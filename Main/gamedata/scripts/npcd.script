local npcdu = npcd_utils

function get_printer()
	if not Printer then
		Printer = npcd_logging.get_printer("npcd")
	end 
	LOG = Printer:GetLogTypes()
	CAT = Printer:GetLogCategories()
end
if AddScriptCallback then
	RegisterScriptCallback("npcd_on_log_update", get_printer)
end

-- PERKS DECK 

local perks = {}

MAX_SECONDARY_PERKS = 3
MAX_MAIN_PERKS = 1

PERK_TYPE = {
	ARCHETYPE = "st_npcd_perk_type_archetype",
	MAIN = "st_npcd_perk_type_main",
	SECONDARY = "st_npcd_perk_type_secondary"
}

FEAT_TYPE = {
	ACTIVE = "st_npcd_feat_type_active",
	PASSIVE = "st_npcd_feat_type_passive",
	BOON = "st_npcd_feat_type_boon",
	TRAIT = "st_npcd_feat_type_trait",
	MUTATION = "st_npcd_feat_type_mutation",
}

FEAT_MODE = {
	AUTO = "st_npcd_feat_mode_auto",
	MANUAL = "st_npcd_feat_mode_manual",
	MODAL = "st_npcd_feat_mode_modal"
}

KEYBIND = {
	MODIFIER = {
		PRESS = 0,
		DOUBLE_TAP = 1,
		HOLD = 2,
	},
	SECOND_KEY = {
		NONE = 0,
		SHIFT = 1,
		CTRL = 2,
		ALT = 3,
	}
}

SECOND_KEY_DESC = {}
-- SECOND_KEY_DESC[1] = "ui_mcm_lst_npcd_kb_mod_none"
SECOND_KEY_DESC[1] = "ui_mcm_lst_npcd_kb_mod_shift"
SECOND_KEY_DESC[2] = "ui_mcm_lst_npcd_kb_mod_ctrl"
SECOND_KEY_DESC[3] = "ui_mcm_lst_npcd_kb_mod_alt"


FEAT_SETTING = {
	ACTIVATION_KEY = "activation_key",
	KEYBIND = {
		KEY = "keybind",
		MODIFIER = "modifier",
		SECOND_KEY = "second_key"
	},
	INDEX = "index",
	STATS = "stats",
	STAT = {
		COOLDOWN = "cooldown",
		LIFE = "life",
	}
}

INPUT_MANAGER = {
	NPCD = "npcd",
	CUSTOM = "custom"
}

-- Perks API

function get_perk(perk_id)
	if not perk_id then return end -- cannot continue
	return perks[perk_id]
end

function get_perk_feats(perk_id)
	if not perk_id then return end -- cannot continue
	return perks[perk_id].feats
end

function get_perk_feat(perk_id, feat_id)
	if not perk_id or not perks[perk_id].feats then return end -- cannot continue
	return perks[perk_id].feats[feat_id]
end

function get_perk_feat_stat(perk_id, feat_id, stat_name, rank)
	if not rank or not stat_name then return end
	local feat = get_perk_feat(perk_id, feat_id)
	if not feat or not feat.stats and not feat.stats[rank]  then return end
	return feat.stats[rank][stat_name]
end

function get_module_perks(module)
	local module_perks = {}
	for _, perk in pairs(perks) do
		if perks[perk.id]["module"] == module then
			table.insert(module_perks, perk)
		end
	end
	return module_perks
end

-- NPCD Modules API

local function apply_module_perks_settings(module, module_perks)
	for _, perk in pairs(module_perks) do
		if perk.feats then
			for _, feat in pairs(perk.feats) do
				if feat.stats then
					for i = 1, #feat.stats do
						for key, _ in pairs(feat.stats[i]) do
							local value = npcd_mcm.get_module_perk_feat_setting(module, perk.id, feat.id, FEAT_SETTING.STATS, key, i)
							feat.stats[i][key] = value
							-- Printer:Log(LOG.INFO, CAT.CONF, "updated perk %s feat %s stat %s[%s] to %s", perk.id, feat.id, key, i, value)
						end
					end
				end
			end
		end
	end
end

function add_module_perks(module, module_perks)
	if not Printer then
		get_printer()
	end
	Printer:Log(LOG.RUN, CAT.CONF, "add module %s perks", module)
	for _, perk in pairs(module_perks) do
		if not perks[perk.id] then
			perks[perk.id] = npcdu.copy(perk)
			perks[perk.id]["module"] = module
		else
			Printer:Log(LOG.ERROR, CAT.CONF, "cannot add module %s perk %s, it already exists from other module %s", module, perk.id, perks[perk.id]["module"])
		end
	end
	-- Printer:LogTable("Added Deck Perks", module_perks)
	update_module_perks(module)
end

function update_module_perks(module)
	Printer:Log(LOG.RUN, CAT.CONF, "update module %s perks", module)
	local module_perks = get_module_perks(module)
	apply_module_perks_settings(module, module_perks)
	-- Printer:LogTable("Updated Deck Perks", module_perks)
end

-- NPCs DECK

local npcs = {}

ABILITY_STATE = {
	READY = "READY",
	COOLDOWN = "COOLDOWN",
	READING = "READING",
	DISABLED = "DISABLED",
}

-- returns true of a new npc is added
function add_npc(npc_id)
	if npcs[npc_id] then return false end
	Printer:Log(LOG.ADD, CAT.CONF,"npc %s added", npc_id)
	npcs[npc_id] = {}
	npcs[npc_id]["id"] = npc_id
	npcs[npc_id]["recruited"] = false
	npcs[npc_id]["has_profile"] = false
	npcs[npc_id]["alive"] = true
	npcs[npc_id]["show_profile"] = false
	npcs[npc_id]["Perk"] = {}
	npcs[npc_id]["Ability"] = {}
	npcs[npc_id]["Info"] = {}
	npcs[npc_id]["Info"]["can_recruit"] = nil
	npcs[npc_id]["Info"]["last_joined"] = nil
	npcs[npc_id]["Info"]["last_time_seen"] = nil
	npcs[npc_id]["Info"]["last_place_seen"] = nil
	npcs[npc_id]["Info"]["last_place_tracked"] = nil
	npcs[npc_id]["Info"]["codec_frequency"] = nil
	return true
end

function remap_npc(npc_id, new_id)
	if not npc_id or not npcs[npc_id] then return false end
	Printer:Log(LOG.RUN, CAT.CONF,"npc %s remapped to %s", npc_id, new_id)
	npcs[new_id] = npcs[npc_id]
	npcs[new_id].id = new_id
	-- delete old npcs
	npcs[npc_id] = nil
	return true
end

function set_show_profile(npc_id, show)
	if not npcs[npc_id] then return end
	npcs[npc_id].show_profile = show
end

function set_recruited(npc_id, enlist)
	if not npcs[npc_id] then return end
	npcs[npc_id].recruited = enlist
	if enlist then
		npcs[npc_id].Info.last_joined = game.get_game_time()
	end
end

function is_recruited(npc_id)
	if not npcs[npc_id] then return false end
	return npcs[npc_id].recruited
end

function set_deck(deck)
    npcs = deck
end

function get_deck()
    return npcs
end

function get_npcs_id_list()
	local npcs_list = {}
	for id, _ in pairs(npcs) do
		table.insert(npcs_list, id)
	end
	return npcs_list
end

function remove_npc(npc_id)
	if not npc_id then return end
	npcs[npc_id]["alive"] = false
end

function purge_npc(npc_id)
	if not npc_id then return end
	npcs[npc_id] = nil
end

function get_npc(npc_id)
    if not npc_id then return end
    return npcs[npc_id]
end

function get_npc_info(npc_id)
    if not npc_id then return end
    return npcs[npc_id].Info
end

function set_npc_info(npc_id, info)
    if not npc_id or not info then return end
    npcs[npc_id].Info = info
end

function set_last_joined(npc_id, time)
	if not npcs[npc_id] then return end
	npcs[npc_id].Info.last_joined = time
end

function set_last_place_seen(npc_id, place)
	if not npcs[npc_id] then return end
	npcs[npc_id].Info.last_place_seen = place
end

function  set_last_place_tracked(npc_id, place)
	if not npcs[npc_id] then return end
	npcs[npc_id].Info.last_place_tracked = place
end

function get_npc_perk(npc_id, perk_id)
	if not npc_id or not npcs[npc_id] or not perk_id then return end
	return npcs[npc_id].Perk[perk_id]
end

function get_npc_perks(npc_id)
	if not npc_id or not npcs[npc_id] then return end
	return npcs[npc_id].Perk
end

function get_archetype_perk(npc_id)
	if not npc_id or not npcs[npc_id] then return end
	for i = 1, #npcs[npc_id].Perk, 1 do
		if npcs[npc_id].Perk[i].type == PERK_TYPE.ARCHETYPE then
			local perk_id = npcs[npc_id].Perk[i].id
			return perks[perk_id]
		end
	end
end

function has_perks(npc_id)
	if not npc_id or not npcs[npc_id] then return end
	return npcdu.tablelength(npcs[npc_id].Perk) > 0
end

function has_perk(npc_id, perk_id)
	if not perk_id or not npc_id or not npcs[npc_id] then return end
	local perk = npcs[npc_id].Perk[perk_id]
	return perk and true or false
end


local function roll_perk(npc_id, functor)
	Printer:Log(LOG.RUN, CAT.CONF,"executing npc %s roll", npc_id)
	if not functor then return false end
	local ex_functor = npcdu.copy(functor)
	table.insert(ex_functor, npc_id)
	Printer:TraceTable("npc executing", ex_functor)
	local result = execute_func(unpack(ex_functor))
	Printer:Trace(LOG.INFO, CAT.EXEC,"with result: %s", result)
	return result
end

-- returns true of the perk is rolled
function roll_npc_perk(npc_id, perk_id)
	Printer:Log(LOG.RUN, CAT.CONF,"npc %s rolls perk", npc_id)
	if not npc_id or not perk_id or not perks[perk_id] then return end
	Printer:Log(LOG.INFO, CAT.CONF,"perk %s is available", perk_id)
	local perk = perks[perk_id]
	if npcs[npc_id].Perk[perk.id] then return end
	Printer:Log(LOG.INFO, CAT.CONF,"npc %s never rolled this perk", npc_id)
	if roll_perk(npc_id, perk.roll_functor) then
		npcs[npc_id].Perk[perk.id] = {}
		npcs[npc_id].Perk[perk.id]["id"]  = perk.id
		-- npcs[npc_id].Perk[perk.id].rank  = 0
		-- local npc = npcdu.get_npc_obj(npc_id)
		-- npcdu.print_tip(perk.roll_desc, 10000, npc:character_name(), npcdu.get_feat_rank_desc(npc_id, perk_id))
		return true
	end
end

function get_perks_id_list()
	local plist = {}
	for id, perk in pairs(perks) do
		table.insert(plist, perk.id)
	end
	return plist
end

local function get_randomized_perk_list(perk_type, perk_archetype)
	local list = {}
	for _, perk in pairs(perks) do
		if perk.type == perk_type then
			if perk_archetype then
				--- not implemented
				if perk.archetype == perk_archetype then
					table.insert(list, perk)
				end
			else
				table.insert(list, perk)
			end
		end
	end
	npcdu.shuffle(list)
	return list
end

function create_profile(npc_id)
	Printer:Log(LOG.RUN, CAT.CONF,"npc %s create profile", npc_id)
	-- ARCHETYPE
	-- atm only one perk can be added, of type archetype
	local archetype_perk_list = get_randomized_perk_list(PERK_TYPE.ARCHETYPE)
	local i = 1
	-- loop until succesfully rolls the archetype
	while not roll_npc_perk(npc_id, archetype_perk_list[i].id) do
		i = i + 1
		if i > #archetype_perk_list then
			break
			-- i = 1 
			-- shuffle(archetype_perk_list)	
		end
	end

	-- -- MAIN PERKS ??
	-- -- no perks available atm
	-- local main_perk_list = get_randomized_perk_list(PERK_TYPE.MAIN, Get_archetype_perk(npc_id))
	-- local i = 1
	-- local perk_count = 0
	-- -- loop until max perks count have been succesfully rolled
	-- while perk_count < MAX_MAIN_PERKS do
	-- 	if roll_npc_perk(npc_id, main_perk_list[i].id) then
	-- 		perk_count = perk_count + 1
	-- 	end
	-- 	i = i + 1
	-- 	if i > #main_perk_list then 
	-- 		shuffle(main_perk_list)
	-- 		i = 1
	-- 	end
	-- end	

	-- -- SECONDARY PERKS
	-- -- no perks available atm
	-- local secondary_perk_list = get_randomized_perk_list(PERK_TYPE.SECONDARY)
	-- local i = 1
	-- local perk_count = 0
	-- -- loop until max perks count have been succesfully rolled
	-- while perk_count < MAX_SECONDARY_PERKS do
	-- 	if roll_npc_perk(npc_id, secondary_perk_list[i].id) then
	-- 		perk_count = perk_count + 1
	-- 	end
	-- 	i = i + 1
	-- 	if i > #secondary_perk_list then 
	-- 		shuffle(secondary_perk_list)
	-- 		i = 1
	-- 	end
	-- end

	npcs[npc_id].has_profile = true
	Printer:LogTable(string.format("Create Profile NPC %s", npc_id), npcs[npc_id])
end

function get_npc_feats(npc_id, feat_id)
	local npc_feats_list = {}
	for _, npc_perk in pairs(npcs[npc_id].Perk) do
		for _, perk in pairs(perks) do
			if perk.id == npc_perk.id then
				for _, feat in pairs(perk.feats) do
					local npc_feat = npcdu.copy(feat)
					npc_feat["perk_module"] = perk.module
					npc_feat["perk_id"] = perk.id
					npc_feat["perk_name"] = perk.name
					local rank = npcdu.get_feat_rank(npc_id)
					npc_feat["stats"] = feat.stats[rank]
					if feat_id and feat.id == feat_id then
						return npc_feat
					else
						table.insert(npc_feats_list, npc_feat)
					end
				end
			end
		end
	end
	return npc_feats_list
end

function add_ability(npc_id, feat)
	local a_id = feat.id
	Printer:Log(LOG.ADD, CAT.CONF,"npc %s adds ability %s", npc_id, a_id)
    npcs[npc_id].Ability[a_id] = {}
	npcs[npc_id].Ability[a_id]["id"] = a_id
	npcs[npc_id].Ability[a_id]["mode"] = feat.mode
	npcs[npc_id].Ability[a_id]["icon"] = feat.icon_hud
	npcs[npc_id].Ability[a_id]["icon_slot"] = feat.icon_slot
	npcs[npc_id].Ability[a_id]["state"] = ABILITY_STATE.READY

	-- TODO ability should be rank independent 
	local rank = npcdu.get_feat_rank(npc_id, feat.id) -- TODO EXP framework can give this otherwise
	npcs[npc_id].Ability[a_id]["rank"] = rank -- TODO move this out from ability
	npcs[npc_id].Ability[a_id]["cooldown"] = feat.stats[rank].cooldown or 1 -- TODO move this out from ability
	
	npcs[npc_id].Ability[a_id]["timer"] = -1
end

function update_ability(npc_id, feat)
	local a_id = feat.id
	Printer:Log(LOG.ADD, CAT.CONF,"npc %s updates ability %s", npc_id, a_id)
	local rank = npcdu.get_feat_rank(npc_id, feat.id) -- EXP framework can give this otherwise
	npcs[npc_id].Ability[a_id]["cooldown"] = feat.stats[rank].cooldown or 1
end

function remove_ability(npc_id, feat_id)
	if not npcs[npc_id] then return end
	npcs[npc_id].Ability[feat_id] = nil
end

function has_abilities(npc_id)
	if not npcs[npc_id] then return false end

	return npcdu.tablelength(npcs[npc_id].Ability) > 0
end

function get_abilities(npc_id)
	if not npcs[npc_id] then return end
	
	return npcs[npc_id].Ability
end

function clear_abilities(npc_id)
	npcs[npc_id].Ability = {}
end

function get_ability(npc_id, feat_id)
	if not npcs[npc_id] then return end
	
	return npcs[npc_id].Ability[feat_id]
end

function ability_registered(npc_id, feat_id)
	if not npcs[npc_id] then return end
	
	return npcs[npc_id].Ability[feat_id] and true or false
end

function set_ability(npc_id, ability)
    npcs[npc_id].Ability[ability.id] = ability
end

-- NPCS STATS

NPCD_STATS = {
	PERK = "Perk",
	NPCS = "Npcs",
	ACTOR = "Actor"
}

local stats = {}
stats["Perk"] = {}
stats["Npcs"] = {}
stats["Actor"] = {}

function get_stats()
	return stats
end

function set_stats(s)
	stats = s
end

function set_stat(stat_type, key, stat)
	stats[stat_type][key] = stat
end

function get_stat(stat_type, key)
	return stats[stat_type][key]
end

function set_discovered(perk_id)
	if stats.Perk[perk_id] and stats.Perk[perk_id].discovered then return false end
	if not stats.Perk[perk_id] then
		stats.Perk[perk_id] = {}
	end
	stats.Perk[perk_id]["discovered"] = true
	return true
end

function set_favorite(npc_id, favorite)
	if not npcs[npc_id] then return end
	if not stats.Npcs[npc_id] then
		stats.Npcs[npc_id] = {}
	end

	stats.Npcs[npc_id]["favorite"] = favorite
end

function get_favorite(npc_id)
	return stats.Npcs[npc_id] and stats.Npcs[npc_id]["favorite"] or false
end

-- NPCS DATA for MCM

local data = {}
function get_npc_data(id)
	Printer:Log(LOG.RUN, CAT.CONF,"getting npc %s data", id)
	if not id then return nil end
    local npc = npcdu.get_npc_obj(id) -- or alife_object(id)
    if npc and IsStalker(npc) then
        local npc_data = {}
        npc_data.id = id
        npc_data.name = npc:character_name()
        npc_data.community = character_community(npc)
        npc_data.rank_name = ranks.get_obj_rank_name(npc)
        npc_data.rank = npcdu.get_npc_rank(npc)
        npc_data.reputation = npcdu.get_npc_reputation(npc)
        local squad = get_object_squad(npc)
        npc_data.squad_id = squad and squad.id or nil
        npc_data.squad_commander = squad and squad:commander_id() == npc.id or false
        npc_data.standings = {
            attitude = npc:general_goodwill(db.actor),
            relation = npc:relation(db.actor),
            goodwill_personal = npc:goodwill(db.actor),
            goodwill_actor_faction = relation_registry.community_goodwill(character_community(npc), db.actor:id()),
            goodwill_rank = game_relations.get_rank_relation(npc, db.actor),
            goodwill_reputation = game_relations.get_reputation_relation(npc, db.actor),
            goodwill_communities = relation_registry.community_relation(character_community(npc), character_community(db.actor)),
            sympathy = npc:sympathy(),
        }
		Printer:DebugTable("NPCS Data cache update", npc_data)
        data[id] = npc_data
        return data[id]
    elseif data[id] then
		Printer:DebugTable("NPCS Data cache returns", data[id])
        return data[id]
    end
    return nil
end

function get_data()
    return data
end

function set_data(new_data)
    data = new_data
end


function actor_on_first_update()
    printf("$[NPCD][Main] npcd actor_on_first_update")
end

function on_game_start()
    printf("$[NPCD][Main] npcd on_game_start")
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	get_printer()
end