npcdu = ncpd_utils

-- PERKS DECK 

local perks_deck = {}

MAX_SECONDARY_PERKS = 3
MAX_MAIN_PERKS = 1

PERK_TYPE = {
	ARCHETYPE = "perk_archetype",
	MAIN = "perk_main",
	SECONDARY = "perk_secondary"
}

FEAT_TYPE = {
	ACTIVE = "feat_active",
	PASSIVE = "feat_passive"
}

FEAT_MODE = {
	AUTO = "feat_auto",
	MANUAL = "feat_manual"
}

function get_perk_deck(perk_id)
    return perks_deck[perk_id]
end

function add_module_perks(perks)
	for _, perk in pairs(perks) do
		if not perks_deck[perk.id] then
			perks_deck[perk.id] = perk
		end
	end 

	npcdu.printlog_table("perks_deck", perks_deck)
end

-- NPCs DECK

local npcs_deck = {}

ABILITY_STATE = {
	READY = "READY",
	COOLDOWN = "COOLDOWN",
	READING = "READING",
	DISABLED = "DISABLED",
}

-- returns true of a new npc is added
function add_npc_deck(npc_id)
	if npcs_deck[npc_id] then return false end
	printf("-- npc %s added", npc_id)
	npcs_deck[npc_id] = {}
	npcs_deck[npc_id]["id"] = npc_id
	npcs_deck[npc_id]["Perk"] = {}
	npcs_deck[npc_id]["Ability"] = {}
	return true
end

function set_npcs_deck(npcs)
    npcs_deck = npcs
end

function remove_npc_deck(npc_id)
	npcs_deck[npc_id] = nil
end

function get_npc_deck(npc_id)
    if not npc_id then return npcs_deck end 
    return npcs_deck[npc_id]
end

function get_npc_perks(npc_id)
	if not npcs_deck[npc_id] then return end

	return npcs_deck[npc_id].Perk
end

function get_npc_perk(npc_id, perk_id)
	if not npcs_deck[npc_id] or not npcs_deck[npc_id].Perk[perk_id] then return end

	return perks_deck[perk_id]
end

function get_npc_archetype_perk(npc_id)
	if not npcs_deck[npc_id] then return end
	for i = 1, #npcs_deck[npc_id].Perk, 1 do

		if npcs_deck[npc_id].Perk[i].type == PERK_TYPE.ARCHETYPE then
			return npcs_deck[npc_id].Perk[i]
		end
	end
end

function has_npc_perk(npc_id, perk_id)

	if not npcs_deck[npc_id] then return end

	local perk = npcs_deck[npc_id].Perk[perk_id]
	
	return (perk and (perk.rank >= 0)) or false
end


local function roll_perk(npc_id, functor)
	if not functor then return false end
	table.insert(functor, npc_id)
	return execute_func(unpack(functor))
end

-- returns true of the perk is rolled
function roll_npc_perk(npc_id, perk_id)
	printf("-- npc %s Roll_perk", npc_id)
	if not perks_deck[perk_id] then return end
	printf("-- perk %s is available", perk_id)
	local perk = perks_deck[perk_id]
	if npcs_deck[npc_id].Perk[perk.id] then return end
	printf("-- npc %s never rolled this perk", npc_id)
	local result = false
	npcs_deck[npc_id].Perk[perk.id] = {}
	npcs_deck[npc_id].Perk[perk.id]["id"]  = perk.id
	npcs_deck[npc_id].Perk[perk.id]["rank"]  = -1

	if roll_perk(npc_id, perk.roll_functor) then
		npcs_deck[npc_id].Perk[perk.id].rank  = 0  -- 0 stands for acquired
		local npc = npcdu.get_npc(npc_id)
		npcdu.print_tip(perk.roll_success_desc, 10000, npc:character_name(), npcdu.get_feat_rank_desc(npc_id, perk_id))
		result = true
	end
	npcdu.printlog_table(string.format("Roll_perk NPC %s", npc_id), npcs_deck[npc_id])
	return result
end

function add_npc_perks(npc_id, perks)
end

function set_npc_perks(npc_id, perks)
end

local function get_randomized_perk_list(type, archetype)
	local list = {}
	for _, perk in pairs(perks_deck) do
		if perk.type == type then
			if archetype then
				--- not implemented
				if perk.archetype == archetype then
					table.insert(list, perk)	
				end
			else
				table.insert(list, perk)
			end
		end
	end
	npcdu.shuffle(list)
	return list
end

function create_npc_profile(npc_id)

	-- ARCHETYPE
	-- atm only one perk can be added, of type archetype
	local archetype_perk_list = get_randomized_perk_list(PERK_TYPE.ARCHETYPE)
	local i = 1
	-- loop until succesfully rolls the archetype
	while not roll_npc_perk(npc_id, archetype_perk_list[i].id) do
		i = i + 1
		if i > #archetype_perk_list then
			return
			-- i = 1 
			-- shuffle(archetype_perk_list)	
		end
	end
	
	-- -- MAIN PERKS ??
	-- -- no perks available atm
	-- local main_perk_list = get_randomized_perk_list(PERK_TYPE.MAIN, Get_archetype_perk(npc_id))
	-- local i = 1
	-- local perk_count = 0
	-- -- loop until max perks count have been succesfully rolled
	-- while perk_count < MAX_MAIN_PERKS do
	-- 	if roll_npc_perk(npc_id, main_perk_list[i].id) then
	-- 		perk_count = perk_count + 1
	-- 	end
	-- 	i = i + 1
	-- 	if i > #main_perk_list then 
	-- 		shuffle(main_perk_list)
	-- 		i = 1
	-- 	end
	-- end	

	-- -- SECONDARY PERKS
	-- -- no perks available atm
	-- local secondary_perk_list = get_randomized_perk_list(PERK_TYPE.SECONDARY)
	-- local i = 1
	-- local perk_count = 0
	-- -- loop until max perks count have been succesfully rolled
	-- while perk_count < MAX_SECONDARY_PERKS do
	-- 	if roll_npc_perk(npc_id, secondary_perk_list[i].id) then
	-- 		perk_count = perk_count + 1
	-- 	end
	-- 	i = i + 1
	-- 	if i > #secondary_perk_list then 
	-- 		shuffle(secondary_perk_list)
	-- 		i = 1
	-- 	end
	-- end	
end

function add_npc_ability(npc_id, feat)
	local a_id = feat.id
	printf("-- npc %s add_npc_ability %s", npc_id, a_id)
    npcs_deck[npc_id].Ability[a_id] = {}
	npcs_deck[npc_id].Ability[a_id]["id"] = a_id
	npcs_deck[npc_id].Ability[a_id]["icon"] = feat.icon_hud
	npcs_deck[npc_id].Ability[a_id]["state"] = ABILITY_STATE.READY
	local rank = npcdu.get_feat_rank(npc_id, feat.id) -- EXP framework should give this
	npcs_deck[npc_id].Ability[a_id]["cooldown"] = feat.cooldown or feat.stats[rank].cooldown or 360
	npcs_deck[npc_id].Ability[a_id]["timer"] = -1
end

local function remove_npc_ability(npc_id, feat_id)
    local a_id = feat_id
	npcs_deck[npc_id].Ability[a_id] = nil
end

function has_npc_abilities(npc_id)
	if not npcs_deck[npc_id] then return false end

	return npcdu.tablelength(npcs_deck[npc_id].Ability) > 0
end

function get_npc_abilities(npc_id)
	if not npcs_deck[npc_id] then return end
	
	return npcs_deck[npc_id].Ability
end

function get_npc_ability(npc_id, perk_id)
	if not npcs_deck[npc_id] then return end
	
	return npcs_deck[npc_id].Ability[perk_id]
end

function set_npc_ability(npc_id, ability)
    npcs_deck[npc_id].Ability[ability.id] = ability
end