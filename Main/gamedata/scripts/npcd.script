local npcdu = npcd_utils
local execute_func = execute_func

function set_printer(main_printer)
	Printer = main_printer
	LOG = Printer:GetLogTypes()
	CAT = Printer:GetLogCategories()
end

-- PERKS DECK 

local perks = {}

MAX_SECONDARY_PERKS = 3
MAX_MAIN_PERKS = 1

PERK_TYPE = {
	ARCHETYPE = "st_npcd_perk_type_archetype",
	MAIN = "st_npcd_perk_type_main",
	SECONDARY = "st_npcd_perk_type_secondary"
}

FEAT_TYPE = {
	ACTIVE = "st_npcd_feat_type_active",
	PASSIVE = "st_npcd_feat_type_passive"
}

FEAT_MODE = {
	AUTO = "st_npcd_feat_mode_auto",
	MANUAL = "st_npcd_feat_mode_manual"
}

function add_module_perks(module_perks)
	for _, perk in pairs(module_perks) do
		if not perks[perk.id] then
			perks[perk.id] = perk
		end
	end 
	-- Printer:LogTable("Deck Perks", perks)
end

-- NPCs DECK

local npcs = {}

ABILITY_STATE = {
	READY = "READY",
	COOLDOWN = "COOLDOWN",
	READING = "READING",
	DISABLED = "DISABLED",
}

-- returns true of a new npc is added
function add_npc(npc_id)
	if npcs[npc_id] then return false end
	Printer:Log(LOG.ADD, CAT.CONF,"npc %s added", npc_id)
	npcs[npc_id] = {}
	npcs[npc_id]["id"] = npc_id
	npcs[npc_id]["Perk"] = {}
	npcs[npc_id]["Ability"] = {}
	return true
end

function set_deck(deck)
    npcs = deck
end

function get_deck()
    return npcs
end

function remove_npc(npc_id)
	if not npc_id then return end
	npcs[npc_id] = nil
end

function get_npc(npc_id)
    if not npc_id then return end
    return npcs[npc_id]
end

function get_perk(perk_id, npc_id)
	if not perk_id then return end -- cannot continue
	if npc_id and (not npcs[npc_id] or not npcs[npc_id].Perk[perk_id]) then return end -- npc perk query but npc does not have this perk

	return perks[perk_id]
end

function get_perk_feats(perk_id)
	if not perk_id then return end -- cannot continue
	return perks[perk_id].feats
end

function get_perk_feat(perk_id, feat_id)
	if not perk_id or not perks[perk_id].feats then return end -- cannot continue
	return perks[perk_id].feats[feat_id]
end

function get_npc_perks(npc_id)
	if not npc_id or not npcs[npc_id] then return end
	return npcs[npc_id].Perk
end

function get_archetype_perk(npc_id)
	if not npc_id or not npcs[npc_id] then return end
	for i = 1, #npcs[npc_id].Perk, 1 do
		if npcs[npc_id].Perk[i].type == PERK_TYPE.ARCHETYPE then
			local perk_id = npcs[npc_id].Perk[i].id
			return perks[perk_id]
		end
	end
end

function has_perk(npc_id, perk_id)
	if not perk_id or not npc_id or not npcs[npc_id] then return end
	local perk = npcs[npc_id].Perk[perk_id]
	return (perk and (perk.rank >= 0)) or false
end


local function roll_perk(npc_id, functor)
	Printer:Log(LOG.INFO, CAT.CONF,"executing npc %s roll", npc_id)
	if not functor then return false end
	table.insert(functor, npc_id)
	-- PRINT.log_table("roll_functor", functor)
	return execute_func(unpack(functor))
end

-- returns true of the perk is rolled
function roll_npc_perk(npc_id, perk_id)
	Printer:Log(LOG.INFO, CAT.CONF,"npc %s Roll_perk", npc_id)
	if not npc_id or not perk_id or not perks[perk_id] then return end
	Printer:Log(LOG.INFO, CAT.CONF,"perk %s is available", perk_id)
	local perk = perks[perk_id]
	if npcs[npc_id].Perk[perk.id] then return end
	Printer:Log(LOG.INFO, CAT.CONF,"npc %s never rolled this perk", npc_id)
	if roll_perk(npc_id, perk.roll_functor) then
		npcs[npc_id].Perk[perk.id] = {}
		npcs[npc_id].Perk[perk.id]["id"]  = perk.id
		npcs[npc_id].Perk[perk.id].rank  = 0  -- 0 stands for acquired TODO revise this
		local npc = npcdu.get_npc_obj(npc_id)
		npcdu.print_tip(perk.roll_success_desc, 10000, npc:character_name(), npcdu.get_feat_rank_desc(npc_id, perk_id))
		Printer:LogTable(string.format("Roll_perk NPC %s", npc_id), npcs[npc_id])
		return true
	end
end

function add_perks(npc_id, some_perks)
end

function set_perks(npc_id, new_perks)
end

local function get_randomized_perk_list(perk_type, perk_archetype)
	local list = {}
	for _, perk in pairs(perks) do
		if perk.type == perk_type then
			if perk_archetype then
				--- not implemented
				if perk.archetype == perk_archetype then
					table.insert(list, perk)	
				end
			else
				table.insert(list, perk)
			end
		end
	end
	npcdu.shuffle(list)
	return list
end

function create_profile(npc_id)

	-- ARCHETYPE
	-- atm only one perk can be added, of type archetype
	local archetype_perk_list = get_randomized_perk_list(PERK_TYPE.ARCHETYPE)
	local i = 1
	-- loop until succesfully rolls the archetype
	while not roll_npc_perk(npc_id, archetype_perk_list[i].id) do
		i = i + 1
		if i > #archetype_perk_list then
			return
			-- i = 1 
			-- shuffle(archetype_perk_list)	
		end
	end
	
	-- -- MAIN PERKS ??
	-- -- no perks available atm
	-- local main_perk_list = get_randomized_perk_list(PERK_TYPE.MAIN, Get_archetype_perk(npc_id))
	-- local i = 1
	-- local perk_count = 0
	-- -- loop until max perks count have been succesfully rolled
	-- while perk_count < MAX_MAIN_PERKS do
	-- 	if roll_npc_perk(npc_id, main_perk_list[i].id) then
	-- 		perk_count = perk_count + 1
	-- 	end
	-- 	i = i + 1
	-- 	if i > #main_perk_list then 
	-- 		shuffle(main_perk_list)
	-- 		i = 1
	-- 	end
	-- end	

	-- -- SECONDARY PERKS
	-- -- no perks available atm
	-- local secondary_perk_list = get_randomized_perk_list(PERK_TYPE.SECONDARY)
	-- local i = 1
	-- local perk_count = 0
	-- -- loop until max perks count have been succesfully rolled
	-- while perk_count < MAX_SECONDARY_PERKS do
	-- 	if roll_npc_perk(npc_id, secondary_perk_list[i].id) then
	-- 		perk_count = perk_count + 1
	-- 	end
	-- 	i = i + 1
	-- 	if i > #secondary_perk_list then 
	-- 		shuffle(secondary_perk_list)
	-- 		i = 1
	-- 	end
	-- end	
end

function add_ability(npc_id, feat)
	local a_id = feat.id
	Printer:Log(LOG.ADD, CAT.CONF,"npc %s add_ability %s", npc_id, a_id)
    npcs[npc_id].Ability[a_id] = {}
	npcs[npc_id].Ability[a_id]["id"] = a_id
	npcs[npc_id].Ability[a_id]["mode"] = feat.mode
	npcs[npc_id].Ability[a_id]["icon"] = feat.icon_hud
	npcs[npc_id].Ability[a_id]["icon_slot"] = feat.icon_slot
	npcs[npc_id].Ability[a_id]["state"] = ABILITY_STATE.READY
	local rank = npcdu.get_feat_rank(npc_id, feat.id) -- EXP framework should give this
	npcs[npc_id].Ability[a_id]["cooldown"] = feat.cooldown or feat.stats[rank].cooldown or 360
	npcs[npc_id].Ability[a_id]["timer"] = -1
end

function remove_ability(npc_id, feat_id)
    local a_id = feat_id
	npcs[npc_id].Ability[a_id] = nil
end

function has_abilities(npc_id)
	if not npcs[npc_id] then return false end

	return npcdu.tablelength(npcs[npc_id].Ability) > 0
end

function get_abilities(npc_id)
	if not npcs[npc_id] then return end
	
	return npcs[npc_id].Ability
end

function get_ability(npc_id, perk_id)
	if not npcs[npc_id] then return end
	
	return npcs[npc_id].Ability[perk_id]
end

function set_ability(npc_id, ability)
    npcs[npc_id].Ability[ability.id] = ability
end