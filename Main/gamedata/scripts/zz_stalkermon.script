-- notifications

print_tip = function(text,delay, ...)

    -- local enabled = dynavision_mcm.get_config('configuration/notifications/enable')
	local enabled = true
    if enabled then
		local text = tostring(text)
		printf(text, ...)
		if not db.actor then
			return
		end
		
		local ico = "ui_inGame2_Dengi_otdani"
		local text_color = utils_xml.get_color("pda_white")
		local arg_color = utils_xml.get_color("d_green")
		local function colorize(s)
			return arg_color .. s .. text_color
		end
		local i = 0
		local t = {...}
		if #t > 0 then
			local function sr(a)
				i = i + 1
				if (type(t[i]) == 'userdata') then
					if (t[i].x and t[i].y) then
						return colorize(vec_to_str(t[i]))
					end
					return colorize('userdata')
				end
				return colorize(tostring(t[i]))
			end
			text = string.gsub(game.translate_string(text), "%%s", sr)
		else
			text = game.translate_string(text)
		end
		text = text_color .. text
		if delay == nil then
			delay = 6000
		end
		news_manager.send_tip(db.actor, text, nil, ico, delay)
	end
end

function tablelength(T)
  local count = 0
  for _ in pairs(T) do count = count + 1 end
  return count
end

local sm_perks = {}

PERK_TYPE = {
	ARCHETYPE = "perk_archetype"
}

FEAT_TYPE = {
	ACTIVE = "feat_active",
	PASSIVE = "feat_passive"
}

function add_module_perks(perks)
	for _, perk in pairs(perks) do
		if not sm_perks[perk.id] then
			sm_perks[perk.id] = perk
		end
	end 

	printlog_table("sm_perks", sm_perks)
end

local stalkers = {}
C = {
	id = "id",
	PERKS = "PERKS",
	rank = "rank",
	ABILITIES = "ABILITIES",
	state = "state",
	ready = "ready",
	timer = "timer"
}

ABILITY_STATE = {
	READY = "READY",
	COOLDOWN = "COOLDOWN",
	READING = "READING",
	DISABLED = "DISABLED",
}

local RANK = {
	novice = 1,
	trainee = 1,
	experienced = 2,
	professional = 2,
	veteran = 3,
	expert = 4,
	master = 4,
	legend = 5,
}

local function get_npc(npc_id)
	return db.storage[npc_id] and db.storage[npc_id].object
end

function Get_desc_rank(npc)
	return ranks.get_se_obj_rank_name(npc)
end

-- this should come from EXP framework
function Get_feat_rank(npc_id, feat_id)
	local npc = get_npc(npc_id)
	local rank = "novice"
	if npc and npc:alive() then
		rank = ranks.get_se_obj_rank_name(npc)
	end

	return rank and RANK[rank] or 1
end

-- returns true of a new npc is added
function Add_npc(npc_id)
	if stalkers[npc_id] then return false end
	printf("-- npc %s added", npc_id)
	stalkers[npc_id] = {}
	stalkers[npc_id]["id"] = npc_id
	stalkers[npc_id]["PERKS"] = {}
	stalkers[npc_id]["ABILITIES"] = {}
	return true
end

local function add_ability(npc_id, feat)
	stalkers[npc_id]["ABILITIES"][feat.id] = {}
	stalkers[npc_id]["ABILITIES"][feat.id]["id"] = feat.id
	stalkers[npc_id]["ABILITIES"][feat.id]["icon"] = feat.icon_hud
	stalkers[npc_id]["ABILITIES"][feat.id]["state"] = ABILITY_STATE.READY
	local rank = Get_feat_rank(npc_id, feat.id) -- EXP framework should give this
	stalkers[npc_id]["ABILITIES"][feat.id]["cooldown"] = feat.cooldown or feat.stats[rank].cooldown or 360
	stalkers[npc_id]["ABILITIES"][feat.id]["timer"] = -1
end

local function remove_ability(npc_id, feat_id)
	stalkers[npc_id]["ABILITIES"][feat_id] = nil
end

function Remove_npc(npc_id)
	stalkers[npc_id] = nil
end

function Get_perks(npc_id)
	if not stalkers[npc_id] then return end

	return stalkers[npc_id]["PERKS"]
end

function Get_perk(npc_id, perk_id)
	if not stalkers[npc_id] or not stalkers[npc_id]["PERKS"][perk_id] then return end
	
	return sm_perks[perk_id]
end

function Has_perk(npc_id, perk_id)

	if not stalkers[npc_id] then return end

	local perk = stalkers[npc_id]["PERKS"][perk_id]
	
	return (perk and (perk.rank >= 0)) or false
end

-- returns true of the perk is rolled
function Roll_perk(npc_id, perk_id, roll_functor)
	printf("-- npc %s Roll_perk", npc_id)
	if not sm_perks[perk_id] then return end
	printf("-- perk %s is available", perk_id)
	local perk = sm_perks[perk_id]
	if stalkers[npc_id]["PERKS"][perk.id] then return end
	printf("-- npc %s never rolled this perk", npc_id)
	stalkers[npc_id]["PERKS"][perk.id] = {}
	stalkers[npc_id]["PERKS"][perk.id]["id"]  = perk.id
	stalkers[npc_id]["PERKS"][perk.id]["rank"]  = -1
	printf("roll_functor %s", roll_functor)
	local roll = roll_functor and execute_func(unpack(roll_functor))
	if roll then
		stalkers[npc_id]["PERKS"][perk.id]["rank"]  = 0  -- 0 stands for acquired
		return true
	end
	printlog_table(string.format("Roll_perk NPC %s", npc_id), stalkers[npc_id])
	return false
end

function Add_perk(npc_id, perks)
end

function Set_perks(npc_id, perks)
end

function Register_abilities(npc_id, perk_id)
	printf("- npc %s Register_abilities", npc_id)
	local perk = Get_perk(npc_id, perk_id)
	if not perk then return end
	printf("- npc %s Register_abilities for perk %s", npc_id, perk_id)
    for _, feat in pairs(perk.feats) do
		if feat.type == FEAT_TYPE.ACTIVE then
			add_ability(npc_id, feat)
		end
	end
end

function Unregister_abilities(npc_id, perk_id)
	printf("! npc %s Unregister_abilities for perk %s", npc_id, perk_id)
	local perk = Get_perk(npc_id, perk_id)
	if not perk then return end
    for _, feat in pairs(perk.feats) do
		if feat.type == FEAT_TYPE.ACTIVE then
			remove_ability(npc_id, feat.id)
		end
	end
end

-- time event function
function manage_ability_cooldown(npc_id, feat_id)
	if not stalkers[npc_id] then return true end  -- npc died?
	if not stalkers[npc_id]["ABILITIES"][feat_id] then return true end -- ability unregistered?
	if stalkers[npc_id]["ABILITIES"][feat_id].state == ABILITY_STATE.READY then
		stalkers[npc_id]["ABILITIES"][feat_id].state = ABILITY_STATE.COOLDOWN
	end
	if stalkers[npc_id]["ABILITIES"][feat_id].timer <= -5 then
		stalkers[npc_id]["ABILITIES"][feat_id].timer = -999
		stalkers[npc_id]["ABILITIES"][feat_id].state = ABILITY_STATE.READY
		printf("! ending time event %s", npc_id)
		return true
	elseif stalkers[npc_id]["ABILITIES"][feat_id].timer == 0 then
		stalkers[npc_id]["ABILITIES"][feat_id].state = ABILITY_STATE.READING
	end
	local timer = stalkers[npc_id]["ABILITIES"][feat_id].timer
	local cooldown = stalkers[npc_id]["ABILITIES"][feat_id].cooldown
	printf("// [tg][%s] manage_ability %s cooldown %s/%s", time_global(), feat_id, timer, cooldown)
	stalkers[npc_id]["ABILITIES"][feat_id].timer = stalkers[npc_id]["ABILITIES"][feat_id].timer - 1
	CreateTimeEvent("ability_coolddown", tostring(npc_id) .. feat_id .. "_" .. tostring(timer), 1, manage_ability_cooldown, npc_id, feat_id)
	return true
end

function Activate_ability(npc_id, feat_id)
	printf("! npc %s activate_ability %s", npc_id, feat_id)

    if not npc_id or not stalkers[npc_id] or not stalkers[npc_id]["ABILITIES"][feat_id] then return false end

	if (stalkers[npc_id]["ABILITIES"][feat_id].state == ABILITY_STATE.COOLDOWN) then return false end

	stalkers[npc_id]["ABILITIES"][feat_id].timer = stalkers[npc_id]["ABILITIES"][feat_id].cooldown
	stalkers[npc_id]["ABILITIES"][feat_id].state = ABILITY_STATE.READY 
	CreateTimeEvent("ability_coolddown", tostring(npc_id) .. feat_id, 1, manage_ability_cooldown, npc_id, feat_id)
	return true
end

function Has_abilities(npc_id)
	if not stalkers[npc_id] then return false end

	return tablelength(stalkers[npc_id]["ABILITIES"]) > 0
end

function Get_abilities(npc_id)
	if not stalkers[npc_id] then return end
	
	return stalkers[npc_id]["ABILITIES"]
end

function Get_ability(npc_id, perk_id)
	if not stalkers[npc_id] then return end
	
	return stalkers[npc_id]["ABILITIES"][perk_id]
end

---- COMPANIONS

function is_companions_squad_in_danger()
	--printf("============================================================================================")
	local squad_is_peaceful = true
	local clist = axr_companions.list_actor_squad_by_id()
	for i=1, #clist do
		local npc = db.storage[clist[i]] and db.storage[clist[i]].object
		if npc then
			local is_peaceful = false
			-- check if is in fight
			if npc:alive() then
				is_peaceful = (not npc:best_enemy()) and npc:dont_has_info("npcx_beh_ignore_combat") and true or false
			end
			-- printf("companion[%s] is_peaceful %s - dist: %s",k.id, is_peaceful, distance_between(db.actor,npc))
			-- check if is too far away
			squad_is_peaceful = squad_is_peaceful and is_peaceful
			-- printf("current calculation for squad is_peaceful %s", squad_is_peaceful)					
		end	
	end	
	if not squad_is_peaceful then
		-- printf("squad is under attack or attacking")
	end
	-- printf("-- squad is resolved peaceful %s", squad_is_peaceful)
	--printf("============================================================================================")
	return not squad_is_peaceful
end


--------------- SQUAD UPDATES
---
-- ADD

axrc_OG_add_special_task_npc_to_actor_squad = axr_companions.add_special_task_npc_to_actor_squad
function axr_companions.add_special_task_npc_to_actor_squad(npc)
	-- printf("-- MP add_special_task_npc_to_actor_squad")
	axrc_OG_add_special_task_npc_to_actor_squad(npc)
	SendScriptCallback("stalkermon_squad_update")
end

axrc_OG_add_special_squad = axr_companions.add_special_squad
function axr_companions.add_special_squad(npc)
	-- printf("-- MP add_special_squad")
	axrc_OG_add_special_squad(npc)
	SendScriptCallback("stalkermon_squad_update")
end

axrc_OG_add_to_actor_squad = axr_companions.add_to_actor_squad
function axr_companions.add_to_actor_squad(npc)
    -- printf("-- MP add_to_actor_squad")
    axrc_OG_add_to_actor_squad(npc)
    SendScriptCallback("stalkermon_squad_update")
end

-- REMOVE

axrc_OG_remove_from_actor_squad = axr_companions.remove_from_actor_squad
function axr_companions.remove_from_actor_squad(npc)
	axrc_OG_remove_from_actor_squad(npc)
	SendScriptCallback("stalkermon_squad_update")
end

axrc_OG_remove_all_from_actor_squad = axr_companions.remove_all_from_actor_squad
function axr_companions.remove_all_from_actor_squad(npc)
	axrc_OG_remove_all_from_actor_squad(npc)
	SendScriptCallback("stalkermon_squad_update")
end

-- DEATH

local function squad_on_npc_death(squad,se_npc)
	local npc = db.storage[se_npc.id] and db.storage[se_npc.id].object
	if not npc then return end
	-- printf("squad_on_npc_death name %s", npc and npc:name())
	local npc_id = npc:id() or 0
	Remove_npc(npc_id)
	for id,actor_squad in pairs(axr_companions.companion_squads) do
		if squad.id == actor_squad.id then
			SendScriptCallback("stalkermon_squad_update")
		end
	end
end


-- STATE MGMT

local string_format = string.format
function printlog_table(text, node, ...)
    
    text = string_format(text, ...)
    printf("STALKERMON: | %s | \n" .. utils_data.print_table(node, text, true), time_global(), ...)
end

function save_state(m_data)
	printf("$ STALKERMON Save State")
    if not m_data.stalkermon then
        m_data.stalkermon = {}
    end 
    -- save the state
    m_data.stalkermon.stalkers = stalkers
	printlog_table("STALKERMON", m_data.stalkermon.stalkers)
end

function load_state(m_data)
	printf("$ STALKERMON Load State")
	if m_data.stalkermon and m_data.stalkermon.stalkers then
        -- cache the state
		stalkers = m_data.stalkermon.stalkers
		printlog_table("Stalkers", stalkers)
	end
end

squad_in_danger = true
function actor_on_first_update()
    squad_in_danger = is_companions_squad_in_danger()
end


local tg_update = 0
local tg_update_step = 1000 --[ms]
function actor_on_update()

	local tg = time_global()
	if tg < tg_update then
		return
	end
	tg_update = tg + tg_update_step

	squad_in_danger = is_companions_squad_in_danger()

	-- printlog_table("Stalkers", stalkers)
end

function register_module(module_name, perks)
	printf("- register_module %s", module_name)
	add_module_perks(perks)
end

if AddScriptCallback then
	AddScriptCallback("stalkermon_squad_update")
end

function on_game_start()
	
	RegisterScriptCallback("actor_on_update",actor_on_update)
	RegisterScriptCallback("actor_on_first_update",actor_on_first_update)
	RegisterScriptCallback("squad_on_npc_death",squad_on_npc_death)

    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("save_state", save_state)	
end