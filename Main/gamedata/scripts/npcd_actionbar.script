local npcdu = npcd_utils

MAX_SLOTS = 16
function get_printer()
	if not Printer then
		Printer = npcd_logging.get_printer("npcd_actionbar")
	end 
	LOG = Printer:GetLogTypes()
	CAT = Printer:GetLogCategories()
end
if AddScriptCallback then
	RegisterScriptCallback("npcd_on_log_update", get_printer)
end

local actionbar = {
    slots = {},         -- List of all slots
    by_index = {},      -- Index → list of slots (supports multiple per index)
    by_key = {}         -- Key → single slot
}

function get_actionbar()
    return actionbar
end

function add_action_slot(action, force_index)

    local index = force_index or npcd_actionbar_mcm.get_slot_index(action.key) or 0
    Printer:Debug(LOG.ADD, CAT.CONF,"added slot %s for action %s", index, action.key)
    local slot = {
        index = index,
        key = action.key,
        action = action,
        activation_input = {
            action = action,
            settings = npcd_actionbar_mcm.get_slot_activation_settings(action.key),
        }
    }
    Printer:DebugTable("Actionbar:add action slot", slot)
    -- Add to master slot list
    table.insert(actionbar.slots, slot)

    -- Add to index map
    if not actionbar.by_index[index] then
        actionbar.by_index[index] = {}
    end
    table.insert(actionbar.by_index[index], slot)

    -- Add to key map
    actionbar.by_key[slot.key] = slot
end

function bind_action_slot(slot_key)
    local slot = actionbar.by_key[slot_key]
    if not slot then
        Printer:Debug(LOG.WARN, CAT.CONF, "Cannot bind - no slot found for action %s", slot_key)
        return false
    end

    -- Remove from old index map
    if actionbar.by_index[slot.index] then
        for i = 1, #actionbar.by_index[slot.index] do
            if actionbar.by_index[slot.index][i].key == slot.key then
                table.remove(actionbar.by_index[slot.index], i)
                break
            end
        end
        if #actionbar.by_index[slot.index] == 0 then
            actionbar.by_index[slot.index] = nil
        end
    end

    -- Update slot properties
    slot.index = npcd_actionbar_mcm.get_slot_index(slot.key) or slot.index
    slot.activation_input.settings = npcd_actionbar_mcm.get_slot_activation_settings(slot.key) or slot.activation_input.settings

    -- Add to new index map
    if not actionbar.by_index[slot.index] then
        actionbar.by_index[slot.index] = {}
    end
    table.insert(actionbar.by_index[slot.index], slot)

    -- bind action slot to input manager
    npcd_input_manager.bind_activation_input(slot.key, slot.activation_input)

    Printer:Debug(LOG.INFO, CAT.CONF, "Updated action slot %s for action %s", slot.index, slot.key)
    return true
end

function bind_actionbar_slots()
    Printer:Debug(LOG.ADD, CAT.CONF, "Binding all actionbar slots")

    -- Create temporary copy of slots since we'll be modifying the actionbar
    local slots_to_update = {}
    for _, slot in ipairs(actionbar.slots) do
        table.insert(slots_to_update, {
            key = slot.key,
        })
    end

    -- Update each slot
    local updated_count = 0
    for _, slot in ipairs(slots_to_update) do
        if bind_action_slot(slot.key) then
            updated_count = updated_count + 1
        end
    end

    Printer:Debug(LOG.INFO, CAT.CONF, "Updated %s actionbar slots", updated_count)
end

function get_actionbar_slots_list()
    Printer:Debug(LOG.RUN, CAT.CONF,"getting actionbar slots list")
    -- Printer:LogTable("Actionbar", actionbar.by_index)
    local action_slots_list = {}
    local action_bar_slots = MAX_SLOTS

    for i = 1, action_bar_slots do
        local current_slots = actionbar.by_index[i]
        if current_slots and #current_slots > 0 then
            -- Use existing slot(s) at index i
            for _, slot in ipairs(current_slots) do
                table.insert(action_slots_list, slot)
            end
        else
            local fallback_slot = nil

            -- Try to get one from index 0
            if actionbar.by_index[0] and #actionbar.by_index[0] > 0 then
                fallback_slot = table.remove(actionbar.by_index[0], 1)
            else
                -- Search ahead for the next available slot
                for j = i + 1, action_bar_slots do
                    if actionbar.by_index[j] and #actionbar.by_index[j] > 0 then
                        fallback_slot = table.remove(actionbar.by_index[j], 1)
                        break
                    end
                end
            end

            if fallback_slot then
                -- Update the slot's index and insert it
                fallback_slot.index = i
                table.insert(action_slots_list, fallback_slot)

                -- Also update the actionbar.by_index[i] to reflect the change
                actionbar.by_index[i] = actionbar.by_index[i] or {}
                table.insert(actionbar.by_index[i], fallback_slot)
            end
        end
    end

    return action_slots_list
end

function remove_action_slot(action_id)
    Printer:Debug(LOG.RUN, CAT.CONF,"removing action slot %s", action_id)
    local slot = actionbar.by_key[action_id]
    
    if not slot then
        Printer:Debug(LOG.WARN, CAT.CONF, "Cannot remove - no slot found for action %s", action_id)
        return false
    end

    -- Remove from slots array
    for i = 1, #actionbar.slots do
        if actionbar.slots[i].key == slot.key then
            table.remove(actionbar.slots, i)
            break
        end
    end
    
    -- Remove from index map
    if actionbar.by_index[slot.index] then
        for i = 1, #actionbar.by_index[slot.index] do
            if actionbar.by_index[slot.index][i].key == slot.key then
                table.remove(actionbar.by_index[slot.index], i)
                break
            end
        end
        -- Clean up empty lists
        if #actionbar.by_index[slot.index] == 0 then
            actionbar.by_index[slot.index] = nil
        end
    end
    
    -- Remove from key map
    actionbar.by_key[slot.key] = nil

    -- Remove input binding
    npcd_input_manager.remove_activation_input(slot.key)

    Printer:Debug(LOG.INFO, CAT.CONF, "Removed action slot %s for action %s", slot.index, slot.key)
    return true
end

function clear_actionbar()
    actionbar.slots = {}
    actionbar.by_index = {}
    actionbar.by_key = {}
end

-- not used but it should redone to take validation functor from caller
-- function is_valid_slot(index, npc_id, feat_id)
--     if not index or index < 0 or index > 8 then return false end
--     if not npc_id or not feat_id then return false end
    
--     -- Check if NPC exists and has the ability
--     local ability = npcd.get_ability(npc_id, feat_id)
--     return ability ~= nil
-- end

function has_slot(action_id)
    return actionbar.by_key[action_id] ~= nil
end

function is_slot_available(index)
    return not actionbar.by_index[index] or #actionbar.by_index[index] == 0
end

function get_slot_by_index(index)
    return actionbar.by_index[index]
end

function count_slots()
    return {
        total = #actionbar.slots,
        used = 0,
        available = npcd_mcm.get_setting("actionbar", "main/max_slots") or settings.max_slots
    }
end

function update_actionbar(action_list)
    Printer:Debug(LOG.RUN, CAT.UI_ACTION, "updating actionbar")
    on_option_change()
    Printer:DebugTable("Updating actionbar with action list", action_list)
    -- Get current squad
    if npcdu.tablelength(action_list) == 0 and not settings.show_always then
        npcd_actionbar_hud.show(false)
        return
    end

    -- Reset actionbar
    clear_actionbar()

    -- Add actions from provided list
    local slot_index = 1
    for _, action in pairs(action_list) do
        add_action_slot(action)
        slot_index = slot_index + 1
    end
    
    -- update action slots mcm menu settings with the new actionbar
    npcd_actionbar_mcm.update_mcm_menu()

    -- update actionbar slots bindings from the updated mcm settings
    bind_actionbar_slots()

    -- refresh hud
    SendScriptCallback("npcd_actionbar_hud_update")

    Printer:Debug(LOG.INFO, CAT.UI_ACTION, "Action bar update complete with %s slots filled", slot_index - 1)
end

-- if AddScriptCallback then
	-- AddScriptCallback("npcd_actionbar_refresh")
-- end

settings = {
    ["max_slots"] = nil,
    ["show_empty"] = nil,
    ["offset_x"] = nil,
    ["offset_y"] = nil
}

function on_option_change()
	settings.max_slots = npcd_mcm.get_setting("actionbar", "main/max_slots")
	settings.show_empty = npcd_mcm.get_setting("actionbar", "main/show_empty")
    settings.show_always = npcd_mcm.get_setting("actionbar", "main/show_always")
	settings.offset_x = npcd_mcm.get_setting("actionbar", "main/offset_x")
	settings.offset_y = npcd_mcm.get_setting("actionbar", "main/offset_y")
end

function on_npcd_started()
    on_option_change()
end

function actor_on_first_update()
    printf("$[NPCD][Main] npcd_actionbar actor_on_first_update")
end

function on_game_start()
    printf("$[NPCD][Main] npcd_actionbar on_game_start")
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("npcd_started", on_npcd_started)
    get_printer()
    -- RegisterScriptCallback("npcd_actionbar_refresh", refresh_actionbar)
end

