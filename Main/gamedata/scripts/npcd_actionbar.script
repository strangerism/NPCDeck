local npcdu = npcd_utils
local FEAT_SETTING = NPCD.FEAT_SETTING

MAX_SLOTS = 16
function get_printer()
	if not Printer then
		Printer = npcd_logging.get_printer("npcd_actionbar")
	end 
	LOG = Printer:GetLogTypes()
	CAT = Printer:GetLogCategories()
end
if AddScriptCallback then
	RegisterScriptCallback("npcd_on_log_update", get_printer)
end

local actionbar = {
    slots = {},         -- List of all slots
    by_index = {},      -- Index → list of slots (supports multiple per index)
    by_key = {}         -- Key → single slot
}

function get_actionbar()
    return actionbar
end 

function get_actionslot_key(npc_id, feat_id)
    return npc_id .. "_" .. feat_id
end

function get_actionslot_ids(actionslot_key)
    local parts = {}
    for part in string.gmatch(actionslot_key, "[^_]+") do
        table.insert(parts, part)
    end
    local npc_id = parts[1]
    local feat_id = parts[2]
    return npc_id, feat_id
end

function add_action_slot(npc_id, feat_id, force_index)
    local key = get_actionslot_key(npc_id, feat_id)
    local feat = npcd.get_npc_feat(npc_id, feat_id)
    local index = force_index or npcd_actionbar_mcm.get_feat_index_slot(npc_id, feat.id) or 0
    Printer:Debug(LOG.ADD, CAT.CONF,"add action slot %s for npc %s and ability %s", index, npc_id, feat_id)
    local feat_activation_input = npcd_actionbar_mcm.get_feat_activation_input(npc_id, feat)
    local slot = {
        index = index,
        key = key,
        npc_id = npc_id,
        feat_id = feat_id,
        activation_input = feat_activation_input
    }

    -- Add to master slot list
    table.insert(actionbar.slots, slot)

    -- Add to index map
    if not actionbar.by_index[index] then
        actionbar.by_index[index] = {}
    end
    table.insert(actionbar.by_index[index], slot)

    -- Add to key map
    actionbar.by_key[key] = slot
end

function bind_action_slot(npc_id, feat_id)
    local key = get_actionslot_key(npc_id, feat_id)
    local slot = actionbar.by_key[key]
    
    if not slot then
        Printer:Debug(LOG.WARN, CAT.CONF, "Cannot bind - no slot found for npc %s and ability %s", npc_id, feat_id)
        return false
    end

    local feat = npcd.get_npc_feat(npc_id, feat_id)
    local new_index = npcd_actionbar_mcm.get_feat_index_slot(npc_id, feat.id)
    local new_activation_input = npcd_actionbar_mcm.get_feat_activation_input(npc_id, feat)
    
    -- Remove from old index map
    if actionbar.by_index[slot.index] then
        for i = 1, #actionbar.by_index[slot.index] do
            if actionbar.by_index[slot.index][i].key == key then
                table.remove(actionbar.by_index[slot.index], i)
                break
            end
        end
        if #actionbar.by_index[slot.index] == 0 then
            actionbar.by_index[slot.index] = nil
        end
    end

    -- Update slot properties
    slot.index = new_index or slot.index
    slot.activation_input = new_activation_input or slot.activation_input

    -- Add to new index map
    if not actionbar.by_index[slot.index] then
        actionbar.by_index[slot.index] = {}
    end
    table.insert(actionbar.by_index[slot.index], slot)

    -- bind action slot to input manager
    slot.activation_input["npc_id"] = npc_id
    slot.activation_input["feat_id"] = feat_id
    npcd_input_manager.bind_activation_input(slot.key, slot.activation_input)

    Printer:Debug(LOG.INFO, CAT.CONF, "Updated action slot %s for npc %s and ability %s", slot.index, npc_id, feat_id)
    return true
end

function add_npc_abilities_to_actionbar(npc_id)
    Printer:Debug(LOG.RUN, CAT.CONF,"add npc %s abilities to actionbar", npc_id)
    local npc_abilities = npcd.get_abilities(npc_id)
    if npc_abilities then
        for id, ability in pairs(npc_abilities) do
            if ability.mode == npcd.FEAT_MODE.MANUAL then
                add_action_slot(npc_id, ability.id)
            end
        end
    end
end

function bind_actionbar_slots()
    Printer:Debug(LOG.ADD, CAT.CONF, "Binding all actionbar slots")

    -- Create temporary copy of slots since we'll be modifying the actionbar
    local slots_to_update = {}
    for _, slot in ipairs(actionbar.slots) do
        table.insert(slots_to_update, {
            npc_id = slot.npc_id,
            feat_id = slot.feat_id
        })
    end

    -- Update each slot
    local updated_count = 0
    for _, slot in ipairs(slots_to_update) do
        if bind_action_slot(slot.npc_id, slot.feat_id) then
            updated_count = updated_count + 1
        end
    end

    Printer:Debug(LOG.INFO, CAT.CONF, "Updated %s actionbar slots", updated_count)
end

function remove_npc_abilities_from_actionbar(npc_id)
    Printer:Debug(LOG.REMOVE, CAT.CONF,"remove npc %s abilities to actionbar", npc_id)
    local npc_abilities = npcd.get_abilities(npc_id)
    if npc_abilities then
        for id, ability in pairs(npc_abilities) do
            Printer:LogTable("Actionbar:remove npc ability", ability)
            if ability.mode == npcd.FEAT_MODE.MANUAL then
                remove_action_slot(npc_id, ability.id)
            end
        end
    end
end

function get_actionbar_slots_list()
    Printer:Debug(LOG.RUN, CAT.CONF,"get actionbar slots list")
    -- Printer:LogTable("Actionbar", actionbar.by_index)
    local action_slots_list = {}
    local action_bar_slots = MAX_SLOTS

    for i = 1, action_bar_slots do
        local current_slots = actionbar.by_index[i]
        if current_slots and #current_slots > 0 then
            -- Use existing slot(s) at index i
            for _, slot in ipairs(current_slots) do
                table.insert(action_slots_list, slot)
            end
        else
            local fallback_slot = nil

            -- Try to get one from index 0
            if actionbar.by_index[0] and #actionbar.by_index[0] > 0 then
                fallback_slot = table.remove(actionbar.by_index[0], 1)
            else
                -- Search ahead for the next available slot
                for j = i + 1, action_bar_slots do
                    if actionbar.by_index[j] and #actionbar.by_index[j] > 0 then
                        fallback_slot = table.remove(actionbar.by_index[j], 1)
                        break
                    end
                end
            end

            if fallback_slot then
                -- Update the slot's index and insert it
                fallback_slot.index = i
                table.insert(action_slots_list, fallback_slot)

                -- Also update the actionbar.by_index[i] to reflect the change
                actionbar.by_index[i] = actionbar.by_index[i] or {}
                table.insert(actionbar.by_index[i], fallback_slot)
            end
        end
    end

    return action_slots_list
end

function remove_action_slot(npc_id, feat_id)
    Printer:Debug(LOG.RUN, CAT.CONF,"npc %s remove ability %s action slot", npc_id, feat_id)
    local key = get_actionslot_key(npc_id, feat_id)
    local slot = actionbar.by_key[key]
    
    if not slot then
        Printer:Debug(LOG.WARN, CAT.CONF, "Cannot remove - no slot found for npc %s and ability %s", npc_id, feat_id)
        return false
    end

    -- Remove from slots array
    for i = 1, #actionbar.slots do
        if actionbar.slots[i].key == key then
            table.remove(actionbar.slots, i)
            break
        end
    end
    
    -- Remove from index map
    if actionbar.by_index[slot.index] then
        for i = 1, #actionbar.by_index[slot.index] do
            if actionbar.by_index[slot.index][i].key == key then
                table.remove(actionbar.by_index[slot.index], i)
                break
            end
        end
        -- Clean up empty lists
        if #actionbar.by_index[slot.index] == 0 then
            actionbar.by_index[slot.index] = nil
        end
    end
    
    -- Remove from key map
    actionbar.by_key[key] = nil

    -- Remove input binding
    npcd_input_manager.remove_activation_input(key)
    
    Printer:Debug(LOG.INFO, CAT.CONF, "Removed action slot %s for npc %s and ability %s", slot.index, npc_id, feat_id)
    return true
end

function clear_actionbar()
    actionbar.slots = {}
    actionbar.by_index = {}
    actionbar.by_key = {}
end

function is_valid_slot(index, npc_id, feat_id)
    if not index or index < 0 or index > 8 then return false end
    if not npc_id or not feat_id then return false end
    
    -- Check if NPC exists and has the ability
    local ability = npcd.get_ability(npc_id, feat_id)
    return ability ~= nil
end

function has_slot(index, npc_id, feat_id)
    local key = get_actionslot_key(npc_id, feat_id)
    return actionbar.by_key[key] ~= nil
end

function is_slot_available(index)
    return not actionbar.by_index[index] or #actionbar.by_index[index] == 0
end

function get_slot_by_index(index)
    return actionbar.by_index[index]
end

function get_slot_by_ability(npc_id, feat_id)
    local key = get_actionslot_key(npc_id, feat_id)
    return actionbar.by_key[key]
end

function get_npc_slots(npc_id)
    local npc_slots = {}
    for _, slot in ipairs(actionbar.slots) do
        if slot.npc_id == npc_id then
            table.insert(npc_slots, slot)
        end
    end
    return npc_slots
end

function count_slots()
    return {
        total = #actionbar.slots,
        used = 0,
        available = npcd_mcm.get_setting("actionbar", "main/max_slots") or settings.max_slots
    }
end

-- function save_actionbar_state()
--     local state = {}
--     for i, slot in ipairs(actionbar.slots) do
--         table.insert(state, {
--             index = slot.index,
--             npc_id = slot.npc_id,
--             feat_id = slot.feat_id
--         })
--     end
--     return state
-- end

-- function load_actionbar_state(state)
--     clear_actionbar()
--     for _, slot in ipairs(state) do
--         add_action_slot(slot.index, slot.npc_id, slot.feat_id)
--     end
-- end

function reset_actionbar()
    Printer:Debug(LOG.RUN, CAT.UI_ACTION, "reset actionbar")
    -- Get current squad
    if not npcd_squad.squad_available() then
        Printer:Debug(LOG.INFO, CAT.UI_ACTION, "npcd_hud_update but no squad available")
        SendScriptCallback("npcd_hud_update")
        return
    end

    clear_actionbar()
    local squad_size = npcd_squad.squad_get_size()
    Printer:Debug(LOG.INFO, CAT.UI_ACTION, "Resetting action bar from squad of %s npcs", squad_size)
    
    -- Process each squad member
    local slot_index = 1
    local clist = npcd_squad.squad_get_clist()
    for i=1, #clist do
        local npc = npcdu.get_npc_obj(clist[i])
        if npc and IsStalker(npc) and npc:alive() then
            if npcd.get_npc(npc:id()) then
                add_npc_abilities_to_actionbar(npc:id())
                slot_index = slot_index + 1
            end
        end
    end
    
    refresh_actionbar()
    Printer:Debug(LOG.INFO, CAT.UI_ACTION, "Action bar reset complete with %s slots filled", slot_index - 1)
    -- Printer:LogTable("Reset Actionbar", actionbar.by_index)
end

function refresh_actionbar()
    Printer:Debug(LOG.RUN, CAT.UI_ACTION, "refresh actionbar")

    -- update actionbar mcm slots with new the actionbar data
    npcd_actionbar_mcm.update_mcm_menu()
    
    -- update actionar from mcm
    bind_actionbar_slots()

    -- refresh hud
    SendScriptCallback("npcd_hud_update")
end

-- if AddScriptCallback then
	-- AddScriptCallback("npcd_actionbar_refresh")
-- end

settings = {
    ["max_slots"] = nil,
    ["show_empty"] = nil,
}

function on_option_change()
	settings.max_slots = npcd_mcm.get_setting("actionbar", "main/max_slots")
	settings.show_empty = npcd_mcm.get_setting("actionbar", "main/show_empty")
    reset_actionbar()
end

function on_npcd_started()
    on_option_change()
end

function actor_on_first_update()
    printf("$[NPCD][Main] npcd_actionbar actor_on_first_update")
end

function on_game_start()
    printf("$[NPCD][Main] npcd_actionbar on_game_start")
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("npcd_started", on_npcd_started)
    -- RegisterScriptCallback("npcd_actionbar_refresh", refresh_actionbar)
end

