local npcdu = npcd_utils

function get_printer()
	if not Printer then
		Printer = npcd_logging.get_printer("npcd_manager")
	end 
	LOG = Printer:GetLogTypes()
	CAT = Printer:GetLogCategories()
end
-- if AddScriptCallback then
	RegisterScriptCallback("npcd_on_log_update", get_printer)
-- end

local FEAT_TYPE = npcd.FEAT_TYPE
local FEAT_MODE = npcd.FEAT_MODE
local ABILITY_STATE = npcd.ABILITY_STATE

--------------- Utilities

local function execute_register(npc_id, register, functor)
	if not functor then return false end
	local ex_functor = npcdu.copy(functor)
	table.insert(ex_functor, npc_id)
	table.insert(ex_functor, register)
	Printer:TraceTable("execute_register", ex_functor)
	local result = execute_func(unpack(ex_functor))
	Printer:Trace(LOG.INFO, CAT.EXEC,"with result: %s", result)
	return result
end

local function execute_activate(npc_id, feat_id, functor)
	if not functor then return false end
	local ex_functor = npcdu.copy(functor)
	table.insert(ex_functor, npcd.get_npc_feat_data(npc_id, feat_id))
	Printer:TraceTable("execute_activate", ex_functor)
	local result = execute_func(unpack(ex_functor))
	Printer:Trace(LOG.INFO, CAT.EXEC,"with result: %s", result)
	return result
end

local function run_register_feat(npc_id, feat, register)
	if feat.register_functor then
		return execute_register(npc_id, register, feat.register_functor)
	else
		return true
	end
end

local function run_register_perk(npc_id, perk, register)
	if perk.register_functor then
		return execute_register(npc_id, register, perk.register_functor)
	else
		return true
	end
end

local function get_ability_polling_id(npc_id, feat_id)
	return "ability_polling_" .. tostring(npc_id) .. "_" .. feat_id
end

local function get_ability_cooldown_id(npc_id, feat_id)
	return "ability_cooldown_" .. tostring(npc_id) .. "_" .. feat_id
end

local function create_polling_input(npc_id, feat)
	local polling_input = {}
	polling_input["id"] = get_ability_polling_id(npc_id, feat.id)
	polling_input["npc_id"] = npc_id
	polling_input["feat_id"] = feat.id
	polling_input["interval"] = feat.activation_polling_interval or 1
	polling_input["activation_functor"] = feat.activation_functor
	return polling_input
end

--------------- Execution MGMT
---

Tasks = {}
EXECUTION_TYPE = { cooldown = "cooldown", polling = "polling"}
local function remove_execution(id)
	if not Tasks[id] then return end
	Printer:Debug(LOG.STOP, CAT.EXEC,"removed execution %s", id)
	RemoveTimeEvent("npcd_manager", id)
	if Tasks[id].type == EXECUTION_TYPE.cooldown then
		npcd.reset_ability(Tasks[id].npc_id, Tasks[id].feat_id)
	end
	Tasks[id] = nil
end

local function add_cooldown_execution(npc_id, feat_id)
	local ability_cooldown_id = get_ability_cooldown_id(npc_id, feat_id)

	--- CANNOT RESET ABILITY COOLDOWN HERE BECAUSE OF ISSUE WITH ENGINE
	-- -- if ability is on cooldown or reading, remove the current execution and reset it
	-- -- workaround for time events not starting swiftly. CreateTimeEvent can be called multiple times before it actually starts and we need to allow this.
	-- local ability = npcd.get_ability(npc_id, feat_id)
	-- if ability and ability.state == ABILITY_STATE.COOLDOWN and Tasks[ability_cooldown_id] then
	-- 	remove_execution(ability_cooldown_id)
	-- end
	Printer:Debug(LOG.ADD, CAT.EXEC,"[%s] npc %s creates new ability cooldown manager %s", time_global(), npc_id, ability_cooldown_id)
	CreateTimeEvent("npcd_manager", ability_cooldown_id, 0, manage_ability_cooldown, ability_cooldown_id, npc_id, feat_id)
	Tasks[ability_cooldown_id] = { npc_id = npc_id, feat_id = feat_id, type = EXECUTION_TYPE.cooldown}
end

local function add_poll_execution(npc_id, feat)
	local polling_input = create_polling_input(npc_id, feat)
	Printer:Debug(LOG.ADD, CAT.EXEC,"npc %s creates new ability poll manager %s", npc_id, polling_input.id)
	CreateTimeEvent("npcd_manager", polling_input.id, polling_input.interval, poll, polling_input)
	Tasks[polling_input.id] = { npc_id = npc_id, feat_id = feat.id, type = EXECUTION_TYPE.polling}
end

local function reset_execution(id, delay)
	Printer:Trace(LOG.INFO, CAT.EXEC,"resetting execution %s", id)
	ResetTimeEvent("npcd_manager", id, delay)
end

local function remove_npc_executions(npc_id, force)
	Printer:Debug(LOG.RUN, CAT.EXEC,"removing npc %s executions",npc_id)
	for id, execution_info in pairs(Tasks) do
		if execution_info.npc_id == npc_id and (execution_info.type == EXECUTION_TYPE.polling or force) then
			remove_execution(id)
		end
	end
end

local function remove_npc_perk_executions(npc_id, perk_id)
	Printer:Debug(LOG.RUN, CAT.EXEC,"removing npc %s perk %s executions",npc_id, perk_id)
	local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?
	local perk = npcd.get_perk(perk_id)
	if not perk or not perk.feats then return false end -- perk not found?
	for _, feat in pairs(perk.feats) do
		local ability_polling_id = get_ability_polling_id(npc_id, feat.id)
		remove_execution(ability_polling_id)
	end
	return true
end

local function resume_npc_ability_execution(npc_id, feat)
	Printer:Debug(LOG.RUN, CAT.EXEC,"resuming npc %s ability %s execution", npc_id, feat.id)
	if feat.type == FEAT_TYPE.ACTIVE then
		-- active feats have state machine
		if npcd.ability_registered(npc_id, feat.id) then
			Printer:Debug(LOG.INFO, CAT.EXEC,"npc %s restarts execution for ability %s", npc_id, feat.id)
			local npc_ability = npcd.get_ability(npc_id, feat.id)
			Printer:DebugTable("npc ability data", npc_ability)
			if feat.mode == FEAT_MODE.MANUAL and npc_ability.state == ABILITY_STATE.COOLDOWN then
				add_cooldown_execution(npc_id, feat.id)
			end
			if feat.mode == FEAT_MODE.AUTO then
				if npc_ability.state ~= ABILITY_STATE.READY then
					add_cooldown_execution(npc_id, feat.id) -- resume current cooldown if not in READY
				end
				add_poll_execution(npc_id, feat)
			end
			if feat.mode == FEAT_MODE.MODAL then
				if npc_ability.state == ABILITY_STATE.ENABLED then
					npcd.reset_ability(npc_id, feat.id) -- disable modal ability on restart
				end
			end
			-- TODO: is FEAT_MODE.CUSTOM really supported by active feats?
			if feat.mode == FEAT_MODE.CUSTOM and npc_ability.state == ABILITY_STATE.COOLDOWN then
				add_cooldown_execution(npc_id, feat.id)
			end			
		end
	end
end

local function restart_npc_execution(npc_id)
	Printer:Debug(LOG.RUN, CAT.EXEC,"npc %s restarting abilities execution", npc_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?
	if not npcd.has_abilities(npc_id) then return false end -- npc has no abilities
	Printer:DebugTable("Restart Abilities - NPC perks:", npc_deck.Perk)
	for _, npc_perk in pairs(npc_deck.Perk) do
		Printer:Debug(LOG.INFO, CAT.EXEC,"npc %s restarts abilities for perk %s", npc_id, npc_perk.id)
		local perk = npcd.get_perk(npc_perk.id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				resume_npc_ability_execution(npc_id, feat)
			end
		end
	end
	Printer:LogTable("Restarted Abilities", npc_deck.Ability)
	return true
end

local function restart_squad_executions()
	local clist = npcd_squad.squad_get_clist()
	for i = 1, #clist do
		restart_npc_execution(clist[i])
	end
end

local function npcs_sweaper()
	Printer:Log(LOG.RUN, CAT.CONF,"running npcs sweaper")
	local npcs_list = npcd.get_npcs_id_list()
	-- Printer:LogTable("NPCS list", npcs_list)
	for i = 1, #npcs_list do
		local npc_id = npcs_list[i]
		local se_npc = alife_object(npc_id)
		-- REMOVE DEAD
		if not se_npc or not se_npc:alive() or not IsStalker(se_npc) then
			-- Printer:Debug(LOG.REMOVE, CAT.CONF,"remove stale npc %s data", npc_id)
			local npc_deck = npcd.get_npc(npc_id)
			if npc_deck.show_profile then
				npcd.remove_npc(npc_id)
			else
				npcd.purge_npc(npc_id)
			end
		end
		-- PURGE STALE ABILITIES
		if se_npc and IsStalker(se_npc) and se_npc:alive() then
			local npc_deck = npcd.get_npc(npc_id)
			if npc_deck and npc_deck.has_profile and not npcd_squad.is_actor_squad(npc_id) then
				-- Printer:Trace(LOG.RUN, CAT.CONF,"sweaping npc %s abilities", npc_id)
				for ability_id, ability in pairs(npc_deck.Ability) do
					if ability.registered == false and ability.state ~= ABILITY_STATE.COOLDOWN then
						Printer:Debug(LOG.REMOVE, CAT.CONF,"removing unregistered ability %s from npc %s", ability_id, npc_id)
						npcd.remove_ability(npc_id, ability_id)
					end
				end
			end
		end
	end
	ResetTimeEvent("npcd_manager", "npcs_sweaper", 60)
end

local function npcs_profiler()
	Printer:Log(LOG.RUN, CAT.CONF,"running npcs profiler")
	local npcs_list = npcd.get_npcs_id_list()
	-- Printer:LogTable("NPCS list", npcs_list)
	for i = 1, #npcs_list do
		local npc_id = npcs_list[i]
		local se_npc = alife_object(npc_id)
		Printer:Trace(LOG.INFO, CAT.CONF, "se_npc id %s %s", se_npc and se_npc.id or "nil", se_npc and se_npc:name() or "nil")
		local npc_deck = npcd.get_npc(npc_id)
		if se_npc and IsStalker(se_npc) and se_npc:alive() and not npc_deck.has_profile then
			Printer:Debug(LOG.RUN, CAT.CONF,"creating new profile for npc %s %s %s", npc_id, se_npc:name(), se_npc:character_name())
			npcd.create_profile(npc_id)
			npcd.get_npc_data(npc_id) -- initialize npc data for MCM
		end
	end
	ResetTimeEvent("npcd_manager", "npcs_profiler", 60)
end


local function npcs_updater()
	Printer:Log(LOG.RUN, CAT.CONF,"running npcs updater")
	local npcs_list = npcd.get_npcs_id_list()
	-- Printer:LogTable("NPCS list", npcs_list)
	for i = 1, #npcs_list do
		local npc_id = npcs_list[i]
		local se_npc = alife_object(npc_id)
		Printer:Trace(LOG.INFO, CAT.CONF, "se_npc id %s %s", se_npc and se_npc.id or "nil", se_npc and se_npc:name() or "nil")		
		local npc_deck = npcd.get_npc(npc_id)
		if se_npc and IsStalker(se_npc) and se_npc:alive() and npc_deck.has_profile then
			Printer:Trace(LOG.RUN, CAT.CONF,"updating profile for npc %s %s %s", npc_id, se_npc:name(), se_npc:character_name())
			local npc_info = npcd.get_npc_info(se_npc.id)
			npc_info.can_recruit = npcd_relations.can_recruit(se_npc.id)
			npcd.set_npc_info(se_npc.id, npc_info)
		end
	end
	ResetTimeEvent("npcd_manager", "npcs_updater", 360)
end

local function start_npcd_execution()
	Printer:Debug(LOG.RUN, CAT.EXEC,"starting npcd execution")
	-- start the npcd sim tasks
	CreateTimeEvent("npcd_manager", "npcs_sweaper", 3, npcs_sweaper)
	CreateTimeEvent("npcd_manager", "npcs_profiler", 5, npcs_profiler)
	CreateTimeEvent("npcd_manager", "npcs_updater", 10, npcs_updater)
end

local function teardown_npcd_execution()
	Printer:Debug(LOG.STOP, CAT.EXEC,"teardown_npcd_execution")

	-- stop current npc Tasks execution
	for key, value in pairs(Tasks) do
		RemoveTimeEvent("npcd_manager", key)
	end

	-- stopping the npcd sim tasks
	RemoveTimeEvent("npcd_manager", "npcs_sweaper")
	RemoveTimeEvent("npcd_manager", "npcs_profiler")
	RemoveTimeEvent("npcd_manager", "npcs_updater")
end

--------------- Abilities EXEC

-- called by NPCD Manager custom time events
function manage_ability_cooldown(ability_cooldown_id, npc_id, feat_id)
	Printer:Trace(LOG.RUN, CAT.COOLDOWN,"managing npc %s ability cooldown %s", npc_id, feat_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then
		Printer:Log(LOG.ERROR, CAT.COOLDOWN,"npc %s deck not found. stopping manage ability cooldown %s", npc_id, ability_cooldown_id)
		Tasks[ability_cooldown_id] = nil
		return true
	end  -- npc died?

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then
		Printer:Log(LOG.ERROR, CAT.COOLDOWN,"npc %s ability %s not found. stopping manage ability cooldown %s", npc_id, feat_id, ability_cooldown_id)
		Tasks[ability_cooldown_id] = nil
		return true
	end -- ability unregistered?

    -- setup cooldown transition
	if npc_ability.state == ABILITY_STATE.READY then
		Printer:Debug(LOG.START, CAT.COOLDOWN,"[%s] npc %s ability %s init cooldown %s", time_global(), npc_id, feat_id, npc_ability.cooldown)
		npcd.start_ability_cooldown(npc_id, feat_id)
	end

    -- ability cooldown ended, kill time event
	if npc_ability.timer <= 0 then
		npcd.reset_ability(npc_id, feat_id)
		Printer:Debug(LOG.STOP, CAT.COOLDOWN,"cooldown completed. ending time event %s", ability_cooldown_id)
		Tasks[ability_cooldown_id] = nil
		return true
	end

    -- managing cooldown timer
	local timer = npc_ability.timer
	local cooldown = npc_ability.cooldown
	local state = npc_ability.state
	Printer:Debug(LOG.RUN, CAT.COOLDOWN,"npc %s ability %s state %s timer %s/%s", npc_id, feat_id, state, timer, cooldown)
	npcd.update_ability_cooldown(npc_id, feat_id)

    -- loop cooldown management event
	reset_execution(ability_cooldown_id, 1)
	return false
end

local function toggle_modal(npc_id, feat_id)
	if npcd.is_ability_enabled(npc_id, feat_id) then
		Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s disables modal ability %s", npc_id, feat_id)
		npcd.disable_ability(npc_id, feat_id)
	else
		Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s enables modal ability %s", npc_id, feat_id)
		npcd.enable_ability(npc_id, feat_id)
	end
	return true
end

local function activate_ability(npc_id, feat_id)
	Printer:Debug(LOG.RUN, CAT.ACTIV,"activating npc %s ability %s", npc_id, feat_id)

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then return false end -- ability unregistered?
	if npc_ability.mode == FEAT_MODE.MANUAL or npc_ability.mode == FEAT_MODE.AUTO then
		Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s activates ability %s cooldown", npc_id, feat_id)
		add_cooldown_execution(npc_id, feat_id)
	end
	if npc_ability.mode == FEAT_MODE.MODAL then
		Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s toggles ability %s modal", npc_id, feat_id)
		toggle_modal(npc_id, feat_id)
	end
	return true
end

local function actionable_ability(npc_id, feat_id)
	local npc_ability = npcd.get_ability(npc_id, feat_id)
	if npc_ability.mode == FEAT_MODE.MANUAL or npc_ability.mode == FEAT_MODE.AUTO then
		if npcd.is_ability_on_cooldown(npc_id, feat_id) then 
			Printer:Debug(LOG.WARN, CAT.ACTIV,"npc %s cannot activate ability %s that is on cooldown", npc_id, feat_id)
			return false
		else
			Printer:Trace(LOG.INFO, CAT.ACTIV,"npc %s can activate ability %s", npc_id, feat_id)
			return true
		end
	elseif npc_ability.mode == FEAT_MODE.MODAL then
		Printer:Trace(LOG.INFO, CAT.ACTIV,"npc %s can toggle modal ability %s", npc_id, feat_id)
		return true
	end
end

-- called by NPCD Manager custom time events
function poll(polling_input)
	Printer:Debug(LOG.RUN, CAT.ACTIV,"polling npc %s ability %s", polling_input.npc_id, polling_input.feat_id)
	
	-- first ensure this polling task has sense to exists
    local npc_deck = npcd.get_npc(polling_input.npc_id)
	if not npc_deck then
		Printer:Log(LOG.ERROR, CAT.ACTIV,"npc %s deck not found. stopping poll %s", polling_input.npc_id, polling_input.id)
		return true 
	end  -- end this task

	-- second checking ability is actionable
	if actionable_ability(polling_input.npc_id, polling_input.feat_id) then
		-- execute ability
		local activated = execute_activate(polling_input.npc_id, polling_input.feat_id, polling_input.activation_functor)
		-- activate ability cooldown
		if activated then
			activate_ability(polling_input.npc_id, polling_input.feat_id)
			local ability = npcd.get_ability(polling_input.npc_id, polling_input.feat_id)
			reset_execution(polling_input.id, ability.cooldown) -- resume polling after cooldown
			return false
		end
	end

    -- loop polling event
	reset_execution(polling_input.id, polling_input.interval)
	return false
end

function get_action(npc_id, feat)
	return {
		key = feat.uid,
		activation_functor = feat.activation_functor,
		state_functor = { "npcd", "get_ability", npc_id, feat.id},
		attr = { npc_id = npc_id }
	}
end
-- called by NPCD Input Manager
function activate(action)
	local npc_id = action.attr.npc_id
	local feat_idx = npcd.get_feat_index(action.key)
	local feat_id = feat_idx.feat_id
	local perk_id = feat_idx.perk_id
	Printer:Debug(LOG.RUN, CAT.ACTIV,"activating npc %s perk %s ability %s", npc_id, perk_id, feat_id)

	-- first ensure this polling task has sense to exists
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return true end  -- end this task

	if actionable_ability(npc_id, feat_id) then
		-- execute ability
		local activated = execute_activate(npc_id, feat_id, action.activation_functor)
		-- activate ability cooldown
		if activated then
			activate_ability(npc_id, feat_id)
		end
	end
end

local function bind_ability(npc_id, feat)
	Printer:Debug(LOG.RUN,CAT.ACTIV, "binding npc %s ability %s", npc_id, feat.id)
	if feat.mode == FEAT_MODE.MANUAL then
		local action = get_action(npc_id, feat)
		npcd_actionbar.add_action_slot(action)
	end

	if feat.mode == FEAT_MODE.AUTO then
		add_poll_execution(npc_id, feat)
	end

	if feat.mode == FEAT_MODE.MODAL then
		local action = get_action(npc_id, feat)
		npcd_actionbar.add_action_slot(action)
	end

end

local function unbind_ability(npc_id, feat)
	Printer:Debug(LOG.RUN,CAT.ACTIV, "unbinding npc %s ability %s", npc_id,  feat.id)
	if feat.mode == FEAT_MODE.MANUAL then
		npcd_actionbar.remove_action_slot(feat.uid)
	end

	if feat.mode == FEAT_MODE.AUTO then
		local ability_polling_id = get_ability_polling_id(npc_id, feat.id)
		remove_execution(ability_polling_id)
	end

	if feat.mode == FEAT_MODE.MODAL then
		npcd_actionbar.remove_action_slot(feat.uid)
		npcd.reset_ability(npc_id, feat.id)
	end

end

--- Custom timed counters used by perk modules
--- 
local custom_timed_buff = {}

local function get_timed_buff_id(npc_id, feat_id)
	return "timed_buff_" .. tostring(npc_id) .. "_" .. feat_id
end

local function manage_buff_duration(npc_id, perk_id, feat_id, duration)
	local buff_id = get_timed_buff_id(npc_id, feat_id)
	if not custom_timed_buff[buff_id] then
		Printer:Debug(LOG.ADD, CAT.COOLDOWN,"initializing custom timed buff %s with duration %s", buff_id, duration)
		custom_timed_buff[buff_id] = { value = duration, duration = duration }
		local feat = npcd.get_perk_feat(perk_id, feat_id)
		actor_status.add_indicator(feat.id, {
			index = 1,
			typ = "booster",
			functor = { "npcd_manager", "get_timed_buff_timer", npc_id, feat_id },
			icon = feat.icon_hud or "ui_npcd_hud_default_icon",
			background = "ui\\alticons\\bg1.dds",
			anim_icon = false,
			anim_bk = false,
			anim_period = 5
		})
	end
	if custom_timed_buff[buff_id].value == 0 then
		Printer:Debug(LOG.STOP, CAT.COOLDOWN,"custom timed buff %s expired", buff_id)
		custom_timed_buff[buff_id] = nil
		return true
	end
	custom_timed_buff[buff_id].value = custom_timed_buff[buff_id].value - 1
	Printer:Debug(LOG.INFO, CAT.COOLDOWN,"custom timed buff %s duration %s", buff_id, custom_timed_buff[buff_id].value)
	-- loop cooldown management event
	reset_execution(buff_id, 1)
	return false
end

function create_timed_buff(npc_id, perk_id, feat_id, duration)
	if duration <= 0 then
		Printer:Log(LOG.ERROR, CAT.FEAT,"cannot create custom timed buff for npc %s feat %s with invalid duration %s", npc_id, feat_id, duration)
		return false
	end
	if npc_id == db.actor:id() then
		Printer:Debug(LOG.INFO, CAT.FEAT,"creating custom timed buff for actor, feat %s duration %s", feat_id, duration)
		CreateTimeEvent("npcd_manager", get_timed_buff_id(npc_id, feat_id), 0, manage_buff_duration, npc_id, perk_id, feat_id, duration)
	else
		Printer:Debug(LOG.INFO, CAT.FEAT,"creating custom timed buff for npc %s feat %s duration %s", npc_id, feat_id, duration)
		local ability = npcd.get_ability(npc_id, feat_id)
		if not ability then
			-- Printer:Log(LOG.ERROR, CAT.FEAT,"npc %s ability %s not found. cannot create timed buff", npc_id, feat_id)
			local feat = npcd.get_perk_feat(perk_id, feat_id)
			npcd.add_ability(npc_id, feat)
		end -- ability unregistered?
		npcd.set_ability_settings(npc_id, feat_id, { cooldown = duration })
		add_cooldown_execution(npc_id, feat_id)
	end
end

function get_timed_buff_timer(npc_id, feat_id)
	if npc_id == db.actor:id() then
		local buff_id = get_timed_buff_id(npc_id, feat_id)
		if custom_timed_buff[buff_id] then
			return custom_timed_buff[buff_id].value
		else
			return nil
		end
	else
		local ability = npcd.get_ability(npc_id, feat_id)
		if ability and ability.state == ABILITY_STATE.COOLDOWN then
			return ability.timer
		else
			return 0
		end
	end
end

function is_timed_buff_on(npc_id, feat_id)
	if npc_id == db.actor:id() then
		local buff_id = get_timed_buff_id(npc_id, feat_id)
		return (custom_timed_buff[buff_id] ~= nil)
	else
		return npcd.is_ability_on_cooldown(npc_id, feat_id)
	end
end

-- modal buffs

function get_modal_buff(perk_id, feat_id)
	local feat = npcd.get_perk_feat(perk_id, feat_id)
	return (actor_status.indicators[feat.id] ~= nil) and 1 or 0
end

function create_modal_buff(npc_id, perk_id, feat_id)
	Printer:Debug(LOG.INFO, CAT.FEAT,"creating modal buff for npc %s feat %s", npc_id, feat_id)
	local feat = npcd.get_perk_feat(perk_id, feat_id)
	if not actor_status.indicators[feat.id] then
		-- custom_modal_buff [feat.id] = true
		actor_status.add_indicator(feat.id, {
			index = 1,
			typ = "state",
			functor = { "npcd_manager", "get_modal_buff", perk_id, feat_id },
			icon = feat.icon_hud or "ui_npcd_hud_default_icon",
			background = "ui\\alticons\\bg1.dds",
			anim_icon = false,
			anim_bk = false,
			anim_period = 5
		})
	end
end

function remove_modal_buff(npc_id, perk_id, feat_id)
	Printer:Debug(LOG.INFO, CAT.FEAT,"removing modal buff for npc %s feat %s", npc_id, feat_id)
	local feat = npcd.get_perk_feat(perk_id, feat_id)
	actor_status.indicators[feat.id] = nil
end

-- event validation functions

local function validate_on_hit(victim, shit, bone_id, flags)

	if not victim:alive() then return end
	
	local shooter_id = shit.draftsman:id()

	if shooter_id ~= db.actor:id() and not npcd_squad.is_actor_squad(shooter_id) then
		return
	end
	
	if bone_id == 65535 then
		return
	end
	
	if shit.power >= 50 then return end
	
	local isCompanion = victim:has_info("npcx_is_companion")
	if isCompanion then return end

    local weapon = level.object_by_id(shit.weapon_id)
	
	-- This is to get around how most explosive weapons work in engine
	if weapon and string.find(weapon:section(), "_fake_missile") then
		weapon = db.actor:active_item()
	end
	
	if weapon == nil then 
		return 
	end

	if not IsWeapon(weapon) then
		return
	end

	return true
end

local function execute_event_handler_functor(event_handler, ...)
    local ex_functor = npcdu.copy(event_handler.functor)
    local args = {...}
    for i = 1, #args do
        table.insert(ex_functor, args[i])
    end
    execute_func(unpack(ex_functor))
end

local events_registry = {}

local EVENT_HANDLERS = {
	["npc_on_before_hit"] = {
		callback = "npc_on_before_hit",
		functor =  function(victim, shit, bone_id, flags)
			Printer:Debug(LOG.RUN, CAT.EXEC,"starting global event handler for monster_on_before_hit")
			Printer:DebugTable("- registered callbacks", events_registry["npc_on_before_hit"])
			if validate_on_hit(victim, shit, bone_id, flags) then
				-- Execute all registered callbacks for this event
				for i, event_handler in pairs(events_registry["npc_on_before_hit"] or {}) do
					Printer:Debug(LOG.INFO, CAT.EXEC,"processing callback %s for event %s", i, event_handler.id)
					local power = shit.power
					execute_event_handler_functor(event_handler, victim, shit, bone_id, flags)
					Printer:Debug(LOG.INFO, CAT.EXEC,"updated power %s --> %s", power, shit.power)
				end
			end
			SendScriptCallback("npcd_npc_on_before_hit")
		end},
	["monster_on_before_hit"] = {
		callback = "monster_on_before_hit",
		functor = function(victim, shit, bone_id, flags)
			Printer:Debug(LOG.RUN, CAT.EXEC,"starting global event handler for monster_on_before_hit")
			Printer:DebugTable("- registered callbacks", events_registry["monster_on_before_hit"])
			if validate_on_hit(victim, shit, bone_id, flags) then
				-- Execute all registered callbacks for this event
				for i, event_handler in pairs(events_registry["monster_on_before_hit"] or {}) do
					Printer:Debug(LOG.INFO, CAT.FEAT,"processing callback %s for event %s", i, event_handler.id)
					local power = shit.power
					execute_event_handler_functor(event_handler, victim, shit, bone_id, flags)
					Printer:Debug(LOG.INFO, CAT.FEAT,"updated power %s --> %s", power, shit.power)
				end
			end
			SendScriptCallback("npcd_monster_on_before_hit")
		end},
	}

-- Event Execution

local function register_feat_callback(feat_uid, event_name, functor)
	Printer:Debug(LOG.RUN, CAT.EXEC,"registering feat %s callback for event %s", feat_uid, event_name)
	if not events_registry[event_name] then
		events_registry[event_name] = {}
		if EVENT_HANDLERS[event_name] then
			RegisterScriptCallback(EVENT_HANDLERS[event_name].callback, EVENT_HANDLERS[event_name].functor)
		end
		Printer:Debug(LOG.ADD, CAT.EXEC,"registered event %s", event_name)
	end
	local event_handler = { id = feat_uid, functor = functor }
	table.insert(events_registry[event_name], event_handler)
	Printer:Debug(LOG.ADD, CAT.EXEC,"registered feat %s callback for event %s", feat_uid, event_name)
end

local function register_stance_callback(feat_uid, event_name, functor)
	Printer:Debug(LOG.RUN, CAT.EXEC,"registering stance %s callback for event %s", feat_uid, event_name)
	register_feat_callback(feat_uid .. "_stance", event_name, functor)
end

local function unregister_feat_callbacks(feat_uid)
	Printer:Debug(LOG.RUN, CAT.EXEC,"unregistering all callbacks for feat %s", feat_uid)
	for event_name, event_handlers in pairs(events_registry) do
		for i = #event_handlers, 1, -1 do
			if event_handlers[i].id == feat_uid then
				table.remove(event_handlers, i)
				Printer:Debug(LOG.REMOVE, CAT.EXEC,"unregistered feat %s callback for event %s", feat_uid, event_name)
			end
		end
		if #events_registry[event_name] == 0 then
			events_registry[event_name] = nil
			if EVENT_HANDLERS[event_name] then
				UnregisterScriptCallback(EVENT_HANDLERS[event_name].callback, EVENT_HANDLERS[event_name].functor)
			end
			Printer:Debug(LOG.REMOVE, CAT.EXEC,"unregistered event %s", event_name)
		end
	end
end

local function unregister_stance_callbacks(feat_uid)
	Printer:Debug(LOG.RUN, CAT.EXEC,"unregistering all stance callbacks for feat %s", feat_uid)
	unregister_feat_callbacks(feat_uid .. "_stance")
end

--- Actor Stance Event
--- 
--- 

local stance_registry = {}

local STANCE_HANDLERS = {
	["st_npcd_stance_type_ads"] = {
		enter = { 
			callback = "actor_on_weapon_zoom_in", 
			functor = function(weapon) 
				local check_zoom_factor = SYS_GetParam(2, weapon:section(), "scope_zoom_factor") or 1
				if check_zoom_factor == 0 then
					for _, stance_handle in pairs(stance_registry["st_npcd_stance_type_ads"] or {}) do
						-- fetch feat data
						local feat_idx = npcd.get_feat_index(stance_handle.id)
						local feat = npcd.get_perk_feat(feat_idx.perk_id, feat_idx.feat_id)
						-- build and execute functor
						local ex_functor = npcdu.copy(feat.stance.enter)
						table.insert(ex_functor, weapon)
						execute_func(unpack(ex_functor))
						-- show icon
						if feat.stance.show_icon then
							create_modal_buff(db.actor:id(), feat_idx.perk_id, feat_idx.feat_id)
						end
						-- register stance callbacks
						for _, activation in pairs(feat.stance.activations or {}) do
							register_stance_callback(feat.uid, activation.event, activation.functor)
						end
					end
				end
			end},
		exit = { 
			callback = "actor_on_weapon_zoom_out", 
			functor = function(weapon) 
				for _, stance_handle in pairs(stance_registry["st_npcd_stance_type_ads"] or {}) do
					-- fetch feat data
					local feat_idx = npcd.get_feat_index(stance_handle.id)
					local feat = npcd.get_perk_feat(feat_idx.perk_id, feat_idx.feat_id)
					-- build and execute functor
					local ex_functor = npcdu.copy(feat.stance.exit)
					table.insert(ex_functor, weapon)
					execute_func(unpack(ex_functor))
					-- remove icon
					if feat.stance.show_icon then
						remove_modal_buff(db.actor:id(), feat_idx.perk_id, feat_idx.feat_id)
					end
					-- unregister stance callbacks
					unregister_stance_callbacks(stance_handle.id)
				end
		 	end},
	}
}

local function register_feat_stance(feat_uid, stance_type)
	Printer:Debug(LOG.RUN, CAT.EXEC,"registering stance callbacks for feat %s stance %s", feat_uid, stance_type)
	if not stance_registry[stance_type] then
		stance_registry[stance_type] = {}
		local handler = STANCE_HANDLERS[stance_type]
		if not handler then
			Printer:Log(LOG.ERROR, CAT.EXEC,"cannot register stance callbacks for feat %s with unknown stance type %s", feat_uid, stance_type)
			return
		end
		-- register global stance callbacks
		RegisterScriptCallback(handler.enter.callback, handler.enter.functor)
		RegisterScriptCallback(handler.exit.callback, handler.exit.functor)
		Printer:Debug(LOG.ADD, CAT.EXEC,"registered global stance callbacks for stance type %s", stance_type)
	end
	local stance_handle = { id = feat_uid }
	table.insert(stance_registry[stance_type], stance_handle)
	Printer:Debug(LOG.ADD, CAT.EXEC,"registered callback for feat %s stance %s", feat_uid, stance_type)
end

function unregister_feat_stance(feat_uid)
	Printer:Debug(LOG.RUN, CAT.EXEC,"unregistering all stance callbacks for feat %s", feat_uid)
	for stance_type, stance_handle in pairs(stance_registry) do
		for i = #stance_handle, 1, -1 do
			if stance_handle[i].id == feat_uid then
				table.remove(stance_handle, i)
				Printer:Debug(LOG.REMOVE, CAT.EXEC,"unregistered stance callback for feat %s stance %s", feat_uid, stance_type)
			end
		end
		if #stance_registry[stance_type] == 0 then
			stance_registry[stance_type] = nil
			-- unregister global stance callbacks
			local handler = STANCE_HANDLERS[stance_type]
			if handler then
				UnregisterScriptCallback(handler.enter.callback, handler.enter.functor)
				UnregisterScriptCallback(handler.exit.callback, handler.exit.functor)
				Printer:Debug(LOG.REMOVE, CAT.EXEC,"unregistered global stance callbacks for stance type %s", stance_type)
			end
		end
	end
end

--------------- NPCs
---

local function release_npc(npc_id)
	local npc_deck = npcd.get_npc(npc_id)
	if npc_deck.show_profile then
		npcd.remove_npc(npc_id)
	else
		Printer:Log(LOG.RUN, CAT.CONF, "purging npc %s", npc_id)
		npcd.purge_npc(npc_id)
	end
end

local function register_npc_perks(npc_id, register)
	Printer:Debug(LOG.RUN, CAT.CONF,"npc %s perks %s", npc_id, register and "registration" or "unregistration")
	local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	if register then
		npcd.setup_profile(npc_id)
	end

	for _, npc_perk in pairs(npc_deck.Perk) do
		local perk = npcd.get_perk(npc_perk.id)
		if perk then
			Printer:Debug(LOG.INFO, CAT.CONF,"npc %s perk %s %s", npc_id, npc_perk.id, register and "register" or "unregister")
			run_register_perk(npc_id, perk, register)
		end
	end
	return true
end

local function unregister_feat(npc_id, feat)
	Printer:Debug(LOG.RUN, CAT.CONF,"unregistering npc %s feat %s", npc_id, feat.id)
	if run_register_feat(npc_id, feat, false) then
		if feat.type == FEAT_TYPE.ACTIVE then
			npcd.set_ability_settings(npc_id, feat.id, { registered = false })
			unbind_ability(npc_id, feat)
		end
		if feat.type == FEAT_TYPE.PASSIVE then
			unregister_feat_callbacks(feat.uid)
		end
		if feat.mode == FEAT_MODE.STANCE then
			unregister_feat_stance(feat.uid)
		end
		return true
	else
		Printer:Debug(LOG.ERROR, CAT.CONF,"npc %s cannot unregister feat %s", npc_id, feat.id)
		return false
	end
end
-- TODO: sort out rifleman perk issue where npc cannot register feats
-- how to manage type and mode
local function register_feat(npc_id, feat)
	Printer:Debug(LOG.RUN, CAT.CONF,"registering npc %s feat %s", npc_id, feat.id)
	if run_register_feat(npc_id, feat, true) then
		-- only active feats are registered as abilities
		if feat.type == FEAT_TYPE.ACTIVE then
			npcd.set_ability_settings(npc_id, feat.id, { registered = true })
			bind_ability(npc_id, feat)
		end
		if feat.type == FEAT_TYPE.PASSIVE then
			for _, activation in pairs(feat.activations or {}) do
				register_feat_callback(feat.uid, activation.event, activation.functor)
			end
		end	
		if feat.mode == FEAT_MODE.STANCE then
			register_feat_stance(feat.uid, feat.stance.type)
		end
		return true
	else
		Printer:Debug(LOG.WARN, CAT.CONF,"npc %s cannot register feat %s", npc_id, feat.id)
		return false
	end
end

local function unregister_feats(npc_id)
    Printer:Debug(LOG.RUN, CAT.CONF,"unregistering npc %s feats", npc_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	for _, npc_perk in pairs(npc_deck.Perk) do
		if is_perk_in_deck(npc_id, npc_perk.id) then
			local perk = npcd.get_perk(npc_perk.id)
			if perk and perk.feats  then
				Printer:Debug(LOG.INFO, CAT.CONF,"npc %s unregister feats for perk %s", npc_id, npc_perk.id)
				for _, feat in pairs(perk.feats) do
					unregister_feat(npc_id, feat)
				end
			end
		end
	end
	return true
end

function unregister_perk_feats(npc_id, perk_id)
	Printer:Debug(LOG.RUN, CAT.CONF,"unregistering npc %s perk %s feats", npc_id, perk_id)
	local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	local perk = npcd.get_perk(perk_id)
	if perk and perk.feats  then
		Printer:Debug(LOG.INFO, CAT.CONF,"npc %s unregister feats for perk %s", npc_id, perk_id)
		for _, feat in pairs(perk.feats) do
			unregister_feat(npc_id, feat)
		end
		remove_npc_perk_executions(npc_id, perk_id)
	end
	return true
end

-- RegisterScriptCallback("on_specific_character_init", function(character_id, data)
-- 	printf("%% character_id %s", character_id)
-- 	if data.snd_config:find("(woman|female)") then
-- 		printf("% %s is a woman", character_id)
-- 		female_npc[character_id] = true
-- 	end
-- end)

--- NPC Recruit API

local function unrecruit_npc(npc_id)
	Printer:Debug(LOG.RUN, CAT.NPC, "unrecruiting npc %s", npc_id)
	npcd.set_recruited(npc_id, false)
	local npc_info = npcd.get_npc_info(npc_id)
	if npc_info then
		npc_info.last_time_seen = game.get_game_time()
		npc_info.last_place_seen = dynamic_news_helper.GetPointDescription(db.actor)
		npcd.set_npc_info(npc_id, npc_info)
	end
end

local function recruit_npc(npc_id, clone_id)
	Printer:Debug(LOG.RUN, CAT.NPC, "recruiting npc %s", npc_id)
	if clone_id then
		-- npc recruited through Individually recruitable companions mod dialogs (free, paid)
		if npcd.get_npc(npc_id) then
			Printer:Log(LOG.ADD, CAT.NPC, "recruit npc %s through clone %s", npc_id, clone_id)			
			-- npc profile already exists, remap to the clone id
			if npcd.remap_npc(npc_id, clone_id) then
				npcd.set_recruited(clone_id, true)
			else
				-- cannot remap - there was a problem
				Printer:Log(LOG.ERROR, CAT.NPC, "cannot remap npc %s to new id %s", npc_id, clone_id)
			end
		else
			Printer:Log(LOG.WARN, CAT.NPC, "recruit through clone where only the clone %s exists", clone_id)
			npcd.set_recruited(clone_id, true)
		end
		npc_id = clone_id
	else
		-- npc recruited through vanilla squad joining dialog (can be 1 npc or more at the same time)
		npcd.set_recruited(npc_id, true)
	end
	local npc_info = npcd.get_npc_info(npc_id)
	if npc_info then
		npc_info.last_time_seen = game.get_game_time()
		npc_info.last_place_seen = dynamic_news_helper.GetPointDescription(db.actor)
		npcd.set_npc_info(npc_id, npc_info)
	end
end

function npcd_recruit(npc_id, clone_id)
	if not NPCD_BOOTED then return end
	recruit_npc(npc_id, clone_id)
end

--- NPC DEATH Callback
--- 
function squad_on_npc_death(squad,se_npc)
	Printer:Trace(LOG.RUN, CAT.NPC,"squad_on_npc_death")
	local npc_id = se_npc.id
	if npcd.get_npc(npc_id) then
		Printer:Debug(LOG.REMOVE, CAT.NPC,"dead npc %s name %s released", npc_id, se_npc:name())
		if npcd_squad.is_actor_squad(npc_id) then
			-- npc is part of the actor squad, unrecruit and remove from player deck
			unrecruit_npc(npc_id)
			unregister_feats(npc_id)
			register_npc_perks(npc_id, false)
			remove_npc_executions(npc_id, true)
			-- push for a squad and deck update
			SendScriptCallback("npcd_squad_update")
		end
		release_npc(npc_id)
	end
end

function npc_on_death(victim, who)
	Printer:Debug(LOG.RUN, CAT.NPC,"npc_on_death victim %s killed by %s", victim and victim:name() or "nil", who and who:name() or "nil")
	if not (victim and who) then
		return
	end
	if who and who:id() == db.actor:id() then
		Printer:Debug(LOG.INFO, CAT.NPC, "Enemy %s killed by actor", victim:name())
		return
	end
	if IsStalker(who) and npcd_squad.is_actor_squad(who:id()) then

		Printer:Debug(LOG.INFO, CAT.NPC, "Enemy %s killed by squad member %s", victim:name(), who:character_name())
		npcd_relations.increase_goodwill_kill(who)
	end
end


--------------- Player Deck
---

local player_deck = {
	Perk = {},
}

function is_perk_in_deck(npc_id, perk_id)
	if player_deck.Perk[perk_id] and player_deck.Perk[perk_id].npc_id == npc_id then
		return true
	else
		return false
	end
end

function unregister_deck()
	Printer:Debug(LOG.RUN, CAT.CONF,"unregistering actor deck")
	for perk_id, perk_info in pairs(player_deck.Perk) do
		local npc_id = perk_info.npc_id
		local perk = npcd.get_perk(perk_id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				unregister_feat(npc_id, feat)
			end
		end
	end
end

function register_deck()
	Printer:Debug(LOG.RUN, CAT.NPC,"registering actor deck")
	for perk_id, perk_info in pairs(player_deck.Perk) do
		local npc_id = perk_info.npc_id
		local perk = npcd.get_perk(perk_id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				register_feat(npc_id, feat)
			end
		end
	end
end

function build_deck()
	Printer:Debug(LOG.RUN, CAT.CONF,"updating actor deck")
	player_deck.Perk = {}
	local clist = npcd_squad.squad_get_clist()
	for i=1, #clist do
		local npc = npcdu.get_npc_obj(clist[i])
		if npc and npc:alive() then
			local npc_id = npc:id()
			local npc_deck = npcd.get_npc(npc_id)
			if npc_deck and npc_deck.Perk then
				for _, npc_perk in pairs(npc_deck.Perk) do
					if not player_deck.Perk[npc_perk.id] then
						Printer:Debug(LOG.INFO, CAT.CONF, "adding perk %s from npc %s", npc_perk.id, npc_id)
						player_deck.Perk[npc_perk.id] = { id = npc_perk.id, npc_id = npc_id, rank = npcdu.get_perk_rank(npc_id) }
					else
						local rank1 = npcdu.get_perk_rank(npc_id)
						local rank2 = npcdu.get_perk_rank(player_deck.Perk[npc_perk.id].npc_id)
						if rank1 > rank2 then
							Printer:Debug(LOG.INFO, CAT.CONF, "upgrading perk %s from npc %s (rank %s) to npc %s (rank %s)", npc_perk.id, player_deck.Perk[npc_perk.id].npc_id, rank2, npc_id, rank1)
							player_deck.Perk[npc_perk.id] = { id = npc_perk.id, npc_id = npc_id, rank = rank1, type = npc_perk.type }
						else
							Printer:Debug(LOG.INFO, CAT.CONF, "skipping duplicate perk %s from npc %s", npc_perk.id, npc_id)
							unregister_perk_feats(npc_id, npc_perk.id)
						end
						-- TODO compare ranks and keep the highest
					end
				end
			end
		end
	end
	Printer:LogTable("Actor Deck", player_deck)
end

local function get_actionable_abilities_in_deck()
	local action_list = {}
	for perk_id, perk_info in pairs(player_deck.Perk) do
		local perk = npcd.get_perk(perk_id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				if feat.type == FEAT_TYPE.ACTIVE and (feat.mode == FEAT_MODE.MANUAL or feat.mode == FEAT_MODE.MODAL) then
					local action = get_action(perk_info.npc_id, feat)
					table.insert(action_list, action)
				end
			end
		end
	end
	return action_list
end

local function remove_from_deck(npc_id)
	Printer:Debug(LOG.RUN, CAT.NPC,"remove_from_deck npc %s", npc_id)
	local perks_to_remove = {}
	for perk_id, perk_info in pairs(player_deck.Perk) do
		if perk_info.npc_id == npc_id then
			table.insert(perks_to_remove, perk_id)
		end
	end
	for i=1, #perks_to_remove do
		player_deck.Perk[perks_to_remove[i]] = nil
	end
	unregister_feats(npc_id)
end

--------------- SQUAD UPDATES

local current_clist
local function do_npcd_squad_update()
	Printer:Debug(LOG.RUN, CAT.NPC,"do_npcd_squad_update")
	local new_clist = npcd_squad.squad_get_clist()

	local added_ids, removed_ids = npcdu.compute_diff(new_clist, current_clist)

	-- update removed squad members
	for i=1, #removed_ids do
		local npc = npcdu.get_npc_obj(removed_ids[i])
		if npc and npcd.get_npc(npc:id()) then -- check if npc was released during squad_on_npc_death event
			unrecruit_npc(npc:id())
			unregister_feats(npc:id())
			register_npc_perks(npc:id(), false)
			remove_npc_executions(npc:id())
		end
	end

	-- update new squad members 
	-- TODO 2 this now is only to cover the case where an entire squad joins
	-- TODO 3 maybe we should not recruit and register non profiled npc automatically
	for i=1, #added_ids do
		local npc = npcdu.get_npc_obj(added_ids[i])
		if npc and npc:alive() then
			recruit_npc(npc:id())
			register_npc_perks(npc:id(), true)
		end
	end
	current_clist = new_clist
	npcd_squad.update_squad_info()
	build_deck()
	register_deck()
	npcd_actionbar.update_actionbar(get_actionable_abilities_in_deck())
	SendScriptCallback("npcd_post_squad_update")
	return true
end

local function npcd_squad_update()
	Printer:Debug(LOG.RUN, CAT.NPC,"npcd_squad_update")
	-- absorbs multiple callbacks in quick succession
	CreateTimeEvent("npcd_manager", "do_npcd_squad_update", 1, do_npcd_squad_update)
end

local function resume_squad_state()
	Printer:Debug(LOG.RUN, CAT.NPC,"resume_squad_state")
	npcd_squad.update_squad_info()
	current_clist = npcd_squad.squad_get_clist()
	if npcd_squad.squad_available() then
		Printer:Debug(LOG.RUN, CAT.NPC,"resuming squad state")
		-- register perks for all squad members
		for i=1, #current_clist do
			local npc = npcdu.get_npc_obj(current_clist[i])
			if npc and npc:alive() then
				register_npc_perks(npc:id(), true)
			end
		end
		-- build and register the deck
		build_deck()
		register_deck()
		npcd_actionbar.update_actionbar(get_actionable_abilities_in_deck())
		-- restart squad executions
		restart_squad_executions()
	else
		Printer:Debug(LOG.WARN, CAT.NPC,"no squad available")
	end
end

--------------- NPCD STATE MGMT

function save_state(m_data)
	Printer:Log(LOG.ADD, CAT.CONF,"NPCDeck State - Saving")
    if not m_data.npcd then
        m_data.npcd = {}
    end 
    -- save the state

	-- npcs decks
    m_data.npcd.npcs = npcd.get_deck()
	-- npcs stats
	m_data.npcd.stats = npcd.get_stats()
	-- npcs data for MCM
	m_data.npcd.data = npcd.get_data()

	

	Printer:LogTable("NPCDeck", m_data.npcd.npcs)
	Printer:LogTable("NPCStats", m_data.npcd.stats)
	Printer:LogTable("NPCs MCM Data", m_data.npcd.data)
end

function load_state(m_data)
	if not Printer then
		get_printer()
	end
	Printer:Log(LOG.ADD, CAT.CONF,"NPCDeck State - Loading")
	if m_data.npcd and m_data.npcd.npcs then
        -- cache the state
        npcd.set_deck(m_data.npcd.npcs)
		Printer:LogTable("NPCDeck", npcd.get_deck())
	end
	if m_data.npcd and m_data.npcd.stats then
		npcd.set_stats(m_data.npcd.stats)
		Printer:LogTable("NPCStats", npcd.get_stats())
	end
	if m_data.npcd and m_data.npcd.data then
		npcd.set_data(m_data.npcd.data)
		Printer:LogTable("NPCs MCM Data", npcd.get_data())
	end
	SendScriptCallback("npcd_on_loaded_state")
end

-- NPCD LIFECYCLE

local tg_update = 0
local tg_update_step = 500 --[ms]
function actor_on_update()

	local tg = time_global()
	if tg < tg_update then
		return
	end
	tg_update = tg + tg_update_step

	npcd_squad.update_squad_info()

	-- printlog_table("Stalkers", stalkers)
end

function actor_on_net_destroy()
	teardown_npcd_execution()
end

--- MODULE REGISTRATION and MGMT

function register_module(deck)
	printf("-[NPCD][MAIN] Manager register module %s", deck.module)
	npcd.add_module_perks(deck.module, deck.perks)
end

function update_module(deck)
	Printer:Log(LOG.RUN, CAT.CONF,"Manager update module %s", deck.module)
	npcd.update_module_perks(deck.module)
	SendScriptCallback("npcd_squad_update")
end

---- 

function game_object_on_net_spawn(obj)
	if (IsStalker(obj) and obj:alive() and obj:id() ~= 0 and obj:character_community() ~= "zombied") then
		if npcd.add_npc(obj:id()) then
			printf("-[NPCD][MAIN] new npc added id:%s, name:%s, character_name:%s, faction:%s", obj:id(), obj:name(), obj:character_name(), obj:character_community())
		end
	end
end

-- function game_object_on_net_spawn(obj)
-- 	if (IsStalker(obj) and obj:alive()) then	
-- 		printf("-[NPCD][MAIN] NPC spawned id:%s, name:%s, character_name:%s, community:%s, rank:%s, reputation:%s, goodwill:%s, general_goodwill:%s", obj:id(), obj:name(), obj:character_name(), obj:community(), obj:rank(), obj:reputation(), obj:goodwill(), obj:general_goodwill())
-- 	end
-- end


function actor_on_first_update()
	Printer:Log(LOG.START, CAT.EXEC,"Manager actor_on_first_update")
end

function on_option_change()
	npcd_actionbar.update_actionbar(get_actionable_abilities_in_deck())
end

---- BOOT

NPCD_BOOTED = false

function check_can_boot()
	local plist = npcd.get_perks_id_list()
	NPCD_BOOTED = (#plist > 0)
	return NPCD_BOOTED
end

function game_play_start()
	if(device().precache_frame > 1) then --detects if game is not past the press any key prompt
		return
	end
	--setup your thing here
	UnregisterScriptCallback("actor_on_update", game_play_start)
	Printer:Log(LOG.START, CAT.EXEC,"Manager game_play_start")
	check_can_boot()
	if not NPCD_BOOTED then
		UnregisterScriptCallback("squad_on_npc_death", squad_on_npc_death)
		UnregisterScriptCallback("npcd_squad_update", npcd_squad_update)
		UnregisterScriptCallback("on_option_change", on_option_change)
		UnregisterScriptCallback("load_state", load_state)
		UnregisterScriptCallback("save_state", save_state)
		UnregisterScriptCallback("game_object_on_net_spawn", game_object_on_net_spawn)
		UnregisterScriptCallback("actor_on_first_update", actor_on_first_update)
		return
	end
	-- NPCD BOOTING
	Printer:Log(LOG.START, CAT.EXEC, "NPCD BOOTED")
	npcd.build_perk_index()
	start_npcd_execution()
	resume_squad_state()
	SendScriptCallback("npcd_started")
	RegisterScriptCallback("actor_on_update", actor_on_update)
end

function actor_on_first_update()
    printf("$[NPCD][Main] npcd_manager actor_on_first_update")
end

function on_game_start()
	printf("$[NPCD][MAIN] npcd_manager on_game_start")
	RegisterScriptCallback("actor_on_update", game_play_start)
	RegisterScriptCallback("squad_on_npc_death", squad_on_npc_death)
	RegisterScriptCallback("npc_on_death_callback", npc_on_death)
	RegisterScriptCallback("npcd_squad_update", npcd_squad_update)
	RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("actor_on_net_destroy",actor_on_net_destroy)
	RegisterScriptCallback("game_object_on_net_spawn", game_object_on_net_spawn)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	get_printer()
end

-- npcd_manager.debug_set_goodwill()
-- npcd_manager.debug_set_community_goodwill()

function debug_set_goodwill(npc_id, goodwill)
	local npc = npcdu.get_npc_obj(npc_id)
	if npc then
		npc:set_goodwill(goodwill, db.actor)
		printf("- npc relation %s", npc:relation(db.actor))
	end
end

function debug_set_community_goodwill(npc_id, goodwill)
	local npc = npcdu.get_npc_obj(npc_id)
	if npc then
		npc:set_community_goodwill(character_community(db.actor), goodwill)
		printf("- npc relation %s", npc:relation(db.actor))
	end
end