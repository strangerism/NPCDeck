local npcdu = npcd_utils
local npcd = npcd

function get_printer()
	if not Printer then
		Printer = npcd_logging.get_printer("npcd_manager")
	end 
	LOG = Printer:GetLogTypes()
	CAT = Printer:GetLogCategories()
end
if AddScriptCallback then
	RegisterScriptCallback("npcd_on_log_update", get_printer)
end

local FEAT_TYPE = npcd.FEAT_TYPE
local FEAT_MODE = npcd.FEAT_MODE
local ABILITY_STATE = npcd.ABILITY_STATE

--------------- Utilities

local function execute(npc_id, functor)
	if not functor then return false end
	local ex_functor = {}
	table.insert(ex_functor, functor[1])
	table.insert(ex_functor, functor[2])
	table.insert(ex_functor, npc_id)
	Printer:TraceTable("npc executing", ex_functor)
	local result = execute_func(unpack(ex_functor))
	Printer:Trace(LOG.INFO, CAT.EXEC,"with result: %s", result)
	return result
end

local function npc_can_register(npc_id, feat)
	if feat.register_functor then
		return execute(npc_id, feat.register_functor)
	else
		return true
	end
end

--------------- NPCs
---

function release_npc(npc_id)
	remove_npc_executions(npc_id)
	npcd_actionbar.remove_npc_abilities_from_actionbar(npc_id)
	npcd.remove_npc(npc_id)
end

function register_abilities(npc_id)
	Printer:Debug(LOG.RUN, CAT.NPC,"npc %s register abilities", npc_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	Printer:LogTable("Register Abilities - NPC perks:", npc_deck)
	-- clear npc current abilities
	npcd.clear_abilities(npc_id)

	for _, npc_perk in pairs(npc_deck.Perk) do
		Printer:Debug(LOG.INFO, CAT.NPC,"npc %s registers abilities for perk %s", npc_id, npc_perk.id)
		local perk = npcd.get_perk(npc_perk.id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				if feat.type == FEAT_TYPE.ACTIVE then
					if npc_can_register(npc_id, feat) then
						Printer:Debug(LOG.ADD, CAT.NPC,"npc %s adds ability %s", npc_id, feat.id)
						npcd.add_ability(npc_id, feat)
						bind_ability(npc_id, feat)
					end
				end
			end
		end
	end
	Printer:LogTable("Registered Abilities", npc_deck.Ability)
	return true
end

function unregister_abilities(npc_id)
    Printer:Debug(LOG.RUN, CAT.NPC,"npc %s unregister abilities", npc_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	for _, npc_perk in pairs(npc_deck.Perk) do
		Printer:Debug(LOG.INFO, CAT.NPC,"npc %s unregister abilities for perk %s", npc_id, npc_perk.id)
		local perk = npcd.get_perk(npc_perk.id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				if feat.type == FEAT_TYPE.ACTIVE then
					Printer:Debug(LOG.ADD, CAT.NPC,"npc %s removes ability %s", npc_id, feat.id)
					npcd.remove_ability(npc_id, feat.id)
					unbind_ability(npc_id, feat)
				end
			end
		end
	end
	return true
end

function dialog_create_npc_profile(actor, npc)
	Printer:Debug(LOG.RUN, CAT.NPC,"create npc profile")
	local npc = dialogs.who_is_npc(actor, npc)
	if npc and npc:alive() then
		if npcd.add_npc(npc:id()) then
			Printer:Debug(LOG.ADD, CAT.NPC,"create npc %s profile", npc:id())
			-- It's a new NPC lets roll the perks
			npcd.create_profile(npc:id())
		end
	end
end

function dialog_get_npc_profile(actor, npc)
	Printer:Debug(LOG.RUN, CAT.NPC,"get npc profile")
	local npc = dialogs.who_is_npc(actor, npc)
	if npc and npc:alive() then
		local npc_id = npc:id()
		Printer:Log(LOG.RUN, CAT.CONF,"npc %s get profile", npc_id)
		local id = math.random(5)
		local profile_dialog = game.translate_string("st_npcd_npc_dialogs_background_response" .. id, true) .. "\\n \\n" 
		local npc_perks = npcd.get_npc_perks(npc_id)
		if npc_perks then
			for _, npc_perk in pairs(npc_perks) do
				local perk = npcd.get_perk(npc_perk.id, npc_id)
				if perk.dialog then
					profile_dialog = profile_dialog .. game.translate_string(perk.dialog, true)
				end
				local st_perk_name = game.translate_string(perk.name, true) or ""
				local st_perk_module = game.translate_string("ui_mcm_npcd_module_menu_" .. perk.module, true) or perk.module or ""
				profile_dialog = profile_dialog .. "\\n" .. string.format(game.translate_string("st_npcd_npc_dialogs_perk_desc"), st_perk_name, st_perk_module)

				profile_dialog = profile_dialog .. "\\n"
			end
			return profile_dialog
		end
	end
	return game.translate_string("st_npcd_npc_dialogs_npc_has_no_perks", true)
end

function recruit_npc(npc_id, clone_id)
	Printer:Debug(LOG.RUN, CAT.NPC, "recruiting npc %s", npc_id)
	if clone_id then
		if npcd.get_npc(npc_id) then
			Printer:Log(LOG.ADD, CAT.CONF, "recruiting npc %s through clone %s", npc_id, clone_id)			
			-- npc profile already exists, remap to the clone id
			if npcd.remap_npc(npc_id, clone_id) then
				npcd.set_recruited(clone_id, true)	
			else
				-- cannot remap - there was a problem
				Printer:Log(LOG.ERROR, CAT.NPC, "cannot remap npc %s to new id %s", npc_id, clone_id)
			end
			
			
		else
			Printer:Log(LOG.WARN, CAT.NPC, "recruiting through clone where only the clone %s exists", clone_id)
			if npcd.add_npc(clone_id) then
				-- It's a new NPC lets roll the perks
				Printer:Debug(LOG.ADD, CAT.NPC,"create npc %s profile", clone_id)
				npcd.create_profile(clone_id)
			end
			npcd.set_recruited(clone_id, true)
		end
	else
		if npcd.add_npc(npc_id) then
			Printer:Log(LOG.ADD, CAT.NPC, "recruiting npc %s ", npc_id)
			Printer:Debug(LOG.ADD, CAT.NPC,"create npc %s profile", npc_id)
			-- It's a new NPC lets roll the perks
			npcd.create_profile(npc_id)
		end
		npcd.set_recruited(npc_id, true)
	end
end
--------------- Execution MGMT
---

Tasks = {}

function add_cooldown_execution(npc_id, feat_id)
	local ability_cooldown_id = get_ability_cooldown_id(npc_id, feat_id)
	remove_execution(ability_cooldown_id)
	Printer:Debug(LOG.ADD, CAT.EXEC,"npc %s creates new ability cooldown manager %s", npc_id, ability_cooldown_id)
	CreateTimeEvent("npcd_manager", ability_cooldown_id, 0, manage_ability_cooldown, ability_cooldown_id, npc_id, feat_id)
	Tasks[ability_cooldown_id] = { npc_id = npc_id, feat_id = feat_id}
end

function add_poll_execution(npc_id, feat)
	local polling_input = create_polling_input(npc_id, feat)
	Printer:Debug(LOG.ADD, CAT.EXEC,"npc %s creates new ability poll manager %s", npc_id, polling_input.id)
	CreateTimeEvent("npcd_manager", polling_input.id, polling_input.interval, poll, polling_input)
	Tasks[polling_input.id] = { npc_id = npc_id, feat_id = feat.id}
end

function remove_execution(id)
	Printer:Debug(LOG.STOP, CAT.EXEC,"remove execution %s", id)
	RemoveTimeEvent("npcd_manager", id)
	Tasks[id] = nil
end

function reset_execution(id, delay)
	Printer:Debug(LOG.ADD, CAT.EXEC,"reset execution %s", id)
	ResetTimeEvent("npcd_manager", id, delay)
end

function remove_npc_executions(npc_id)
	Printer:Debug(LOG.RUN, CAT.EXEC,"remove npc %s executions",npc_id)
	for id, execution_info in pairs(Tasks) do
		if execution_info.npc_id == npc_id then
			remove_execution(id)
		end
	end
end

function teardown_npcd_execution()
	Printer:Debug(LOG.STOP, CAT.EXEC,"teardown_npcd_execution")
	for key, value in pairs(Tasks) do
		RemoveTimeEvent("npcd_manager", key)
	end
end

--------------- Abilities MGMT

-- called by NPCD Manager custom time events
function manage_ability_cooldown(ability_cooldown_id, npc_id, feat_id)
	Printer:Trace(LOG.RUN, CAT.FEAT,"npc %s manage ability cooldown %s", npc_id, feat_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then
		Printer:Log(LOG.ERROR, CAT.FEAT,"npc %s deck not found. stopping manage ability cooldown %s", npc_id, ability_cooldown_id)
		return true
	end  -- npc died?

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then
		Printer:Log(LOG.ERROR, CAT.FEAT,"npc %s ability %s not found. stopping manage ability cooldown %s", npc_id, feat_id, ability_cooldown_id)
		return true
	end -- ability unregistered?

    -- setup cooldown transition
	if npc_ability.state == ABILITY_STATE.READY then
		Printer:Debug(LOG.START, CAT.FEAT,"npc %s ability %s init cooldown %s", npc_id, feat_id, npc_ability.cooldown)
		npc_ability.state = ABILITY_STATE.COOLDOWN
		npc_ability.timer = npc_ability.cooldown
	end

    -- ability cooldown ended, kill time event
	if npc_ability.timer <= -5 then
		npc_ability.timer = -999
		npc_ability.state = ABILITY_STATE.READY
		Printer:Debug(LOG.STOP, CAT.FEAT,"cooldown completed. ending time event %s", ability_cooldown_id)
		return true
	elseif npc_ability.timer == 0 then -- ability cooldown ended is, going to reading up
		npc_ability.state = ABILITY_STATE.READING
	end

    -- managing cooldown timer
	local timer = npc_ability.timer
	local cooldown = npc_ability.cooldown
	local state = npc_ability.state
	Printer:Debug(LOG.RUN, CAT.FEAT,"npc %s ability %s state %s timer %s/%s", npc_id, feat_id, state, timer, cooldown)
	npc_ability.timer = npc_ability.timer - 1

    -- updating, necessary ??
    npcd.set_ability(npc_id, npc_ability)

    -- loop cooldown management event
	reset_execution(ability_cooldown_id, 1)
	return false
end

function get_ability_cooldown_id(npc_id, feat_id)
	return "ability_cooldown_" .. tostring(npc_id) .. "_" .. feat_id
end

local function activate_ability(npc_id, feat_id)
	Printer:Debug(LOG.RUN, CAT.ACTIV,"npc %s tries to activate ability %s", npc_id, feat_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end  -- npc died?

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then return false end -- ability unregistered?

	if (npc_ability.state == ABILITY_STATE.READING) then
		Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s activates ability %s on READING", npc_id, feat_id)
		npc_ability.state = ABILITY_STATE.READY
	else
		Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s activates ability %s", npc_id, feat_id)
	end

	add_cooldown_execution(npc_id, feat_id)
	return true
end

function poll_ability(npc_id, feat_id)
	Printer:Trace(LOG.RUN, CAT.ACTIV,"npc %s polling ability cooldown %s", npc_id, feat_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end  -- npc died?

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then return false end -- ability unregistered?

	Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s cheking ability cooldown %s", npc_id, feat_id)
	if (npc_ability.state == ABILITY_STATE.COOLDOWN) then 
		Printer:Debug(LOG.WARN, CAT.ACTIV,"npc %s cannot activate ability %s that is on cooldown", npc_id, feat_id)
		return false
	else
		return true
	end
end

-- TODO add all cooldown timers to a table by cooldown id
-- called by NPCD Manager custom time events
function poll(polling_input)
	Printer:Debug(LOG.RUN, CAT.ACTIV,"npc %s polls ability %s", polling_input.npc_id, polling_input.feat_id)
	
	-- first poll ability is not on cooldown
	if poll_ability(polling_input.npc_id, polling_input.feat_id) then
		-- execute ability
		local activated = execute(polling_input.npc_id, polling_input.activation_functor)
		-- activate ability cooldown
		if activated then
			activate_ability(polling_input.npc_id, polling_input.feat_id)
		end
	end

    -- loop polling event
	reset_execution(polling_input.id, polling_input.interval)
	return false
end

-- called by NPCD Input Manager
function activate(activation_input)
	Printer:Debug(LOG.RUN, CAT.ACTIV,"input manager activates npc %s ability %s",activation_input.npc_id, activation_input.feat_id)
	if poll_ability(activation_input.npc_id, activation_input.feat_id) then
		-- execute ability
		local activated = execute(activation_input.npc_id, activation_input.activation_functor)
		-- activate ability cooldown
		if activated then
			activate_ability(activation_input.npc_id, activation_input.feat_id)
		end
	end
end

function get_ability_polling_id(npc_id, feat_id)
	return "ability_polling_" .. tostring(npc_id) .. "_" .. feat_id
end

function create_polling_input(npc_id, feat)
	local polling_input = {}
	polling_input["id"] = get_ability_polling_id(npc_id, feat.id)
	polling_input["npc_id"] = npc_id
	polling_input["feat_id"] = feat.id
	polling_input["interval"] = feat.activation_polling_interval or 1
	polling_input["activation_functor"] = feat.activation_functor
	return polling_input
end

function bind_ability(npc_id, feat)
	Printer:Debug(LOG.ADD,CAT.NPC, "npc %s bind ability %s", npc_id, feat.id)
	if feat.mode == FEAT_MODE.MANUAL then
		npcd_actionbar.add_action_slot(npc_id, feat.id)
	end

	if feat.mode == FEAT_MODE.AUTO then
		add_poll_execution(npc_id, feat)
	end

	if feat.mode == FEAT_MODE.MODAL then
	end

end

function unbind_ability(npc_id, feat)
	Printer:Debug(LOG.REMOVE,CAT.NPC, "npc %s unbind ability %s", npc_id,  feat.id)
	if feat.mode == FEAT_MODE.MANUAL then
		npcd_actionbar.remove_action_slot(npc_id, feat.id)
	end

	if feat.mode == FEAT_MODE.AUTO then
		local ability_polling_id = get_ability_polling_id(npc_id, feat.id)
		remove_execution(ability_polling_id)
	end

	if feat.mode == FEAT_MODE.MODAL then
	end

end

--------------- ACTIONBAR UPDATES

function update_actionbar()
	Printer:Debug(LOG.INFO, CAT.UI_ACTION, "Manager update actionbar")
	npcd_actionbar.reset_actionbar()
end

--------------- SQUAD UPDATES (abilities registration mainly)
-- TODO this registration part should be done differently
-- if we remove create_profile from squad updates then we can do all registration in start_npcd_squad_update

function npcd_squad_ability_registration()
	Printer:Debug(LOG.RUN, CAT.NPC,"npcd_squad_ability_registration")
	local clist = squad_get_clist()
	-- re-configure all squad abilities
	for i=1, #clist do
		local npc = npcdu.get_npc_obj(clist[i])
		if npc and npc:alive() then
			local npc_id = npc:id()
			register_abilities(npc_id)
		end
	end

	update_actionbar()
	return true
end

local current_clist
local function do_npcd_squad_update()
	Printer:Debug(LOG.RUN, CAT.NPC,"do_npcd_squad_update")
	local new_clist = squad_get_clist()

	local added_ids, removed_ids = npcdu.compute_diff(new_clist, current_clist)

	-- update removed squad members
	for i=1, #removed_ids do
		local npc = npcdu.get_npc_obj(removed_ids[i])
		if npc and npcd.get_npc(npc:id()) then -- check if npc was released during squad_on_npc_death event
			unregister_abilities(npc:id())
			npcd.set_recruited(npc:id(), false)
		end
	end

	-- update new squad members - TODO this can be removed if we create the npc profile on npc dialog window
	for i=1, #added_ids do
		local npc = npcdu.get_npc_obj(added_ids[i])
		if npc and npc:alive() then
			recruit_npc(npc:id())
		end
	end
	current_clist = new_clist
	SendScriptCallback("npcd_post_squad_update")
	CreateTimeEvent("npcd_manager", "npcd_squad_ability_registration", 1, npcd_squad_ability_registration)
	return true
end

local function npcd_squad_update()
	Printer:Debug(LOG.RUN, CAT.NPC,"npcd_squad_update")
	CreateTimeEvent("npcd_manager", "do_npcd_squad_update", 1, do_npcd_squad_update)
end

--------------- NPC DEATH
-- TODO remove_npc or remove_npc_abilities_from_actionbar or npcd_squad_update
function squad_on_npc_death(squad,se_npc)
	Printer:Trace(LOG.RUN, CAT.NPC,"squad_on_npc_death")
	local npc = npcdu.get_npc_obj(se_npc.id)
	if not npc then return end
	local npc_id = npc:id()
	if npcd.get_npc(npc_id) then
		Printer:Debug(LOG.WARN, CAT.NPC,"squad_on_npc_death npc %s name %s", npc_id, npc:name())
		release_npc(npc_id)
		Printer:Debug(LOG.REMOVE, CAT.NPC,"dead npc %s released", npc_id)		
		for id,actor_squad in pairs(axr_companions.companion_squads) do
			if squad.id == actor_squad.id then
				SendScriptCallback("npcd_squad_update")
			end
		end
	end
end

--------------- SQUAD STATE


local Squad_Info = {
	combat = false,
	size = 0,
	non_task_companions = 0,
	clist = {}
}

function squad_get_clist()
	return Squad_Info.clist
end

function squad_get_combat()
	return Squad_Info.combat
end

function squad_get_size()
	return Squad_Info.size
end

function squad_get_nontask_size()
	return Squad_Info.non_task_companions
end

function squad_available()
	return Squad_Info.available
end

local function reset_squad_info()
	Squad_Info = {
		combat = false,
		size = 0,
		non_task_companions = 0,
		clist = {},
		available = false
	}
end

function is_actor_squad(npc_id)
	local clist = squad_get_clist()
	for i = 1, #clist do
		if clist[i] == npc_id then return true end
	end
	return false
end

local function update_axr_companions_info()
    local clist = axr_companions.list_actor_squad_by_id()
	Squad_Info.size = npcdu.tablelength(clist)
    if not (Squad_Info.size > 0) then
        Printer:Trace(LOG.WARN, CAT.NPC, "no squad available at this time")
		reset_squad_info()
	else
		Squad_Info.non_task_companions = axr_companions.get_companion_count()
		Squad_Info.clist = clist
		Squad_Info.available = true
		Printer:Trace(LOG.INFO, CAT.NPC, "squad count %s - non tasks companions %s", Squad_Info.size, Squad_Info.non_task_companions)
	end
end

function update_squad_info()
	local squad_is_peaceful = true
	update_axr_companions_info()
	local clist = Squad_Info.clist
	for i=1, #clist do
		local npc = npcdu.get_npc_obj(clist[i])
		if npc then
			local is_peaceful = false
			-- check if is in fight
			if npc:alive() then
				is_peaceful = (not npc:best_enemy()) and npc:dont_has_info("npcx_beh_ignore_combat") and true or false
			end
			-- Printer:Trace(LOG.INFO, CAT.NPC,"companion[%s] is_peaceful %s - dist: %s",clist[i], is_peaceful, distance_between(db.actor,npc))
			-- check if is too far away
			squad_is_peaceful = squad_is_peaceful and is_peaceful
			Printer:Trace(LOG.INFO, CAT.NPC,"current calculation for squad is_peaceful %s", squad_is_peaceful)					
		end	
	end	
	if not squad_is_peaceful then
		Printer:Trace(LOG.INFO, CAT.NPC,"squad is under attack or attacking")
	end
	Printer:Trace(LOG.INFO, CAT.NPC,"squad is resolved peaceful %s", squad_is_peaceful)
	if not Squad_Info.combat and not squad_is_peaceful then
		Printer:Debug(LOG.START, CAT.EXEC,"npcd_squad_combat_started")
		Squad_Info.combat = true
		SendScriptCallback("npcd_squad_combat_started")
		return
	end

	if Squad_Info.combat and squad_is_peaceful then
		Printer:Debug(LOG.STOP, CAT.EXEC,"npcd_squad_combat_ended")
		Squad_Info.combat = false
		SendScriptCallback("npcd_squad_combat_ended")
		return
	end
end

--------------- NPCD STATE MGMT

function save_state(m_data)
	Printer:Log(LOG.ADD, CAT.CONF,"NPCDeck Save State")
    if not m_data.npcd then
        m_data.npcd = {}
    end 
    -- save the state
    m_data.npcd.npcs = npcd.get_deck()
	Printer:LogTable("NPCDeck", m_data.npcd.npcs)
end

function load_state(m_data)
	if not Printer then
		get_printer()
	end
	Printer:Log(LOG.ADD, CAT.CONF,"NPCDeck Load State")
	if m_data.npcd and m_data.npcd.npcs then
        -- cache the state
        npcd.set_deck(m_data.npcd.npcs)
		Printer:LogTable("NPCDeck", npcd.get_deck())
	end
	SendScriptCallback("npcd_on_loaded_state")
end

-- NPCD LIFECYCLE

function npcs_sweaper()
	Printer:Log(LOG.RUN, CAT.CONF,"npcs sweaper")
	local npcs_list = npcd.get_npcs_id_list()
	for i = 1, #npcs_list do
		local npc_id = npcs_list[i]
		local se_npc = alife_object(npc_id)
		if not se_npc then
			Printer:Debug(LOG.REMOVE, CAT.CONF,"removing stale npc %s data", npc_id)
			npcd.remove_npc(npc_id)
		end		
	end
	ResetTimeEvent("npcd_manager", "npcs_sweaper", 60)
end

local tg_update = 0
local tg_update_step = 500 --[ms]
function actor_on_update()

	local tg = time_global()
	if tg < tg_update then
		return
	end
	tg_update = tg + tg_update_step

	update_squad_info()

	-- printlog_table("Stalkers", stalkers)
end

function actor_on_net_destroy()
	teardown_npcd_execution()
	RemoveTimeEvent("npcd_manager", "npcs_sweaper")
end

--- MODULE REGISTRATION

function register_module(deck)
	printf("-[NPCD][MAIN] Manager register module %s", deck.module)
	-- printf("-[NPCD][Main] Manager register_module %s", deck.module)
	npcd.add_module_perks(deck.module, deck.perks)
end

function actor_on_first_update()
	Printer:Log(LOG.START, CAT.EXEC,"Manager actor_on_first_update")
end

--- NPCD SETTINGS

settings = {
	["actionbar"] = {
		["max_slots"] = 8,
		["show_empty"] = true,
	}
}

function on_option_change()
	settings.actionbar.max_slots = npcd_mcm.get_setting("actionbar", "main/max_slots")
	settings.actionbar.show_empty = npcd_mcm.get_setting("actionbar", "main/show_empty")
	update_actionbar()
end

---- BOOT

function game_play_start()
    if(device().precache_frame > 1) then --detects if game is not past the press any key prompt
        return
    end
  --setup your thing here
   UnregisterScriptCallback("actor_on_update", game_play_start)
   Printer:Log(LOG.START, CAT.EXEC,"Manager game_play_start")
   update_actionbar()
   CreateTimeEvent("npcd_manager", "npcs_sweaper", 60, npcs_sweaper)
end

function on_game_start()
	printf("/[NPCD][MAIN] Manager on_game_start")
	-- RegisterScriptCallback("npcd_on_loaded_state", npcd_on_loaded_state)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	RegisterScriptCallback("actor_on_update", actor_on_update)
	RegisterScriptCallback("actor_on_update", game_play_start)
	RegisterScriptCallback("squad_on_npc_death", squad_on_npc_death)
	RegisterScriptCallback("npcd_squad_update", npcd_squad_update)
	RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("actor_on_net_destroy",actor_on_net_destroy)
end