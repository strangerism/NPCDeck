local npcdu = npcd_utils

function get_printer()
	if not Printer then
		Printer = npcd_logging.get_printer("npcd_manager")
	end 
	LOG = Printer:GetLogTypes()
	CAT = Printer:GetLogCategories()
end
if AddScriptCallback then
	RegisterScriptCallback("npcd_on_log_update", get_printer)
end

local FEAT_TYPE = npcd.FEAT_TYPE
local FEAT_MODE = npcd.FEAT_MODE
local ABILITY_STATE = npcd.ABILITY_STATE

--------------- Utilities

local function execute_register(npc_id, register, functor)
	if not functor then return false end
	local ex_functor = npcdu.copy(functor)
	table.insert(ex_functor, npc_id)
	table.insert(ex_functor, register)
	Printer:TraceTable("npc executing", ex_functor)
	local result = execute_func(unpack(ex_functor))
	Printer:Trace(LOG.INFO, CAT.EXEC,"with result: %s", result)
	return result
end

local function execute_activate(npc_id, feat_id, functor)
	if not functor then return false end
	local ex_functor = npcdu.copy(functor)
	table.insert(ex_functor, npcd.get_npc_feats(npc_id, feat_id))
	Printer:TraceTable("npc executing", ex_functor)
	local result = execute_func(unpack(ex_functor))
	Printer:Trace(LOG.INFO, CAT.EXEC,"with result: %s", result)
	return result
end

local function run_register_feat(npc_id, feat, register)
	if feat.register_functor then
		return execute_register(npc_id, register, feat.register_functor)
	else
		return true
	end
end

function run_register_perk(npc_id, perk, register)
	if perk.register_functor then
		return execute_register(npc_id, register, perk.register_functor)
	else
		return true
	end
end

local function get_ability_polling_id(npc_id, feat_id)
	return "ability_polling_" .. tostring(npc_id) .. "_" .. feat_id
end

local function get_ability_cooldown_id(npc_id, feat_id)
	return "ability_cooldown_" .. tostring(npc_id) .. "_" .. feat_id
end

local function create_polling_input(npc_id, feat)
	local polling_input = {}
	polling_input["id"] = get_ability_polling_id(npc_id, feat.id)
	polling_input["npc_id"] = npc_id
	polling_input["feat_id"] = feat.id
	polling_input["interval"] = feat.activation_polling_interval or 1
	polling_input["activation_functor"] = feat.activation_functor
	return polling_input
end

--------------- Execution MGMT
---

Tasks = {}
EXECUTION_TYPE = { cooldown = "cooldown", polling = "polling"}
local function remove_execution(id)
	if not Tasks[id] then return end
	Printer:Debug(LOG.STOP, CAT.EXEC,"removed execution %s", id)
	RemoveTimeEvent("npcd_manager", id)
	Tasks[id] = nil
end

local function add_cooldown_execution(npc_id, feat_id)
	local ability_cooldown_id = get_ability_cooldown_id(npc_id, feat_id)
	remove_execution(ability_cooldown_id)
	Printer:Debug(LOG.ADD, CAT.EXEC,"npc %s creates new ability cooldown manager %s", npc_id, ability_cooldown_id)
	CreateTimeEvent("npcd_manager", ability_cooldown_id, 0, manage_ability_cooldown, ability_cooldown_id, npc_id, feat_id)
	Tasks[ability_cooldown_id] = { npc_id = npc_id, feat_id = feat_id, type = EXECUTION_TYPE.cooldown}
end

local function add_poll_execution(npc_id, feat)
	local polling_input = create_polling_input(npc_id, feat)
	Printer:Debug(LOG.ADD, CAT.EXEC,"npc %s creates new ability poll manager %s", npc_id, polling_input.id)
	CreateTimeEvent("npcd_manager", polling_input.id, polling_input.interval, poll, polling_input)
	Tasks[polling_input.id] = { npc_id = npc_id, feat_id = feat.id, type = EXECUTION_TYPE.polling}
end

local function reset_execution(id, delay)
	Printer:Trace(LOG.INFO, CAT.EXEC,"resetting execution %s", id)
	ResetTimeEvent("npcd_manager", id, delay)
end

local function remove_npc_executions(npc_id, force)
	Printer:Debug(LOG.RUN, CAT.EXEC,"removing npc %s executions",npc_id)
	for id, execution_info in pairs(Tasks) do
		if execution_info.npc_id == npc_id and (execution_info.type == EXECUTION_TYPE.polling or force) then
			remove_execution(id)
		end
	end
end

function remove_npc_perk_executions(npc_id, perk_id)
	Printer:Debug(LOG.RUN, CAT.EXEC,"removing npc %s perk %s executions",npc_id, perk_id)
	local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?
	local perk = npcd.get_perk(perk_id)
	if not perk or not perk.feats then return false end -- perk not found?
	for _, feat in pairs(perk.feats) do
		local ability_polling_id = get_ability_polling_id(npc_id, feat.id)
		remove_execution(ability_polling_id)
	end
	return true
end

local function resume_npc_ability_execution(npc_id, feat)
	Printer:Debug(LOG.RUN, CAT.EXEC,"resuming npc %s ability %s execution", npc_id, feat.id)
	if feat.type == FEAT_TYPE.ACTIVE then
		if npcd.ability_registered(npc_id, feat.id) then
			Printer:Debug(LOG.INFO, CAT.EXEC,"npc %s restarts execution for ability %s", npc_id, feat.id)
			local npc_ability = npcd.get_ability(npc_id, feat.id)
			if feat.mode == FEAT_MODE.MANUAL and (npc_ability.state == ABILITY_STATE.COOLDOWN or npc_ability.state == ABILITY_STATE.READING) then
				add_cooldown_execution(npc_id, feat.id)
			end
			if feat.mode == FEAT_MODE.AUTO then
				if npc_ability.state ~= ABILITY_STATE.READY then
					add_cooldown_execution(npc_id, feat.id) -- resume current cooldown if not in READY
				end
				add_poll_execution(npc_id, feat)
			end
		end
	end
end

function restart_npc_execution(npc_id)
	Printer:Debug(LOG.RUN, CAT.EXEC,"npc %s restarting abilities execution", npc_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?
	if not npcd.has_abilities(npc_id) then return false end -- npc has no abilities
	Printer:LogTable("Restart Abilities - NPC perks:", npc_deck)
	for _, npc_perk in pairs(npc_deck.Perk) do
		Printer:Debug(LOG.INFO, CAT.EXEC,"npc %s restarts abilities for perk %s", npc_id, npc_perk.id)
		local perk = npcd.get_perk(npc_perk.id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				resume_npc_ability_execution(npc_id, feat)
			end
		end
	end
	Printer:LogTable("Restarted Abilities", npc_deck.Ability)
	return true
end

local function restart_squad_executions()
	local clist = npcd_squad.squad_get_clist()
	for i = 1, #clist do
		restart_npc_execution(clist[i])
	end
end

local function start_npcd_execution()
	Printer:Debug(LOG.RUN, CAT.EXEC,"starting npcd execution")
	-- start the npcd sim tasks
	CreateTimeEvent("npcd_manager", "npcs_sweaper", 3, npcs_sweaper)
	CreateTimeEvent("npcd_manager", "npcs_profiler", 5, npcs_profiler)
	CreateTimeEvent("npcd_manager", "npcs_updater", 10, npcs_updater)
end

local function teardown_npcd_execution()
	Printer:Debug(LOG.STOP, CAT.EXEC,"teardown_npcd_execution")

	-- stop current npc Tasks execution
	for key, value in pairs(Tasks) do
		RemoveTimeEvent("npcd_manager", key)
	end

	-- stopping the npcd sim tasks
	RemoveTimeEvent("npcd_manager", "npcs_sweaper")
	RemoveTimeEvent("npcd_manager", "npcs_profiler")
	RemoveTimeEvent("npcd_manager", "npcs_updater")
end

function npcs_sweaper()
	Printer:Log(LOG.RUN, CAT.CONF,"running npcs sweaper")
	local npcs_list = npcd.get_npcs_id_list()
	for i = 1, #npcs_list do
		local npc_id = npcs_list[i]
		local se_npc = alife_object(npc_id)
		-- REMOVE DEAD
		if not se_npc then
			Printer:Debug(LOG.REMOVE, CAT.CONF,"remove stale npc %s data", npc_id)
			local npc_deck = npcd.get_npc(npc_id)
			if npc_deck.show_profile then
				npcd.remove_npc(npc_id)
			else
				npcd.purge_npc(npc_id)
			end
		end
		-- PURGE STALE ABILITIES
		if se_npc and IsStalker(se_npc) and se_npc:alive() then
			local npc_deck = npcd.get_npc(npc_id)
			if npc_deck and npc_deck.has_profile then
				Printer:Debug(LOG.RUN, CAT.CONF,"sweaping npc %s abilities", npc_id)
				for ability_id, ability in pairs(npc_deck.Ability) do
					if ability.registered == false and (ability.state ~= ABILITY_STATE.COOLDOWN or ability.timer < 0) then
						Printer:Debug(LOG.REMOVE, CAT.CONF,"removing unregistered ability %s from npc %s", ability_id, npc_id)
						npcd.remove_ability(npc_id, ability_id)
					end
				end
			end
		end
	end
	ResetTimeEvent("npcd_manager", "npcs_sweaper", 60)
end

function npcs_profiler()
	Printer:Log(LOG.RUN, CAT.CONF,"running npcs profiler")
	local npcs_list = npcd.get_npcs_id_list()
	-- Printer:LogTable("NPCS list", npcs_list)
	for i = 1, #npcs_list do
		local npc_id = npcs_list[i]
		local se_npc = alife_object(npc_id)
		Printer:Trace(LOG.INFO, CAT.CONF, "se_npc id %s %s", se_npc and se_npc.id or "nil", se_npc and se_npc:name() or "nil")
		local npc_deck = npcd.get_npc(npc_id)
		if se_npc and IsStalker(se_npc) and se_npc:alive() and not npc_deck.has_profile then
			Printer:Debug(LOG.RUN, CAT.CONF,"creating new profile for npc %s %s %s", npc_id, se_npc:name(), se_npc:character_name())
			npcd.create_profile(npc_id)
			npcd.get_npc_data(npc_id) -- initialize npc data for MCM
		end
	end
	ResetTimeEvent("npcd_manager", "npcs_profiler", 60)
end


function npcs_updater()
	Printer:Log(LOG.RUN, CAT.CONF,"running npcs updater")
	local npcs_list = npcd.get_npcs_id_list()
	-- Printer:LogTable("NPCS list", npcs_list)
	for i = 1, #npcs_list do
		local npc_id = npcs_list[i]
		local se_npc = alife_object(npc_id)
		Printer:Trace(LOG.INFO, CAT.CONF, "se_npc id %s %s", se_npc and se_npc.id or "nil", se_npc and se_npc:name() or "nil")		
		local npc_deck = npcd.get_npc(npc_id)
		if se_npc and IsStalker(se_npc) and se_npc:alive() and npc_deck.has_profile then
			Printer:Trace(LOG.RUN, CAT.CONF,"updating profile for npc %s %s %s", npc_id, se_npc:name(), se_npc:character_name())
			local npc_info = npcd.get_npc_info(se_npc.id)
			npc_info.can_recruit = npcd_relations.can_recruit(se_npc.id)
			npcd.set_npc_info(se_npc.id, npc_info)
		end
	end
	ResetTimeEvent("npcd_manager", "npcs_updater", 360)
end

--------------- Abilities EXEC

-- called by NPCD Manager custom time events
function manage_ability_cooldown(ability_cooldown_id, npc_id, feat_id)
	Printer:Trace(LOG.RUN, CAT.FEAT,"managing npc %s ability cooldown %s", npc_id, feat_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then
		Printer:Log(LOG.ERROR, CAT.FEAT,"npc %s deck not found. stopping manage ability cooldown %s", npc_id, ability_cooldown_id)
		return true
	end  -- npc died?

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then
		Printer:Log(LOG.ERROR, CAT.FEAT,"npc %s ability %s not found. stopping manage ability cooldown %s", npc_id, feat_id, ability_cooldown_id)
		return true
	end -- ability unregistered?

    -- setup cooldown transition
	if npc_ability.state == ABILITY_STATE.READY then
		Printer:Debug(LOG.START, CAT.FEAT,"npc %s ability %s init cooldown %s", npc_id, feat_id, npc_ability.cooldown)
		npc_ability.state = ABILITY_STATE.COOLDOWN
		npc_ability.timer = npc_ability.cooldown
	end

    -- ability cooldown ended, kill time event
	if npc_ability.timer <= -5 then
		npc_ability.timer = -999
		npc_ability.state = ABILITY_STATE.READY
		Printer:Debug(LOG.STOP, CAT.FEAT,"cooldown completed. ending time event %s", ability_cooldown_id)
		return true
	elseif npc_ability.timer == 0 then -- ability cooldown ended is, going to reading up
		npc_ability.state = ABILITY_STATE.READING
	end

    -- managing cooldown timer
	local timer = npc_ability.timer
	local cooldown = npc_ability.cooldown
	local state = npc_ability.state
	Printer:Debug(LOG.RUN, CAT.FEAT,"npc %s ability %s state %s timer %s/%s", npc_id, feat_id, state, timer, cooldown)
	npc_ability.timer = npc_ability.timer - 1

    -- updating, necessary ??
    npcd.set_ability(npc_id, npc_ability)

    -- loop cooldown management event
	reset_execution(ability_cooldown_id, 1)
	return false
end

local function activate_ability(npc_id, feat_id)
	Printer:Debug(LOG.RUN, CAT.ACTIV,"activating npc %s ability %s", npc_id, feat_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end  -- npc died?

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then return false end -- ability unregistered?

	if (npc_ability.state == ABILITY_STATE.READING) then
		Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s activates ability %s on READING", npc_id, feat_id)
		npc_ability.state = ABILITY_STATE.READY
	else
		Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s activates ability %s", npc_id, feat_id)
	end

	add_cooldown_execution(npc_id, feat_id)
	return true
end

local function actionable_ability(npc_id, feat_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end  -- npc died?

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then return false end -- ability unregistered?
	if (npc_ability.state == ABILITY_STATE.COOLDOWN) then 
		Printer:Debug(LOG.WARN, CAT.ACTIV,"npc %s cannot activate ability %s that is on cooldown", npc_id, feat_id)
		return false
	else
		Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s can activate ability %s", npc_id, feat_id)
		return true
	end
end

-- TODO add all cooldown timers to a table by cooldown id
-- called by NPCD Manager custom time events
function poll(polling_input)
	Printer:Debug(LOG.RUN, CAT.ACTIV,"polling npc %s ability %s", polling_input.npc_id, polling_input.feat_id)
	
	-- first poll ability is not on cooldown
	if actionable_ability(polling_input.npc_id, polling_input.feat_id) then
		-- execute ability
		local activated = execute_activate(polling_input.npc_id, polling_input.feat_id, polling_input.activation_functor)
		-- activate ability cooldown
		if activated then
			activate_ability(polling_input.npc_id, polling_input.feat_id)
		end
	end

    -- loop polling event
	reset_execution(polling_input.id, polling_input.interval)
	return false
end

-- called by NPCD Input Manager
function activate(activation_input)
	Printer:Debug(LOG.RUN, CAT.ACTIV,"activating npc %s ability %s",activation_input.npc_id, activation_input.feat_id)
	if actionable_ability(activation_input.npc_id, activation_input.feat_id) then
		-- execute ability
		local activated = execute_activate(activation_input.npc_id, activation_input.feat_id, activation_input.activation_functor)
		-- activate ability cooldown
		if activated then
			activate_ability(activation_input.npc_id, activation_input.feat_id)
		end
	end
end

local function bind_ability(npc_id, feat)
	Printer:Debug(LOG.RUN,CAT.ACTIV, "binding npc %s ability %s", npc_id, feat.id)
	if feat.mode == FEAT_MODE.MANUAL then
		npcd_actionbar.add_action_slot(npc_id, feat.id)
	end

	if feat.mode == FEAT_MODE.AUTO then
		add_poll_execution(npc_id, feat)
	end

	if feat.mode == FEAT_MODE.MODAL then
	end

end

local function unbind_ability(npc_id, feat)
	Printer:Debug(LOG.RUN,CAT.ACTIV, "unbinding npc %s ability %s", npc_id,  feat.id)
	if feat.mode == FEAT_MODE.MANUAL then
		npcd_actionbar.remove_action_slot(npc_id, feat.id)
	end

	if feat.mode == FEAT_MODE.AUTO then
		local ability_polling_id = get_ability_polling_id(npc_id, feat.id)
		remove_execution(ability_polling_id)
	end

	if feat.mode == FEAT_MODE.MODAL then
	end

end

--------------- NPCs
---

local function release_npc(npc_id)
	-- TODO: is this necessary? can it be done in squad update?
	-- npcd_actionbar.remove_npc_abilities_from_actionbar(npc_id)
	local npc_deck = npcd.get_npc(npc_id)
	if npc_deck.show_profile then
		npcd.remove_npc(npc_id)
	else
		Printer:Log(LOG.RUN, CAT.CONF, "purging npc %s", npc_id)
		npcd.purge_npc(npc_id)
	end
end

local function register_abilities(npc_id)
	Printer:Debug(LOG.RUN, CAT.CONF,"registering npc %s abilities", npc_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	Printer:LogTable("Register Abilities - NPC perks:", npc_deck)

	for _, npc_perk in pairs(npc_deck.Perk) do
		Printer:Debug(LOG.INFO, CAT.CONF,"npc %s registers abilities for perk %s", npc_id, npc_perk.id)
		local perk = npcd.get_perk(npc_perk.id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				if feat.type == FEAT_TYPE.ACTIVE then
					if npc_can_register(npc_id, feat) then
						if not npcd.ability_registered(npc_id, feat.id) then
							npcd.add_ability(npc_id, feat)
							bind_ability(npc_id, feat)
						else
							npcd.update_ability(npc_id, feat)
						end
					else
						npcd.remove_ability(npc_id, feat.id)
						unbind_ability(npc_id, feat)
					end
				end
			end
		end
	end
	Printer:LogTable("Registered Abilities", npc_deck.Ability)
	return true
end

local function register_npc_perks(npc_id, register)
	Printer:Debug(LOG.RUN, CAT.CONF,"npc %s perks %s", npc_id, register and "registration" or "unregistration")
	local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	if register then
		npcd.setup_profile(npc_id)
	end

	for _, npc_perk in pairs(npc_deck.Perk) do
		local perk = npcd.get_perk(npc_perk.id)
		if perk then
			Printer:Debug(LOG.INFO, CAT.CONF,"npc %s perk %s %s", npc_id, npc_perk.id, register and "register" or "unregister")
			run_register_perk(npc_id, perk, register)
		end
	end
	return true
end

local function unregister_feat(npc_id, feat)
	Printer:Debug(LOG.RUN, CAT.CONF,"unregistering npc %s feat %s", npc_id, feat.id)
	if run_register_feat(npc_id, feat, false) then
		if feat.type == FEAT_TYPE.ACTIVE then
			npcd.set_ability_settings(npc_id, feat.id, { registered = false })
			unbind_ability(npc_id, feat)
		end
		return true
	else
		Printer:Debug(LOG.WARN, CAT.CONF,"npc %s cannot unregister feat %s", npc_id, feat.id)
		return false
	end
end

local function register_feat(npc_id, feat)
	Printer:Debug(LOG.RUN, CAT.CONF,"registering npc %s feat %s", npc_id, feat.id)
	if run_register_feat(npc_id, feat, true) then
		-- only active feats are registered as abilities
		if feat.type == FEAT_TYPE.ACTIVE then
			npcd.set_ability_settings(npc_id, feat.id, { registered = true })
			bind_ability(npc_id, feat)
		end
		return true
	else
		Printer:Debug(LOG.WARN, CAT.CONF,"npc %s cannot register feat %s", npc_id, feat.id)
		return false
	end
end

local function unregister_feats(npc_id)
    Printer:Debug(LOG.RUN, CAT.CONF,"unregistering npc %s feats", npc_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	for _, npc_perk in pairs(npc_deck.Perk) do
		if is_perk_in_deck(npc_id, npc_perk.id) then
			local perk = npcd.get_perk(npc_perk.id)
			if perk and perk.feats  then
				Printer:Debug(LOG.INFO, CAT.CONF,"npc %s unregister feats for perk %s", npc_id, npc_perk.id)
				for _, feat in pairs(perk.feats) do
					unregister_feat(npc_id, feat)
				end
			end
		end
	end
	return true
end

function unregister_perk_feats(npc_id, perk_id)
	Printer:Debug(LOG.RUN, CAT.CONF,"unregistering npc %s perk %s feats", npc_id, perk_id)
	local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	local perk = npcd.get_perk(perk_id)
	if perk and perk.feats  then
		Printer:Debug(LOG.INFO, CAT.CONF,"npc %s unregister feats for perk %s", npc_id, perk_id)
		for _, feat in pairs(perk.feats) do
			unregister_feat(npc_id, feat)
		end
		remove_npc_perk_executions(npc_id, perk_id)
	end
	return true
end

-- RegisterScriptCallback("on_specific_character_init", function(character_id, data)
-- 	printf("%% character_id %s", character_id)
-- 	if data.snd_config:find("(woman|female)") then
-- 		printf("% %s is a woman", character_id)
-- 		female_npc[character_id] = true
-- 	end
-- end)

--- NPC Recruit API

local function unrecruit_npc(npc_id)
	Printer:Debug(LOG.RUN, CAT.NPC, "unrecruiting npc %s", npc_id)
	npcd.set_recruited(npc_id, false)
	local npc_info = npcd.get_npc_info(npc_id)
	if npc_info then
		npc_info.last_time_seen = game.get_game_time()
		npc_info.last_place_seen = dynamic_news_helper.GetPointDescription(db.actor)
		npcd.set_npc_info(npc_id, npc_info)
	end
end

local function recruit_npc(npc_id, clone_id)
	Printer:Debug(LOG.RUN, CAT.NPC, "recruiting npc %s", npc_id)
	if clone_id then
		-- npc recruited through Individually recruitable companions mod dialogs (free, paid)
		if npcd.get_npc(npc_id) then
			Printer:Log(LOG.ADD, CAT.NPC, "recruit npc %s through clone %s", npc_id, clone_id)			
			-- npc profile already exists, remap to the clone id
			if npcd.remap_npc(npc_id, clone_id) then
				npcd.set_recruited(clone_id, true)
			else
				-- cannot remap - there was a problem
				Printer:Log(LOG.ERROR, CAT.NPC, "cannot remap npc %s to new id %s", npc_id, clone_id)
			end
		else
			Printer:Log(LOG.WARN, CAT.NPC, "recruit through clone where only the clone %s exists", clone_id)
			npcd.set_recruited(clone_id, true)
		end
		npc_id = clone_id
	else
		-- npc recruited through vanilla squad joining dialog (can be 1 npc or more at the same time)
		npcd.set_recruited(npc_id, true)
	end
	local npc_info = npcd.get_npc_info(npc_id)
	if npc_info then
		npc_info.last_time_seen = game.get_game_time()
		npc_info.last_place_seen = dynamic_news_helper.GetPointDescription(db.actor)
		npcd.set_npc_info(npc_id, npc_info)
	end
end

function npcd_recruit(npc_id, clone_id)
	if not NPCD_BOOTED then return end
	recruit_npc(npc_id, clone_id)
end

--- NPC DEATH Callback
--- 
function squad_on_npc_death(squad,se_npc)
	Printer:Trace(LOG.RUN, CAT.NPC,"squad_on_npc_death")
	local npc_id = se_npc.id
	if npcd.get_npc(npc_id) then
		Printer:Debug(LOG.REMOVE, CAT.NPC,"dead npc %s name %s released", npc_id, se_npc:name())
		if npcd_squad.is_actor_squad(npc_id) then
			-- npc is part of the actor squad, unrecruit and remove from player deck
			unrecruit_npc(npc_id)
			unregister_feats(npc_id)
			register_npc_perks(npc_id, false)
			remove_npc_executions(npc_id, true)
			-- push for a squad and deck update
			SendScriptCallback("npcd_squad_update")
		end
		release_npc(npc_id)
	end
end

function npc_on_death(victim, who)
	Printer:Debug(LOG.RUN, CAT.NPC,"npc_on_death victim %s killed by %s", victim and victim:name() or "nil", who and who:name() or "nil")
	if not (victim and who) then
		return
	end
	if who and who:id() == db.actor then
		Printer:Debug(LOG.INFO, CAT.NPC, "Enemy %s killed by actor", victim:name())
		return
	end
	if IsStalker(who) and npcd_squad.is_actor_squad(who:id()) then

		Printer:Debug(LOG.INFO, CAT.NPC, "Enemy %s killed by squad member %s", victim:name(), who:character_name())
		npcd_relations.increase_goodwill_kill(who)
	end
end


--------------- Player Deck
---

local player_deck = {
	Perk = {},
}

function is_perk_in_deck(npc_id, perk_id)
	if player_deck.Perk[perk_id] and player_deck.Perk[perk_id].npc_id == npc_id then
		return true
	else
		return false
	end
end

function unregister_deck()
	Printer:Debug(LOG.RUN, CAT.CONF,"unregistering actor deck")
	for perk_id, perk_info in pairs(player_deck.Perk) do
		local npc_id = perk_info.npc_id
		local perk = npcd.get_perk(perk_id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				unregister_feat(npc_id, feat)
			end
		end
	end
end

function register_deck()
	Printer:Debug(LOG.RUN, CAT.NPC,"registering actor deck")
	for perk_id, perk_info in pairs(player_deck.Perk) do
		local npc_id = perk_info.npc_id
		local perk = npcd.get_perk(perk_id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				register_feat(npc_id, feat)
			end
		end
	end
end

function build_deck()
	Printer:Debug(LOG.RUN, CAT.CONF,"updating actor deck")
	player_deck.Perk = {}
	local clist = npcd_squad.squad_get_clist()
	for i=1, #clist do
		local npc = npcdu.get_npc_obj(clist[i])
		if npc and npc:alive() then
			local npc_id = npc:id()
			local npc_deck = npcd.get_npc(npc_id)
			if npc_deck and npc_deck.Perk then
				for _, npc_perk in pairs(npc_deck.Perk) do
					if not player_deck.Perk[npc_perk.id] then
						Printer:Debug(LOG.INFO, CAT.CONF, "adding perk %s from npc %s", npc_perk.id, npc_id)
						player_deck.Perk[npc_perk.id] = { id = npc_perk.id, npc_id = npc_id, rank = npcdu.get_feat_rank(npc_id) }
					else
						local rank1 = npcdu.get_feat_rank(npc_id)
						local rank2 = npcdu.get_feat_rank(player_deck.Perk[npc_perk.id].npc_id)
						if rank1 > rank2 then
							Printer:Debug(LOG.INFO, CAT.CONF, "upgrading perk %s from npc %s (rank %s) to npc %s (rank %s)", npc_perk.id, player_deck.Perk[npc_perk.id].npc_id, rank2, npc_id, rank1)
							player_deck.Perk[npc_perk.id] = { id = npc_perk.id, npc_id = npc_id, rank = rank1 }
						else
							Printer:Debug(LOG.INFO, CAT.CONF, "skipping duplicate perk %s from npc %s", npc_perk.id, npc_id)
							unregister_perk_feats(npc_id, npc_perk.id)
						end
						-- TODO compare ranks and keep the highest
					end
				end
			end
		end
	end
	Printer:LogTable("Actor Deck", player_deck)
end

local function remove_from_deck(npc_id)
	Printer:Debug(LOG.RUN, CAT.NPC,"remove_from_deck npc %s", npc_id)
	local perks_to_remove = {}
	for perk_id, perk_info in pairs(player_deck.Perk) do
		if perk_info.npc_id == npc_id then
			table.insert(perks_to_remove, perk_id)
		end
	end
	for i=1, #perks_to_remove do
		player_deck.Perk[perks_to_remove[i]] = nil
	end
	unregister_feats(npc_id)
end

--------------- SQUAD UPDATES

local current_clist
local function do_npcd_squad_update()
	Printer:Debug(LOG.RUN, CAT.NPC,"do_npcd_squad_update")
	local new_clist = npcd_squad.squad_get_clist()

	local added_ids, removed_ids = npcdu.compute_diff(new_clist, current_clist)

	-- update removed squad members
	for i=1, #removed_ids do
		local npc = npcdu.get_npc_obj(removed_ids[i])
		if npc and npcd.get_npc(npc:id()) then -- check if npc was released during squad_on_npc_death event
			unrecruit_npc(npc:id())
			unregister_feats(npc:id())
			register_npc_perks(npc:id(), false)
			remove_npc_executions(npc:id())
		end
	end

	-- update new squad members 
	-- TODO 2 this now is only to cover the case where an entire squad joins
	-- TODO 3 maybe we should not recruit and register non profiled npc automatically
	for i=1, #added_ids do
		local npc = npcdu.get_npc_obj(added_ids[i])
		if npc and npc:alive() then
			recruit_npc(npc:id())
			register_npc_perks(npc:id(), true)
		end
	end
	current_clist = new_clist
	build_deck()
	register_deck()
	npcd_actionbar.update_actionbar()
	return true
end

local function npcd_squad_update()
	Printer:Debug(LOG.RUN, CAT.NPC,"npcd_squad_update")
	-- absorbs multiple callbacks in quick succession
	CreateTimeEvent("npcd_manager", "do_npcd_squad_update", 1, do_npcd_squad_update)
end

local function resume_squad_state()
	Printer:Debug(LOG.RUN, CAT.NPC,"resume_squad_state")
	npcd_squad.update_squad_info()
	current_clist = npcd_squad.squad_get_clist()
	if npcd_squad.squad_available() then
		Printer:Debug(LOG.RUN, CAT.NPC,"resuming squad state")
		-- register perks for all squad members
		local clist = npcd_squad.squad_get_clist()
		for i=1, #clist do
			local npc = npcdu.get_npc_obj(clist[i])
			if npc and npc:alive() then
				register_npc_perks(npc:id(), true)
			end
		end
		-- build and register the deck
		build_deck()
		register_deck()
		-- restart squad executions
		restart_squad_executions()
	else
		Printer:Debug(LOG.WARN, CAT.NPC,"no squad available")
	end
end

--------------- NPCD STATE MGMT

function save_state(m_data)
	Printer:Log(LOG.ADD, CAT.CONF,"NPCDeck State - Saving")
    if not m_data.npcd then
        m_data.npcd = {}
    end 
    -- save the state

	-- npcs decks
    m_data.npcd.npcs = npcd.get_deck()
	-- npcs stats
	m_data.npcd.stats = npcd.get_stats()
	-- npcs data for MCM
	m_data.npcd.data = npcd.get_data()

	

	Printer:LogTable("NPCDeck", m_data.npcd.npcs)
	Printer:LogTable("NPCStats", m_data.npcd.stats)
	Printer:LogTable("NPCs MCM Data", m_data.npcd.data)
end

function load_state(m_data)
	if not Printer then
		get_printer()
	end
	Printer:Log(LOG.ADD, CAT.CONF,"NPCDeck State - Loading")
	if m_data.npcd and m_data.npcd.npcs then
        -- cache the state
        npcd.set_deck(m_data.npcd.npcs)
		Printer:LogTable("NPCDeck", npcd.get_deck())
	end
	if m_data.npcd and m_data.npcd.stats then
		npcd.set_stats(m_data.npcd.stats)
		Printer:LogTable("NPCStats", npcd.get_stats())
	end
	if m_data.npcd and m_data.npcd.data then
		npcd.set_data(m_data.npcd.data)
		Printer:LogTable("NPCs MCM Data", npcd.get_data())
	end
	SendScriptCallback("npcd_on_loaded_state")
end

-- NPCD LIFECYCLE

local tg_update = 0
local tg_update_step = 500 --[ms]
function actor_on_update()

	local tg = time_global()
	if tg < tg_update then
		return
	end
	tg_update = tg + tg_update_step

	npcd_squad.update_squad_info()

	-- printlog_table("Stalkers", stalkers)
end

function actor_on_net_destroy()
	teardown_npcd_execution()
end

--- MODULE REGISTRATION and MGMT

function register_module(deck)
	printf("-[NPCD][MAIN] Manager register module %s", deck.module)
	npcd.add_module_perks(deck.module, deck.perks)
end

function update_module(deck)
	Printer:Log(LOG.RUN, CAT.CONF,"Manager update module %s", deck.module)
	npcd.update_module_perks(deck.module)
	SendScriptCallback("npcd_squad_update")
end

---- 

function game_object_on_net_spawn(obj)
	if (IsStalker(obj) and obj:alive() and obj:id() ~= 0 and obj:character_community() ~= "zombied") then
		if npcd.add_npc(obj:id()) then
			printf("-[NPCD][MAIN] new npc added id:%s, name:%s, character_name:%s, faction:%s", obj:id(), obj:name(), obj:character_name(), obj:character_community())
		end
	end
end

-- function game_object_on_net_spawn(obj)
-- 	if (IsStalker(obj) and obj:alive()) then	
-- 		printf("-[NPCD][MAIN] NPC spawned id:%s, name:%s, character_name:%s, community:%s, rank:%s, reputation:%s, goodwill:%s, general_goodwill:%s", obj:id(), obj:name(), obj:character_name(), obj:community(), obj:rank(), obj:reputation(), obj:goodwill(), obj:general_goodwill())
-- 	end
-- end


function actor_on_first_update()
	Printer:Log(LOG.START, CAT.EXEC,"Manager actor_on_first_update")
end

function on_option_change()
end

---- BOOT

NPCD_BOOTED = false

function check_can_boot()
	local plist = npcd.get_perks_id_list()
	NPCD_BOOTED = (#plist > 0)
	return NPCD_BOOTED
end

function game_play_start()
	if(device().precache_frame > 1) then --detects if game is not past the press any key prompt
		return
	end
	--setup your thing here
	UnregisterScriptCallback("actor_on_update", game_play_start)
	Printer:Log(LOG.START, CAT.EXEC,"Manager game_play_start")
	check_can_boot()
	if not NPCD_BOOTED then
		UnregisterScriptCallback("squad_on_npc_death", squad_on_npc_death)
		UnregisterScriptCallback("npcd_squad_update", npcd_squad_update)
		UnregisterScriptCallback("on_option_change", on_option_change)
		UnregisterScriptCallback("load_state", load_state)
		UnregisterScriptCallback("save_state", save_state)
		UnregisterScriptCallback("game_object_on_net_spawn", game_object_on_net_spawn)
		UnregisterScriptCallback("actor_on_first_update", actor_on_first_update)
		return
	end
	-- NPCD BOOTING
	Printer:Log(LOG.START, CAT.EXEC, "NPCD BOOTED")
	start_npcd_execution()
	resume_squad_state()
	SendScriptCallback("npcd_started")
	RegisterScriptCallback("actor_on_update", actor_on_update)
end

function actor_on_first_update()
    printf("$[NPCD][Main] npcd_manager actor_on_first_update")
end

function on_game_start()
	printf("$[NPCD][MAIN] npcd_manager on_game_start")
	RegisterScriptCallback("actor_on_update", game_play_start)
	RegisterScriptCallback("squad_on_npc_death", squad_on_npc_death)
	RegisterScriptCallback("npc_on_death_callback", npc_on_death)
	RegisterScriptCallback("npcd_squad_update", npcd_squad_update)
	RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("actor_on_net_destroy",actor_on_net_destroy)
	RegisterScriptCallback("game_object_on_net_spawn", game_object_on_net_spawn)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	get_printer()
end

-- npcd_manager.debug_set_goodwill()
-- npcd_manager.debug_set_community_goodwill()

function debug_set_goodwill(npc_id, goodwill)
	local npc = npcdu.get_npc_obj(npc_id)
	if npc then
		npc:set_goodwill(goodwill, db.actor)
		printf("- npc relation %s", npc:relation(db.actor))
	end
end

function debug_set_community_goodwill(npc_id, goodwill)
	local npc = npcdu.get_npc_obj(npc_id)
	if npc then
		npc:set_community_goodwill(character_community(db.actor), goodwill)
		printf("- npc relation %s", npc:relation(db.actor))
	end
end