local npcdu = npcd_utils

local FEAT_TYPE = npcd.FEAT_TYPE
local FEAT_MODE = npcd.FEAT_MODE
local ABILITY_STATE = npcd.ABILITY_STATE

--------------- ABILITIES
function register_abilities(npc_id)

	printf("! npc %s register_abilities", npc_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	for _, npc_perk in pairs(npc_deck.Perk) do
		printf("! npc %s register_abilities for perk %s", npc_id, npc_perk.id)
		local perk_deck = npcd.get_perk(npc_perk.id)
		if perk_deck and perk_deck.feats then
			for _, feat in pairs(perk_deck.feats) do
				if feat.type == FEAT_TYPE.ACTIVE then
					npcd.add_ability(npc_id, feat)
				end
			end
		end
	end
	npcdu.printlog_table("Registered Abilities", npc_deck.Ability)
	return true
end

function unregister_abilities(npc_id)

    printf("! npc %s unregister_abilities", npc_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	for _, npc_perk in pairs(npc_deck.Perk) do
		printf("! npc %s unregister_abilities for perk %s", npc_id, npc_perk.id)
		local perk_deck = npcd.get_perk(npc_perk.id)
		if perk_deck and perk_deck.feats then
			for _, feat in pairs(perk_deck.feats) do
				if feat.type == FEAT_TYPE.ACTIVE then
					npcd.remove_ability(npc_id, feat.id)
				end
			end
		end
	end
	return true
end

-- time event function
function manage_ability_cooldown(npc_id, feat_id)

    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return true end  -- npc died?

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then return true end -- ability unregistered?

    -- setup cooldown transition
	if npc_ability.state == ABILITY_STATE.READY then
		printf("npc %s manage_ability %s init cooldown %s", npc_id, feat_id, npc_ability.cooldown)
		npc_ability.state = ABILITY_STATE.COOLDOWN
		npc_ability.timer = npc_ability.cooldown
	end

    -- ability cooldown ended, kill time event
	if npc_ability.timer <= -5 then
		npc_ability.timer = -999
		npc_ability.state = ABILITY_STATE.READY
		printf("! ending time event %s", npc_id)
		return true
	elseif npc_ability.timer == 0 then -- ability cooldown ended is, going to reading up
		npc_ability.state = ABILITY_STATE.READING
	end

    -- managing cooldown timer
	local timer = npc_ability.timer
	local cooldown = npc_ability.cooldown
	local state = npc_ability.state
	printf("// npc %s manage_ability %s state %s timer %s/%s", npc_id, feat_id, state, timer, cooldown)
	npc_ability.timer = npc_ability.timer - 1

    -- updating, necessary ??
    npcd.set_ability(npc_id, npc_ability)

    -- loop cooldown management event
	-- CreateTimeEvent("ability_coolddown", tostring(npc_id) .. feat_id .. "_" .. tostring(timer), 1, manage_ability_cooldown, npc_id, feat_id)
    ResetTimeEvent("npcd_ability_coolddown", tostring(npc_id) .. feat_id, 1)
	return false
end

function activate_ability(npc_id, feat_id)

    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return true end  -- npc died?

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then return true end -- ability unregistered?

	if (npc_ability.state == ABILITY_STATE.COOLDOWN) then 
		printf("! npc %s cannot activate ability %s that is on cooldown", npc_id, feat_id)
		return false
	elseif (npc_ability.state == ABILITY_STATE.READING) then
		printf("! npc %s activates ability %s on READING", npc_id, feat_id)
		npc_ability.state = ABILITY_STATE.READY
	end

    RemoveTimeEvent("npcd_ability_coolddown", tostring(npc_id) .. feat_id)

    printf("! npc %s activate_ability %s", npc_id, feat_id)

	CreateTimeEvent("npcd_ability_coolddown", tostring(npc_id) .. feat_id, 0.5, manage_ability_cooldown, npc_id, feat_id)
	return true
end

--------------- SQUAD UPDATES

local current_clist
local function npcd_squad_update()
	printf("% npcd_squad_update")
	local new_clist = axr_companions.list_actor_squad_by_id()

	local added_ids, removed_ids = npcdu.compute_diff(new_clist, current_clist)

	-- update new squad members
	for i=1, #added_ids do
		local npc = npcdu.get_npc_obj(added_ids[i])
		if npc and npc:alive() then
			local npc_id = npc:id()
			if npcd.add_npc(npc_id) then
				-- It's a new NPC lets roll the perks
				npcd.create_profile(npc_id)
			end
			register_abilities(npc_id)
		end
	end

	-- update removed squad members
	for i=1, #removed_ids do
		local npc = npcdu.get_npc_obj(removed_ids[i])
		local npc_id = npc:id()
		unregister_abilities(npc_id)
	end	

	current_clist = new_clist
end

-- DEATH

function squad_on_npc_death(squad,se_npc)
	local npc = db.storage[se_npc.id] and db.storage[se_npc.id].object
	if not npc then return end
	-- printf("squad_on_npc_death name %s", npc and npc:name())
	local npc_id = npc:id() or 0
	npcd.remove_npc(npc_id)
	for id,actor_squad in pairs(axr_companions.companion_squads) do
		if squad.id == actor_squad.id then
			SendScriptCallback("npcd_squad_update")
		end
	end
end

--------------- SQUAD STATE

function is_companions_squad_in_danger()
	--printf("============================================================================================")
	local squad_is_peaceful = true
	local clist = axr_companions.list_actor_squad_by_id()
	for i=1, #clist do
		local npc = db.storage[clist[i]] and db.storage[clist[i]].object
		if npc then
			local is_peaceful = false
			-- check if is in fight
			if npc:alive() then
				is_peaceful = (not npc:best_enemy()) and npc:dont_has_info("npcx_beh_ignore_combat") and true or false
			end
			-- printf("companion[%s] is_peaceful %s - dist: %s",k.id, is_peaceful, distance_between(db.actor,npc))
			-- check if is too far away
			squad_is_peaceful = squad_is_peaceful and is_peaceful
			-- printf("current calculation for squad is_peaceful %s", squad_is_peaceful)					
		end	
	end	
	if not squad_is_peaceful then
		-- printf("squad is under attack or attacking")
	end
	-- printf("-- squad is resolved peaceful %s", squad_is_peaceful)
	--printf("============================================================================================")
	return not squad_is_peaceful
end

--------------- STATE MGMT

function save_state(m_data)
	printf("$ NPCDeck Save State")
    if not m_data.npcd then
        m_data.npcd = {}
    end 
    -- save the state
    m_data.npcd.npcs = npcd.get_deck()
	npcdu.printlog_table("NPCDeck", m_data.npcd.npcs)
end

function load_state(m_data)
	printf("$ NPCDeck Load State")
	if m_data.npcd and m_data.npcd.npcs then
        -- cache the state
        npcd.set_deck(m_data.npcd.npcs)
		npcdu.printlog_table("NPCDeck", npcd.get_deck())
	end
end

-- LIFECYCLE

local squad_is_peaceful = true
function actor_on_first_update()
	printf("-- NPCD Manager actor_on_first_update")	
    -- squad_is_peaceful = not (is_companions_squad_in_danger())
end


local tg_update = 0
local tg_update_step = 1000 --[ms]
function actor_on_update()

	local tg = time_global()
	if tg < tg_update then
		return
	end
	tg_update = tg + tg_update_step

	local in_danger_state = is_companions_squad_in_danger()
	-- printf("squad_is_peaceful %s, in_danger_state %s", squad_is_peaceful, in_danger_state)
	if squad_is_peaceful and in_danger_state then
		printf("npcd_squad_combat_started")
		squad_is_peaceful = false
		SendScriptCallback("npcd_squad_combat_started")
		return
	end

	if not squad_is_peaceful and not in_danger_state then
		printf("npcd_squad_combat_ended")
		squad_is_peaceful = true
		SendScriptCallback("npcd_squad_combat_ended")
		return
	end


	-- printlog_table("Stalkers", stalkers)
end

function register_module(module_name, perks)
	printf("- NPCD Manager register_module %s", module_name)
	npcd.add_module_perks(perks)
end

if AddScriptCallback then
	AddScriptCallback("npcd_squad_update")
	AddScriptCallback("npcd_squad_combat_started")
	AddScriptCallback("npcd_squad_combat_ended")
end

function on_game_start()
	printf("-- NPCD Manager on_game_start")
	RegisterScriptCallback("npcd_actor_on_first_update", actor_on_first_update)
	RegisterScriptCallback("actor_on_update",actor_on_update)
	RegisterScriptCallback("squad_on_npc_death",squad_on_npc_death)
	RegisterScriptCallback("npcd_squad_update",npcd_squad_update)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("save_state", save_state)
end