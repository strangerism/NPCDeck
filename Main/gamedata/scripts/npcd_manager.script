local npcdu = npcd_utils

function get_printer()
	if not Printer then
		Printer = npcd_logging.get_printer("npcd_manager")
	end 
	LOG = Printer:GetLogTypes()
	CAT = Printer:GetLogCategories()
end
if AddScriptCallback then
	RegisterScriptCallback("npcd_on_log_update", get_printer)
end

local FEAT_TYPE = npcd.FEAT_TYPE
local FEAT_MODE = npcd.FEAT_MODE
local ABILITY_STATE = npcd.ABILITY_STATE

--------------- Utilities

local function execute(npc_id, functor)
	if not functor then return false end
	local ex_functor = npcdu.copy(functor)
	table.insert(ex_functor, npc_id)
	Printer:TraceTable("npc executing", ex_functor)
	local result = execute_func(unpack(ex_functor))
	Printer:Trace(LOG.INFO, CAT.EXEC,"with result: %s", result)
	return result
end

local function npc_can_register(npc_id, feat)
	if feat.register_functor then
		return execute(npc_id, feat.register_functor)
	else
		return true
	end
end

local function get_ability_polling_id(npc_id, feat_id)
	return "ability_polling_" .. tostring(npc_id) .. "_" .. feat_id
end

local function get_ability_cooldown_id(npc_id, feat_id)
	return "ability_cooldown_" .. tostring(npc_id) .. "_" .. feat_id
end

local function create_polling_input(npc_id, feat)
	local polling_input = {}
	polling_input["id"] = get_ability_polling_id(npc_id, feat.id)
	polling_input["npc_id"] = npc_id
	polling_input["feat_id"] = feat.id
	polling_input["interval"] = feat.activation_polling_interval or 1
	polling_input["activation_functor"] = feat.activation_functor
	return polling_input
end

--------------- Execution MGMT
---

Tasks = {}

local function remove_execution(id)
	Printer:Debug(LOG.STOP, CAT.EXEC,"remove execution %s", id)
	RemoveTimeEvent("npcd_manager", id)
	Tasks[id] = nil
end

local function add_cooldown_execution(npc_id, feat_id)
	local ability_cooldown_id = get_ability_cooldown_id(npc_id, feat_id)
	remove_execution(ability_cooldown_id)
	Printer:Debug(LOG.ADD, CAT.EXEC,"npc %s creates new ability cooldown manager %s", npc_id, ability_cooldown_id)
	CreateTimeEvent("npcd_manager", ability_cooldown_id, 0, manage_ability_cooldown, ability_cooldown_id, npc_id, feat_id)
	Tasks[ability_cooldown_id] = { npc_id = npc_id, feat_id = feat_id}
end

local function add_poll_execution(npc_id, feat)
	local polling_input = create_polling_input(npc_id, feat)
	Printer:Debug(LOG.ADD, CAT.EXEC,"npc %s creates new ability poll manager %s", npc_id, polling_input.id)
	CreateTimeEvent("npcd_manager", polling_input.id, polling_input.interval, poll, polling_input)
	Tasks[polling_input.id] = { npc_id = npc_id, feat_id = feat.id}
end

local function reset_execution(id, delay)
	Printer:Debug(LOG.ADD, CAT.EXEC,"reset execution %s", id)
	ResetTimeEvent("npcd_manager", id, delay)
end

local function remove_npc_executions(npc_id)
	Printer:Debug(LOG.RUN, CAT.EXEC,"remove npc %s executions",npc_id)
	for id, execution_info in pairs(Tasks) do
		if execution_info.npc_id == npc_id then
			remove_execution(id)
		end
	end
end

local function resume_npc_ability_execution(npc_id, feat)
	Printer:Debug(LOG.RUN, CAT.EXEC,"resume npc %s ability %s execution", npc_id, feat.id)
	if feat.type == FEAT_TYPE.ACTIVE then
		if npcd.ability_registered(npc_id, feat.id) then
			Printer:Debug(LOG.ADD, CAT.EXEC,"npc %s restarts execution %s", npc_id, feat.id)
			if feat.mode == FEAT_MODE.MANUAL then
				add_cooldown_execution(npc_id, feat.id)
			end
			if feat.mode == FEAT_MODE.AUTO then
				add_poll_execution(npc_id, feat)
			end
		end
	end
end

function restart_npc_execution(npc_id)
	Printer:Debug(LOG.RUN, CAT.EXEC,"npc %s restarts abilities execution", npc_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	Printer:LogTable("Restart Abilities - NPC perks:", npc_deck)
	for _, npc_perk in pairs(npc_deck.Perk) do
		Printer:Debug(LOG.INFO, CAT.EXEC,"npc %s restarts abilities for perk %s", npc_id, npc_perk.id)
		local perk = npcd.get_perk(npc_perk.id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				resume_npc_ability_execution(npc_id, feat)
			end
		end
	end
	Printer:LogTable("Restarted Abilities", npc_deck.Ability)
	return true
end

local function start_npcd_execution()
	Printer:Debug(LOG.RUN, CAT.EXEC,"start_npcd_execution")

	-- restart saved execution checkpoints
	local clist = npcd_squad.squad_get_clist()
	for i = 1, #clist do
		restart_npc_execution(clist[i])
	end

	-- start the npcd sim tasks
	CreateTimeEvent("npcd_manager", "npcs_sweaper", 0, npcs_sweaper)
	CreateTimeEvent("npcd_manager", "npcs_profiler", 0, npcs_profiler)
	CreateTimeEvent("npcd_manager", "npcs_updater", 10, npcs_updater)
end

local function teardown_npcd_execution()
	Printer:Debug(LOG.STOP, CAT.EXEC,"teardown_npcd_execution")

	-- stop current npc Tasks execution
	for key, value in pairs(Tasks) do
		RemoveTimeEvent("npcd_manager", key)
	end

	-- stopping the npcd sim tasks
	RemoveTimeEvent("npcd_manager", "npcs_sweaper")
	RemoveTimeEvent("npcd_manager", "npcs_profiler")
end

function npcs_sweaper()
	Printer:Log(LOG.RUN, CAT.CONF,"npcs sweaper")
	local npcs_list = npcd.get_npcs_id_list()
	for i = 1, #npcs_list do
		local npc_id = npcs_list[i]
		local se_npc = alife_object(npc_id)
		if not se_npc then
			Printer:Debug(LOG.REMOVE, CAT.CONF,"removing stale npc %s data", npc_id)
			local npc_deck = npcd.get_npc(npc_id)
			if npc_deck.show_profile then
				npcd.remove_npc(npc_id)
			else
				npcd.purge_npc(npc_id)
			end
		end
	end
	ResetTimeEvent("npcd_manager", "npcs_sweaper", 60)
end

function npcs_profiler()
	Printer:Log(LOG.RUN, CAT.CONF,"npcs profiler")
	local npcs_list = npcd.get_npcs_id_list()
	-- Printer:LogTable("NPCS list", npcs_list)
	for i = 1, #npcs_list do
		local npc_id = npcs_list[i]
		Printer:Trace(LOG.INFO, CAT.CONF, "profiling npc %s", npc_id)
		local se_npc = alife_object(npc_id)
		local npc_deck = npcd.get_npc(npc_id)
		if se_npc and se_npc:alive() and not npc_deck.has_profile then
			Printer:Debug(LOG.RUN, CAT.CONF,"creating new profile for npc %s %s %s", npc_id, se_npc:name(), se_npc:character_name())
			npcd.create_profile(npc_id)
		end
	end
	ResetTimeEvent("npcd_manager", "npcs_profiler", 60)
end


function npcs_updater()
	Printer:Log(LOG.RUN, CAT.CONF,"npcs npcs_updater")
	local npcs_list = npcd.get_npcs_id_list()
	Printer:LogTable("NPCS list", npcs_list)
	printf("%s",#npcs_list)
	for i = 1, #npcs_list do
		local npc_id = npcs_list[i]
		Printer:Trace(LOG.INFO, CAT.CONF, "updating npc %s", npc_id)
		local se_npc = alife_object(npc_id)
		local npc_deck = npcd.get_npc(npc_id)
		if se_npc and se_npc:alive() and npc_deck.has_profile then
			Printer:Debug(LOG.RUN, CAT.CONF,"updating profile for npc %s %s %s", npc_id, se_npc:name(), se_npc:character_name())
			local npc_info = npcd.get_npc_info(se_npc.id)
			npc_info.can_recruit = npcd_relations.is_npc_recruitable(se_npc.id)
			npcd.set_npc_info(se_npc.id, npc_info)
		end
	end
	ResetTimeEvent("npcd_manager", "npcs_updater", 360)
end

--------------- Abilities EXEC

-- called by NPCD Manager custom time events
function manage_ability_cooldown(ability_cooldown_id, npc_id, feat_id)
	Printer:Trace(LOG.RUN, CAT.FEAT,"npc %s manage ability cooldown %s", npc_id, feat_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then
		Printer:Log(LOG.ERROR, CAT.FEAT,"npc %s deck not found. stopping manage ability cooldown %s", npc_id, ability_cooldown_id)
		return true
	end  -- npc died?

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then
		Printer:Log(LOG.ERROR, CAT.FEAT,"npc %s ability %s not found. stopping manage ability cooldown %s", npc_id, feat_id, ability_cooldown_id)
		return true
	end -- ability unregistered?

    -- setup cooldown transition
	if npc_ability.state == ABILITY_STATE.READY then
		Printer:Debug(LOG.START, CAT.FEAT,"npc %s ability %s init cooldown %s", npc_id, feat_id, npc_ability.cooldown)
		npc_ability.state = ABILITY_STATE.COOLDOWN
		npc_ability.timer = npc_ability.cooldown
	end

    -- ability cooldown ended, kill time event
	if npc_ability.timer <= -5 then
		npc_ability.timer = -999
		npc_ability.state = ABILITY_STATE.READY
		Printer:Debug(LOG.STOP, CAT.FEAT,"cooldown completed. ending time event %s", ability_cooldown_id)
		return true
	elseif npc_ability.timer == 0 then -- ability cooldown ended is, going to reading up
		npc_ability.state = ABILITY_STATE.READING
	end

    -- managing cooldown timer
	local timer = npc_ability.timer
	local cooldown = npc_ability.cooldown
	local state = npc_ability.state
	Printer:Debug(LOG.RUN, CAT.FEAT,"npc %s ability %s state %s timer %s/%s", npc_id, feat_id, state, timer, cooldown)
	npc_ability.timer = npc_ability.timer - 1

    -- updating, necessary ??
    npcd.set_ability(npc_id, npc_ability)

    -- loop cooldown management event
	reset_execution(ability_cooldown_id, 1)
	return false
end

local function activate_ability(npc_id, feat_id)
	Printer:Debug(LOG.RUN, CAT.ACTIV,"npc %s tries to activate ability %s", npc_id, feat_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end  -- npc died?

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then return false end -- ability unregistered?

	if (npc_ability.state == ABILITY_STATE.READING) then
		Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s activates ability %s on READING", npc_id, feat_id)
		npc_ability.state = ABILITY_STATE.READY
	else
		Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s activates ability %s", npc_id, feat_id)
	end

	add_cooldown_execution(npc_id, feat_id)
	return true
end

local function poll_ability(npc_id, feat_id)
	Printer:Trace(LOG.RUN, CAT.ACTIV,"npc %s polling ability cooldown %s", npc_id, feat_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end  -- npc died?

    local npc_ability = npcd.get_ability(npc_id, feat_id)
	if not npc_ability then return false end -- ability unregistered?

	Printer:Debug(LOG.INFO, CAT.ACTIV,"npc %s cheking ability cooldown %s", npc_id, feat_id)
	if (npc_ability.state == ABILITY_STATE.COOLDOWN) then 
		Printer:Debug(LOG.WARN, CAT.ACTIV,"npc %s cannot activate ability %s that is on cooldown", npc_id, feat_id)
		return false
	else
		return true
	end
end

-- TODO add all cooldown timers to a table by cooldown id
-- called by NPCD Manager custom time events
function poll(polling_input)
	Printer:Debug(LOG.RUN, CAT.ACTIV,"npc %s polls ability %s", polling_input.npc_id, polling_input.feat_id)
	
	-- first poll ability is not on cooldown
	if poll_ability(polling_input.npc_id, polling_input.feat_id) then
		-- execute ability
		local activated = execute(polling_input.npc_id, polling_input.activation_functor)
		-- activate ability cooldown
		if activated then
			activate_ability(polling_input.npc_id, polling_input.feat_id)
		end
	end

    -- loop polling event
	reset_execution(polling_input.id, polling_input.interval)
	return false
end

-- called by NPCD Input Manager
function activate(activation_input)
	Printer:Debug(LOG.RUN, CAT.ACTIV,"input manager activates npc %s ability %s",activation_input.npc_id, activation_input.feat_id)
	if poll_ability(activation_input.npc_id, activation_input.feat_id) then
		-- execute ability
		local activated = execute(activation_input.npc_id, activation_input.activation_functor)
		-- activate ability cooldown
		if activated then
			activate_ability(activation_input.npc_id, activation_input.feat_id)
		end
	end
end

local function bind_ability(npc_id, feat)
	Printer:Debug(LOG.ADD,CAT.NPC, "npc %s bind ability %s", npc_id, feat.id)
	if feat.mode == FEAT_MODE.MANUAL then
		npcd_actionbar.add_action_slot(npc_id, feat.id)
	end

	if feat.mode == FEAT_MODE.AUTO then
		add_poll_execution(npc_id, feat)
	end

	if feat.mode == FEAT_MODE.MODAL then
	end

end

local function unbind_ability(npc_id, feat)
	Printer:Debug(LOG.REMOVE,CAT.NPC, "npc %s unbind ability %s", npc_id,  feat.id)
	if feat.mode == FEAT_MODE.MANUAL then
		npcd_actionbar.remove_action_slot(npc_id, feat.id)
	end

	if feat.mode == FEAT_MODE.AUTO then
		local ability_polling_id = get_ability_polling_id(npc_id, feat.id)
		remove_execution(ability_polling_id)
	end

	if feat.mode == FEAT_MODE.MODAL then
	end

end

--------------- ACTIONBAR UPDATES

local function update_actionbar()
	Printer:Debug(LOG.INFO, CAT.UI_ACTION, "Manager update actionbar")
	npcd_actionbar.reset_actionbar()
end

--------------- NPCs
---

local function release_npc(npc_id)
	remove_npc_executions(npc_id)
	npcd_actionbar.remove_npc_abilities_from_actionbar(npc_id)
	local npc_deck = npcd.get_npc(npc_id)
	if npc_deck.show_profile then
		npcd.remove_npc(npc_id)
	else
		Printer:Log(LOG.RUN, CAT.NPC, "purging npc %s", npc_id)
		npcd.purge_npc(npc_id)
	end
end

local function register_abilities(npc_id)
	Printer:Debug(LOG.RUN, CAT.NPC,"npc %s register abilities", npc_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	Printer:LogTable("Register Abilities - NPC perks:", npc_deck)

	for _, npc_perk in pairs(npc_deck.Perk) do
		Printer:Debug(LOG.INFO, CAT.NPC,"npc %s registers abilities for perk %s", npc_id, npc_perk.id)
		local perk = npcd.get_perk(npc_perk.id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				if feat.type == FEAT_TYPE.ACTIVE then
					if npc_can_register(npc_id, feat) then
						Printer:Debug(LOG.ADD, CAT.NPC,"npc %s adds ability %s", npc_id, feat.id)
						if not npcd.ability_registered(npc_id, feat.id) then
							npcd.add_ability(npc_id, feat)
							bind_ability(npc_id, feat)
						else
							npcd.update_ability(npc_id, feat)
						end
					else
						Printer:Debug(LOG.REMOVE, CAT.NPC,"npc %s removes ability %s", npc_id, feat.id)
						npcd.remove_ability(npc_id, feat.id)
						unbind_ability(npc_id, feat)
					end
				end
			end
		end
	end
	Printer:LogTable("Registered Abilities", npc_deck.Ability)
	return true
end

local function unregister_abilities(npc_id)
    Printer:Debug(LOG.RUN, CAT.NPC,"npc %s unregister abilities", npc_id)
    local npc_deck = npcd.get_npc(npc_id)
	if not npc_deck then return false end -- npc died?

	for _, npc_perk in pairs(npc_deck.Perk) do
		Printer:Debug(LOG.INFO, CAT.NPC,"npc %s unregister abilities for perk %s", npc_id, npc_perk.id)
		local perk = npcd.get_perk(npc_perk.id)
		if perk and perk.feats then
			for _, feat in pairs(perk.feats) do
				if feat.type == FEAT_TYPE.ACTIVE then
					Printer:Debug(LOG.REMOVE, CAT.NPC,"npc %s removes ability %s", npc_id, feat.id)
					npcd.remove_ability(npc_id, feat.id)
					unbind_ability(npc_id, feat)
				end
			end
		end
	end
	return true
end

-- RegisterScriptCallback("on_specific_character_init", function(character_id, data)
-- 	printf("%% character_id %s", character_id)
-- 	if data.snd_config:find("(woman|female)") then
-- 		printf("% %s is a woman", character_id)
-- 		female_npc[character_id] = true
-- 	end
-- end)

--- NPC Recruit API

local function recruit_npc(npc_id, clone_id)
	Printer:Debug(LOG.RUN, CAT.NPC, "recruiting npc %s", npc_id)
	if clone_id then
		-- npc recruited through Individually recruitable companions mod dialogs (free, paid)
		if npcd.get_npc(npc_id) then
			Printer:Log(LOG.ADD, CAT.CONF, "recruiting npc %s through clone %s", npc_id, clone_id)			
			-- npc profile already exists, remap to the clone id
			if npcd.remap_npc(npc_id, clone_id) then
				npcd.set_recruited(clone_id, true)	
			else
				-- cannot remap - there was a problem
				Printer:Log(LOG.ERROR, CAT.NPC, "cannot remap npc %s to new id %s", npc_id, clone_id)
			end
		else
			Printer:Log(LOG.WARN, CAT.NPC, "recruiting through clone where only the clone %s exists", clone_id)
			npcd.set_recruited(clone_id, true)
		end
	else
		-- npc recruited through vanilla squad joining dialog (can be 1 npc or more at the same time)
		npcd.set_recruited(npc_id, true)
	end
end

function ncpd_recruit(npc_id, clone_id)
	if not NPCD_BOOTED then return end
	recruit_npc(npc_id, clone_id)
end

--- NPC DEATH Callback

function squad_on_npc_death(squad,se_npc)
	Printer:Trace(LOG.RUN, CAT.NPC,"squad_on_npc_death")
	local npc = npcdu.get_npc_obj(se_npc.id)
	if not npc then return end
	local npc_id = npc:id()
	if npcd.get_npc(npc_id) then
		Printer:Debug(LOG.WARN, CAT.NPC,"squad_on_npc_death npc %s name %s", npc_id, npc:name())
		release_npc(npc_id)
		Printer:Debug(LOG.REMOVE, CAT.NPC,"dead npc %s released", npc_id)
		for id,actor_squad in pairs(axr_companions.companion_squads) do
			if squad.id == actor_squad.id then
				SendScriptCallback("npcd_squad_update")
			end
		end
	end
end

--------------- SQUAD UPDATES (abilities registration)

function npcd_squad_abilities_registration()
	Printer:Debug(LOG.RUN, CAT.NPC,"npcd_squad_abilities_registration")
	local clist = npcd_squad.squad_get_clist()
	-- re-configure all squad abilities
	for i=1, #clist do
		local npc = npcdu.get_npc_obj(clist[i])
		if npc and npc:alive() then
			local npc_id = npc:id()
			register_abilities(npc_id)
		end
	end

	update_actionbar()
	return true
end

local current_clist
local function do_npcd_squad_update()
	Printer:Debug(LOG.RUN, CAT.NPC,"do_npcd_squad_update")
	local new_clist = npcd_squad.squad_get_clist()

	local added_ids, removed_ids = npcdu.compute_diff(new_clist, current_clist)

	-- update removed squad members
	for i=1, #removed_ids do
		local npc = npcdu.get_npc_obj(removed_ids[i])
		if npc and npcd.get_npc(npc:id()) then -- check if npc was released during squad_on_npc_death event
			unregister_abilities(npc:id())
			npcd.set_recruited(npc:id(), false)
		end
	end

	-- update new squad members 
	-- TODO 1 this can be removed if we create the npc profile on npc dialog window
	-- TODO 2 this now is only to cover the case where an entire squad joins
	-- TODO 3 maybe we should not recruit and register non profiled npc automatically
	for i=1, #added_ids do
		local npc = npcdu.get_npc_obj(added_ids[i])
		if npc and npc:alive() then
			recruit_npc(npc:id())
		end
	end
	current_clist = new_clist
	SendScriptCallback("npcd_post_squad_update")
	CreateTimeEvent("npcd_manager", "npcd_squad_abilities_registration", 1, npcd_squad_abilities_registration)
	return true
end

local function npcd_squad_update()
	Printer:Debug(LOG.RUN, CAT.NPC,"npcd_squad_update")
	CreateTimeEvent("npcd_manager", "do_npcd_squad_update", 1, do_npcd_squad_update)
end

--------------- NPCD STATE MGMT

function save_state(m_data)
	Printer:Log(LOG.ADD, CAT.CONF,"NPCDeck Save State")
    if not m_data.npcd then
        m_data.npcd = {}
    end 
    -- save the state
    m_data.npcd.npcs = npcd.get_deck()
	Printer:LogTable("NPCDeck", m_data.npcd.npcs)
end

function load_state(m_data)
	if not Printer then
		get_printer()
	end
	Printer:Log(LOG.ADD, CAT.CONF,"NPCDeck Load State")
	if m_data.npcd and m_data.npcd.npcs then
        -- cache the state
        npcd.set_deck(m_data.npcd.npcs)
		Printer:LogTable("NPCDeck", npcd.get_deck())
	end
	SendScriptCallback("npcd_on_loaded_state")
end

-- NPCD LIFECYCLE

local tg_update = 0
local tg_update_step = 500 --[ms]
function actor_on_update()

	local tg = time_global()
	if tg < tg_update then
		return
	end
	tg_update = tg + tg_update_step

	npcd_squad.update_squad_info()

	-- printlog_table("Stalkers", stalkers)
end

function actor_on_net_destroy()
	teardown_npcd_execution()
end

--- MODULE REGISTRATION and MGMT

function register_module(deck)
	printf("-[NPCD][MAIN] Manager register module %s", deck.module)
	npcd.add_module_perks(deck.module, deck.perks)
end

function update_module(deck)
	Printer:Log(LOG.RUN, CAT.CONF,"Manager update module %s", deck.module)
	npcd.update_module_perks(deck.module)
	SendScriptCallback("npcd_squad_update")
end

---- 

function game_object_on_net_spawn(obj)
	if (IsStalker(obj) and obj:alive() and obj:id() ~= 0 and obj:character_community() ~= "zombied") then
		if npcd.add_npc(obj:id()) then
			printf("-[NPCD][MAIN] new npc added id:%s, name:%s, character_name:%s, faction:%s", obj:id(), obj:name(), obj:character_name(), obj:character_community())
		end
	end
end

-- function game_object_on_net_spawn(obj)
-- 	if (IsStalker(obj) and obj:alive()) then	
-- 		printf("-[NPCD][MAIN] NPC spawned id:%s, name:%s, character_name:%s, community:%s, rank:%s, reputation:%s, goodwill:%s, general_goodwill:%s", obj:id(), obj:name(), obj:character_name(), obj:community(), obj:rank(), obj:reputation(), obj:goodwill(), obj:general_goodwill())
-- 	end
-- end


function actor_on_first_update()
	Printer:Log(LOG.START, CAT.EXEC,"Manager actor_on_first_update")
end

function on_option_change()
	-- update_actionbar()
end

---- BOOT

NPCD_BOOTED = false

function check_can_boot()
	local plist = npcd.get_perks_id_list()
	NPCD_BOOTED = (#plist > 0)
	return NPCD_BOOTED
end

function game_play_start()
	if(device().precache_frame > 1) then --detects if game is not past the press any key prompt
		return
	end
	--setup your thing here
	UnregisterScriptCallback("actor_on_update", game_play_start)
	Printer:Log(LOG.START, CAT.EXEC,"Manager game_play_start")
	check_can_boot()
	if not NPCD_BOOTED then
		UnregisterScriptCallback("squad_on_npc_death", squad_on_npc_death)
		UnregisterScriptCallback("npcd_squad_update", npcd_squad_update)
		UnregisterScriptCallback("on_option_change", on_option_change)
		UnregisterScriptCallback("load_state", load_state)
		UnregisterScriptCallback("save_state", save_state)
		UnregisterScriptCallback("game_object_on_net_spawn", game_object_on_net_spawn)
		UnregisterScriptCallback("actor_on_first_update", actor_on_first_update)
		return
	end
	-- NPCD BOOTING
	Printer:Log(LOG.START, CAT.EXEC, "NPCD BOOTED")
	npcd_squad.update_squad_info()
	current_clist = npcd_squad.squad_get_clist()
	start_npcd_execution()
	update_actionbar()
	SendScriptCallback("npcd_started")
	RegisterScriptCallback("actor_on_update", actor_on_update)
end

function actor_on_first_update()
    printf("$[NPCD][Main] npcd_manager actor_on_first_update")
end

function on_game_start()
	printf("$[NPCD][MAIN] npcd_manager on_game_start")
	RegisterScriptCallback("actor_on_update", game_play_start)
	RegisterScriptCallback("squad_on_npc_death", squad_on_npc_death)
	RegisterScriptCallback("npcd_squad_update", npcd_squad_update)
	RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("actor_on_net_destroy",actor_on_net_destroy)
	RegisterScriptCallback("game_object_on_net_spawn", game_object_on_net_spawn)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	get_printer()
end

-- npcd_manager.debug_set_goodwill()
-- npcd_manager.debug_set_community_goodwill()

function debug_set_goodwill(npc_id, goodwill)
	local npc = npcdu.get_npc_obj(npc_id)
	if npc then
		npc:set_goodwill(goodwill, db.actor)
		printf("- npc relation %s", npc:relation(db.actor))
	end
end

function debug_set_community_goodwill(npc_id, goodwill)
	local npc = npcdu.get_npc_obj(npc_id)
	if npc then
		npc:set_community_goodwill(character_community(db.actor), goodwill)
		printf("- npc relation %s", npc:relation(db.actor))
	end
end